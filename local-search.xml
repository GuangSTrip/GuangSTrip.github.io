<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>朝花夕拾</title>
    <link href="/20240816/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/"/>
    <url>/20240816/%E6%9C%9D%E8%8A%B1%E5%A4%95%E6%8B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="我的目标"><a href="#我的目标" class="headerlink" title="我的目标"></a>我的目标</h2><p>情况简介：本人刚刚北航毕业，23年考研北深计算机差一分没进复试，计划申请25Spring或25Fall的出国留学，目标是<strong>新国立AI</strong></p><ul><li>长期目标<ul><li>申请2025年的出国留学，理想目标新国立AI，由于资历欠缺，不是很敢申请Phd，需要根据申请时的科研情况决定</li><li>找一个想做且高薪的工作，在愉快工作的同时，能够有足够的钱来满足家庭开销</li><li>健康生活：锻炼体能恢复 + 早睡早起</li><li>时间管理：锻炼至有意识有意义地使用自己的每一分每一秒</li></ul></li><li>短期目标<ul><li><del>Synapse BraTS 2024 脑胶质瘤切割比赛（已完成）</del></li><li>准备2025 Spring NUS AI 申请</li><li>TinyBeauty系列研究（目标是九月份发表论文）</li><li><del>myGCLs系列研究（目标是九&#x2F;十月份发表论文）（已放弃）</del></li><li>广州实验室线下实习（刚起步）</li></ul></li></ul><p>每周总结将从工作 + 健康 + 人际关系三个方面来总结本周的经历，并且规划下周所需要完成的事情</p><h2 id="20240822-20240828-每周总结（20240901补）"><a href="#20240822-20240828-每周总结（20240901补）" class="headerlink" title="20240822~20240828 每周总结（20240901补）"></a>20240822~20240828 每周总结（20240901补）</h2><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>主线：</p><ul><li><p>TinyBeauty实验</p><ul><li>在周末到开会前赶着完成了一些尝试，制造了三种Style的人造数据用于训练，实测效果是有所提升的。但是有一个关键的问题是，对照试验没有做好，没有办法确定是人造数据带来的提升，还是用于生成人造数据的原始数据所带来的提升，在下周需要补足这个实验来进行对比</li><li>这星期的时间耗费在了造数据和训练上，nnUNet的训练时间依旧是玄学，对于快的机器6s&#x2F;epoch，慢的机器却要25s&#x2F;epoch</li></ul></li><li><p>实验室实习</p><ul><li>这周终于是进入实验室了！熟悉了上班的时间和地点，大概搞清楚了实验室所要作的PCB缺陷多分类任务</li><li>不过催了半天入职程序还是没有弄完，这就是公家实验室的速度么qwq</li></ul></li><li><p>留学事项</p><ul><li>本周成功完成了BraTS的汇报，可以拿到推荐信啦</li><li>继续对State of Purpose（SOP）继续进行修改（估计还得改几版），机构老师写得实在是一言难尽</li></ul></li></ul><p>支线-拓展学习：</p><ul><li>收藏了很多视频，但是每天下班了就去玩了，总是没有静下心来学习，下周一定要把这些存货清掉</li></ul><h3 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h3><p><strong>本周体重：未测量</strong></p><ul><li>上了一次课，主要是锻炼了上肢，手关节肌肉酸了好几天，还是锻炼太少啦</li></ul><h3 id="生活-amp-人际关系"><a href="#生活-amp-人际关系" class="headerlink" title="生活 &amp; 人际关系"></a>生活 &amp; 人际关系</h3><ul><li>周末去亲戚家坐了坐，聊了一下近况，他们家的智能开关好好玩，有机会以后也在家弄弄</li><li>来实验室这边认识了舍友（可惜舍友刚好第二天请假回家了），聊了很多这边的事情，算是有了一个大致的了解</li><li>见到了实验室的同事和领导，但是还不太敢有太多的交流，希望下周能混熟一点，搞清楚实验室的情况以及生活情况</li></ul><h3 id="本周总结"><a href="#本周总结" class="headerlink" title="本周总结"></a>本周总结</h3><p>​<em>唯热爱可抵岁月漫长</em></p><p>​这周算是一个关键的时间节点吧，来到了一个新的实验室环境，也是第一次真正进入了工作这个阶段，虽然是暂时的，但是希望无论是从心态上，还是从经历上，我都能完成从学生到社会人的一个转变。虽然是进入了实验室，但是初来乍到还是有一些畏畏缩缩，不敢交流，后面至少要认识所有人，最好能和他们混到一起，这样才是我来此的目的，而且认识的人也都是日后潜在的人脉资源。原本我以为我作为实习生可能会被轻易打发，但是现在看来我应该是能做点事情的，有了这个机会，就要好好把握住。</p><p>​另外线上实习方面，本周仍是有一点懈怠，其原因我认为有两点，一个是线下上班了有点懈怠，经常下班了就放纵自己停止思考，另一个原因是对做的事情缺乏认真的思考和兴趣培养，导致做起来动力不足，总想拖延。这周学长也让我去研究另一个东西，我一定要打起精神来，尽早给学长反馈，这样才能跟着学长做更多有趣的东西。</p><p>​最后是生活方面，这周来到了一个新的环境，我觉得这个环境十分的不错，既可以让我学到东西，也保证了一定的生活水准，一定要好好珍惜。接下来就是要做到内外结合，对内调整个人作息，在熟悉了工作规律后安排合适的时间去运动健身，对外要积极去研究周围环境，搞清楚公园、健身房、购物这些事项，进一步<strong>有意识的把控自己的生活，而不是几个月后浑浑噩噩恍然今日</strong>。</p><h3 id="下周计划"><a href="#下周计划" class="headerlink" title="下周计划"></a>下周计划</h3><ul><li>工作<ul><li>TinyBeauty——完成对照组实验</li><li>PET-Reconstruction——完成复现并且把Auxiliary Guidance扒下来</li><li>实验室——完成模型调研，并复现两个大模型</li></ul></li><li>健康<ul><li>调整一个规律的作息</li><li>观察确定去哪个健身房</li></ul></li><li>生活 &amp; 人际关系<ul><li>给宿舍弄一个小衣柜</li><li>加上实验室每一个人的微信，搞清楚实验室的业务情况</li></ul></li></ul><h2 id="20240815-20240821-每周总结-（20240822补）"><a href="#20240815-20240821-每周总结-（20240822补）" class="headerlink" title="20240815~20240821 每周总结 （20240822补）"></a>20240815~20240821 每周总结 （20240822补）</h2><blockquote><p>这周还是玩心太重，总是堕落</p></blockquote><h3 id="工作-1"><a href="#工作-1" class="headerlink" title="工作"></a>工作</h3><p>主线：</p><ul><li><p>TinyBeauty实验：推进很慢</p><ul><li>设计了具体的2D实验方案，但并没有完成太多</li></ul></li><li><p>myGCLs实验复现并联系老师</p><ul><li><p>思考了很久还是决定放弃了，一方面是这个项目我并不想做，另一个方面是它的推进慢未知程度高</p></li><li><p>感觉很对不起老师的帮助，但或许有时候就是不能要脸，做出客观的选择</p></li></ul></li><li><p>实验室实习</p><ul><li>在决定放弃myGCLs的实验后，联系了实验室并确定了下周一入职</li></ul></li><li><p>留学事项</p><ul><li>和留学机构完成了两封推荐信的底稿攥写，其中一篇需要修改，目前尚未修改好</li><li>完成了SOP的第一版，感觉内容有一些冗长，并且上下文不连贯，不能很好体现个人的成长，正在进行下一步修改</li></ul></li></ul><p>支线-拓展学习：</p><ul><li>&#x3D;&#x3D;本周玩心太重，并没有在学习其他的拓展视频 or 书籍&#x3D;&#x3D;</li></ul><h3 id="健康-1"><a href="#健康-1" class="headerlink" title="健康"></a>健康</h3><p><strong>本周体重：77.25kg</strong></p><ul><li>本周的锻炼积极性有所下降，因为没有规律作息而懈怠了，总共去了两次有氧</li></ul><h3 id="生活-amp-人际关系-1"><a href="#生活-amp-人际关系-1" class="headerlink" title="生活 &amp; 人际关系"></a>生活 &amp; 人际关系</h3><ul><li>本周作息有些混乱，需要调整</li><li>高中宿舍聚会，见到了另外五个同学（没全），一起玩了《罪恶演绎》剧本杀，玩起来十分新奇，整体感觉很好，玩完还去了稻香喝晚茶</li><li>周末去了亲戚家（有两只猫），同亲戚聊了一下近况，也咨询了相关的看法，收获良多。</li></ul><h3 id="本周总结-1"><a href="#本周总结-1" class="headerlink" title="本周总结"></a>本周总结</h3><p>​<em>当你在凝视深渊的时候，深渊也正在凝视着你</em></p><p>​永远不要相信自己的自律性，当诱惑触手可得，你无法保证自己能抵制诱惑，最好的办法就是<strong>隔绝诱惑</strong>。</p><p>​本周就是堕入深渊的一周，当诱惑摆在面前我没能经受住，在抉择时放弃了思考，将本应用来干正事的时间花费在了无意义的游戏或刷短视频上。这导致了我在工作、健康上这周的表现不尽人意，<strong>很多计划要做的事情都没做到，导致任务不断拖延而且心理上的压力也越来越大。</strong>或许这就是所谓的自律才能带来自由吧，只有完成的预定的计划，才能有更多的时间去自由地做其他事情，而像这周这样，时间都花费在了无意义的内耗上，反而是禁锢住了自己。痛定思痛，下周要开始线下实习了，从现在开始改善作息，积极完成任务，才能成为更好的自己。</p><h3 id="下周计划-1"><a href="#下周计划-1" class="headerlink" title="下周计划"></a>下周计划</h3><ul><li>工作<ul><li>TinyBeauty——完成未完成的任务（完成SSA数据扩充+下游任务效果对比）</li><li>TinyBeauty——<strong>待定，需周末像学长汇报后再确认</strong></li><li>实习——办理入职，搞清楚实习任务，判断是否适合自己</li><li>留学——跟进推荐信事项</li><li>留学——完善SOP</li><li>留学——NUS春季学期提交</li></ul></li><li>健康<ul><li>私教课一堂</li><li>探索实验室周围环境（实验室 &amp; 公园），规划锻炼计划</li></ul></li><li>生活 &amp; 人际关系<ul><li>认识实验室同事</li><li>熟悉实验室新环境</li><li>去亲戚家坐坐（周末）</li></ul></li></ul><h2 id="20240808-20240814-每周总结（20240816补）"><a href="#20240808-20240814-每周总结（20240816补）" class="headerlink" title="20240808~20240814 每周总结（20240816补）"></a>20240808~20240814 每周总结（20240816补）</h2><blockquote><p>第一次开始写每周总结，有些拖延，拖延到第三天才完成。</p></blockquote><h3 id="工作-2"><a href="#工作-2" class="headerlink" title="工作"></a>工作</h3><p>主线：</p><ul><li><p>TinyBeauty实验：尝试了上周学长给的三个任务</p><ol><li>为非大脑区域添加Mask查看效果</li><li>尝试高质量到高质量数据的生成</li><li>尝试增加训练数据并检验效果</li></ol><p><em>该部分工作的完成积极性不高，实际上是拖到了组会前一天勉强完成，后续需要调整心态积极完成，因为自己主动完成后续才有希望完成论文发表</em></p></li><li><p>myGCLs实验复现并联系老师</p><ul><li>找到了大部分实验结果的实验配置并且尝试复现出来了，仍存在边增强的情况未找到合适配置，但咨询学长后暂时不予考虑</li><li>向老师进行了汇报，老师提出后续还需商讨下一步研究方向（目前尚未有进一步回复）</li></ul></li><li><p>留学事项</p><ul><li>和留学机构进行了简单的沟通，暂时确认先不考GRE</li><li>完成了推荐人基本资料表格</li><li>完成了个人项目经历（略有拖欠，比原定计划晚了四天完成）</li></ul></li></ul><p>支线-拓展学习：</p><ul><li>学习了b站上UP主<strong>AliAbdaal</strong>的时间管理三部曲，并且做了相应的<a href="https://guangstrip.github.io/20240809/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E4%B8%89%E9%83%A8%E6%9B%B2%E7%AC%94%E8%AE%B0/">笔记记录</a>，主要内容包括①五个关于时间管理的心态②五个最大的时间黑洞③五项有效提升时间管理的技能。（注：十分容易忘记，需要时常回顾提醒自己）</li></ul><h3 id="健康-2"><a href="#健康-2" class="headerlink" title="健康"></a>健康</h3><p><strong>本周体重：77.5kg</strong></p><ul><li>8.8 8.9 8.10 8.14 8.15都去了健身房有氧，时间40min左右</li><li>8.15（周一）第一次上了课，主要是腿部的激活训练，包括平地上的热身、臀部激活，以及器械的臀部训练和腿部的提杆训练<ul><li>由于太久没有大强度运用，上课过程中有一些眩晕的感觉，教练冲了一杯葡萄糖水给我立马见效，着实神奇</li></ul></li></ul><h3 id="生活-amp-人际关系-2"><a href="#生活-amp-人际关系-2" class="headerlink" title="生活 &amp; 人际关系"></a>生活 &amp; 人际关系</h3><ul><li>解决一直拖延没有处理的衣物和杂物，将他们归类放好</li><li>对房间的桌面进行了整理，变得更为整洁了</li><li>8.10（周六）同时参加了亲戚的生日聚餐，也同时参加了高中同学的生日聚餐，见到了很多亲戚和高中同学</li></ul><h3 id="本周总结-2"><a href="#本周总结-2" class="headerlink" title="本周总结"></a>本周总结</h3><p>​<em>一念神魔</em></p><p>​总的来讲，本周的积极向上与自甘堕落相结合。<strong>工作</strong>的主线方面有一定的进展，但并没有太高的效率，时常是确定了目标后就一直拖延，将时间耗费在了无意识的刷视频和游戏上，可能本质上还是对任务困难的一种逃避。在支线学习上，我学习了时间管理三部曲，确实是深刻感受到了时间管理的重要性和这些方法的有效性。但可惜的是未能坚定去锻炼时间管理，有时候人堕落了就会放弃思考，一错再错。所以在下一周，我要努力锻炼，在做好时间管理的同时，相信也能有效提升做事的效率。在<strong>健康</strong>方面，我开始逐渐习惯了拥有运动的生活，虽然由于长期没有运动导致身体有一些虚，但是相信后续的锻炼能够越来越好。<strong>生活</strong>方面我完成了一直拖欠的物品整理，同时也与亲戚和朋友碰面，感觉稍微脱离出了整日宅家的生活。</p><h3 id="下周计划-2"><a href="#下周计划-2" class="headerlink" title="下周计划"></a>下周计划</h3><ul><li>工作<ul><li>TinyBeauty——衍生数据集 + nnUNet的优化效果检验（排列组合，包括高质量和低质量的衍生数据集）</li><li>myGCLs——MLP优化实验</li><li>myGCLs——与老师跟进（不方便太push老师，预计在周日&#x2F;周一再进行询问）</li><li>留学——跟进推荐信事项</li></ul></li><li>健康<ul><li>7天至少4次有氧</li><li>再上一次课（锻炼上肢）</li></ul></li><li>生活 &amp; 人际关系<ul><li>高中宿舍聚会（周四）</li><li>去亲戚家坐坐（周末）</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>时间管理三部曲笔记</title>
    <link href="/20240809/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E4%B8%89%E9%83%A8%E6%9B%B2%E7%AC%94%E8%AE%B0/"/>
    <url>/20240809/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E4%B8%89%E9%83%A8%E6%9B%B2%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="第一章节：视频《想搞副业挣钱但没时间？【时间管理】是实现经济独立的第一步》"><a href="#第一章节：视频《想搞副业挣钱但没时间？【时间管理】是实现经济独立的第一步》" class="headerlink" title="第一章节：视频《想搞副业挣钱但没时间？【时间管理】是实现经济独立的第一步》"></a>第一章节：视频《<a href="https://www.bilibili.com/video/BV17E421w7D9?spm_id_from=333.1245.0.0">想搞副业挣钱但没时间？【时间管理】是实现经济独立的第一步</a>》</h3><p>一、关于时间管理的五个心态</p><ol><li><p>时间管理是一个十分有价值的技能</p><p>​时间是稀缺的不可再生资源：我们可以赚更多的钱，但我们不可能再生更多的时间</p><p>​时间是如此珍贵，时刻想象自己十年后是否会后悔现在浪费了年轻时的时间和精力</p></li><li><p>你可以想做任何事情，但不可能所有都真正做到</p><p>​时间管理的一个关键是<strong>优先级排布</strong>，有选择地放弃某些东西，才能更好地聚焦时间和精力</p><p>​<strong>“候诊室永远不会是空着的，唯一能做的是以更好的状态去面对更优先的事情“</strong></p></li><li><p>维持生命并不是目标</p><p>​维持生命的事项只是在保证生存，需要有”进步”事项来让你感觉到成就感</p><p>​设立目标：从现在起的12个月后，你想庆祝什么？（In Work &#x2F; Health &#x2F; Relationship）</p><p>​（我想去到心仪的学校，提升学历，获得更多的技能与成果 &#x2F; 减肥成功 &#x2F; 认识更多的资源和人脉）</p><p>​<strong>并不是对幸福的追求让我们满足，而是追求的过程本身就很幸福</strong></p></li><li><p>意向性心态（有意识的使用时间）</p><p>​不应为无意识地使用时间而自责</p><p>​<strong>但是</strong>，变得擅长管理时间的关键就在于——努力做到有意识地使用每一小段时间</p><p>​<strong>生产力与意向性挂钩</strong>，如若是有意识地做某件事，那么这件事就是有意义的</p></li><li><p>把自己当成机器人</p><p>​我们不会责怪机器人，只会思考可能是代码错误了</p><p>​当我们荒废时间时，往往会产生很多负面能量，如若把自己当作机器人，我们知道<strong>这只是系统并没有起作用</strong></p><p>​We just need to tweak the system rather than beating ourselves up</p><p>​很多人只知道失败了，认为自己很失败，但没有后退一步想清楚失败的原因</p></li></ol><h3 id="第二章节：视频《别浑浑噩噩地掉进这5个时间黑洞，却问“时间都去哪了”》"><a href="#第二章节：视频《别浑浑噩噩地掉进这5个时间黑洞，却问“时间都去哪了”》" class="headerlink" title="第二章节：视频《别浑浑噩噩地掉进这5个时间黑洞，却问“时间都去哪了”》"></a>第二章节：视频《<a href="https://www.bilibili.com/video/BV1d4421Z7Hx/?spm_id_from=333.999.0.0&vd_source=d8a05635f6adb9d3c59be246064bfdab">别浑浑噩噩地掉进这5个时间黑洞，却问“时间都去哪了”</a>》</h3><p>如何管理业余时间？——要了解<strong>5个最大的时间黑洞</strong>：</p><ol><li><p>社交媒体Social Media</p><p>​要带着目的去使用社交媒体（大多数人是无意识就打开了、无意义的刷任何东西）</p><p>​社交媒体的公司就是为了<strong>劫持我们的注意力</strong>，由于算法的存在，我们永远不可能把所谓的新闻看完</p><p>​睡前刷抖音并不能带来放松</p><p>​控制方法：使用前缓一缓，核心是增加使用这些无意义媒体的启动速度，减少我们的无意识行为</p><p>​ 尝试把手机上的无意义软件删除，把自己当作机器人，审视输入的内容</p></li><li><p>新闻News</p><p>​新闻的目的是点击率和热度，并不是想给观众普及信息，习惯性看新闻其实并没有太大收益</p><p>​<strong>应该带着目的去读新闻，而不是被动接收信息</strong></p><p>​控制方法：先找到确实想要了解的讯息，再专门分配时间去收集相关信息</p></li><li><p>电视TV（可以延伸出刷视频）</p><p>​一个人刷视频 &#x3D; <strong>时间杀手的时间黑洞</strong></p><p>​一段时间后回看其实会发现戒断这些内容其实并没有多怀念，相反多余的时间可以被用来学习更多有意义的东西</p></li><li><p>家务Chores</p><p>​<strong>家务是为了维持我们的生命，不得不做的事</strong>，大部分家务都可以被<strong>删除、自动化或外包</strong></p><p>​通过外包（置换）：用自己较少时间赚的钱去购买别人的大量时间，从而减少自己所花费的时间</p><p>​<strong>金钱和时间实际上是可以互换的，可以用钱买回时间</strong></p></li><li><p>耗尽了时间碎片Squandering The Spare Minutes</p><p>​<strong>我们都倾向于浪费掉碎片的时间</strong>：在去做某件事前的小段时间里，我们常处于一种无所事事的悬空状态</p><p>​最关键要意识到的是：<strong>every minute counts</strong>，无论时间多短，只要有意识地去利用，都会有所收获，哪怕专门用于休息，也是有意义地</p></li></ol><h3 id="第三章节：视频《关于时间管理你一定要掌握的5项实用技能》"><a href="#第三章节：视频《关于时间管理你一定要掌握的5项实用技能》" class="headerlink" title="第三章节：视频《关于时间管理你一定要掌握的5项实用技能》"></a>第三章节：视频《<a href="https://www.bilibili.com/video/BV13S42197qU?spm_id_from=333.1245.0.0">关于时间管理你一定要掌握的5项实用技能</a>》</h3><p>​五项能够有效帮助提升时间管理能力的技能</p><ol><li><p>优先级管理Prioritisation</p><p>​并不是“我没有时间”做某件事，<strong>问题的核心从来不是我们没有时间， 而是我们想做的事情的优先级还不够高</strong> </p><p>​实用方法：</p><p>​目标：知道自己真正想要什么，并且转化为目标，能够有效管理事务的优先级</p><p>​每日探险：<strong>The Daily Adventure</strong>（今天想要完成的最重要的事情是什么）</p><p>​确认自己的“探险任务”是什么，然后在日程表中分配时间块</p><p>​支线任务：<strong>The Side Quest</strong>（一些提升自己的小任务，例如健身、维持人际关系）</p><p>​在确认了探险后，再来添加支线任务，并且为其分配时间块</p><p>​每周回顾：<strong>Weekly Review</strong>（每周花费20分钟反思上一周过的如何，而后为下一周制定一系列的优先事项）</p></li><li><p>时间块管理Time Block</p><p>​对任何事情（运动、休息）分配时间块都有意义，而并非只留意重要的事项</p><p>​使用时间块的三个层次：</p><p>​①记录琐事（备忘录）</p><p>​②标记出每天要做的所有事情（甚至包括通勤时间，对自己的一整天的时间分配有清晰的把控）</p><p>​③理想周（健康、工作、生活，每周都能向习惯一样为这些事务分配稳定的时间块）</p></li><li><p>专注力Focus</p><p>​<strong>Focus is a skill that can be honed and learned and developed</strong>（专注力是可以培养的，而大多数人没有主动尝试过提高专注力）</p><p>​核心：<strong>单一任务原则</strong>，不要在同一时间处理多个任务，任务间切换所浪费的时间会比专注完成任务平均多花费25%~27%</p><p>​专注力的好处：专注涉及了工作内外</p><p>​工作中专注可以使得工作被及时完成而不需要拖到晚上或周末，因此空余时间就可以被你自由利用</p><p>​工作外专注做某件事（在时间块分配的期间内）可以让你充分利用时间，而不是在时间耗尽后发现事情没完成或效率低而感到劳累 </p></li><li><p>执行力Follow-Through</p><p>​执行力就是<strong>Doing what you say you’re going to do</strong>，这是一个很罕见的节能</p><p>​缺乏执行力的表现： 当你已经规划好了时间块，但是当计划的时间到来却因为某些事情（借口）而未能如期去做，转而去刷短视频</p><p>​如何应对拖延症（执行力差）？</p><p>​①解锁方法Unlock Method：</p><p>​内容清晰Clarity（克服不确定性带来的障碍） + </p><p>​鼓足勇气Courage（当某件实现涉及不适，例如运动，往往会带来心理压力和恐惧） + </p><p>​开始行动Getting Started（惯性带来的阻碍需要一点动力和阻力来带动）</p><p>​②找到责任感Finding Accountability：</p><p>​通过他人来寻找的完成计划的责任感，进而降低对自身意志力、内驱力或自律的依赖（利用周围人的力量）</p><p>​ </p></li><li><p>让工作充满精力Energising your work</p><p>​<strong>当你学会时间管理后，瓶颈往往不是时间，而是精力</strong>（即使你安排好了时间块，你也没有精力或者意识去完成）</p><p>​如何让工作充满精力？——<strong>3P要素</strong>：Play + Power + People（视频结束了，这个内容没有讲解）</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>时间管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日志</title>
    <link href="/20220706/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/"/>
    <url>/20220706/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<p><strong>注意：博客内容具有主观上和时间上的局限性，请谨慎参考！！</strong></p><h4 id="2022-7-6"><a href="#2022-7-6" class="headerlink" title="2022-7-6"></a>2022-7-6</h4><ul><li><strong>博客创建</strong></li><li>上传：2022春面向对象课程的四次单元总结</li><li>上传：2022春操作系统各lab实验报告</li><li>上传：2022操作系统实验的部分笔记<ul><li>只整理了lab3~lab5的笔记，别的偷懒没做</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OSlab4-challenge实验报告</title>
    <link href="/20220630/OSlab4-challenge%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/20220630/OSlab4-challenge%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="lab4-challenge实验报告"><a href="#lab4-challenge实验报告" class="headerlink" title="lab4-challenge实验报告"></a>lab4-challenge实验报告</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​lab4的挑战性任务要求实现基础的多线程和信号量功能。由于时间所限，笔者完成了要求的基础函数，以及部分搭配使用的函数，除此之外对于原先有的系统架构进行了部分修改，以满足多线程的实现，下面内容会从实现方式和测试两部分展开。</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程架构介绍"><a href="#线程架构介绍" class="headerlink" title="线程架构介绍"></a>线程架构介绍</h3><p>​在原先的架构中，进程既是资源分配的单位，有是系统调度的单位。引入线程的概念后，资源分配的单位仍旧是进程，但系统调度的单位则变成了线程，因此在完成相应线程接口之前，首先要对原先的系统进行一定的修改，包括修改调度对象让线程控制上下文、将程序载入到线程而非进程中、进程的销毁等，而后再拓展系统调用以及用户态的线程函数接口。</p><h3 id="线程控制块"><a href="#线程控制块" class="headerlink" title="线程控制块"></a>线程控制块</h3><p>​类似于进程，我们要有一个控制块来记录线程的信息，我设置了Pth，其架构如下。除此之外，笔者选择将控制块直接存储在Env的控制块中，便于进程对自己线程的管理，笔者限定了每个进程最多有8个线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> &#123;</span><br>       ...<br>        <span class="hljs-comment">//lab4-challenge-Pth</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pth</span> <span class="hljs-title">env_pth</span>[8];</span><br>        u_int env_pth_num;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pth</span> &#123;</span><br>        <span class="hljs-comment">//environment</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">pth_tf</span>;</span><br>        LIST_ENTRY(Pth) pth_link;<br>        <span class="hljs-comment">//message </span><br>        u_int pth_id;<br>        u_int pth_status;<br>        u_int pth_pri;<br>        u_int pth_in_ienv;<br>        u_int pth_envid;<br>        LIST_ENTRY(Pth) pth_sched_link;<br>        <span class="hljs-comment">//join </span><br>        LIST_ENTRY(Pth) pth_joined_link;<br>        LIST_HEAD(Pth_joined_list, Pth);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pth_joined_list</span> <span class="hljs-title">pth_joined_list</span>;</span><br>        <span class="hljs-type">void</span> **pth_join_value_ptr;<br>        u_int pth_detach;<br>        <span class="hljs-comment">//exit </span><br>        <span class="hljs-type">void</span> *pth_exit_ptr;<br>        <span class="hljs-type">int</span> pth_exit_value;<br>        <span class="hljs-comment">//cancel</span><br>        <span class="hljs-type">int</span> pth_cancelstate;<br>        <span class="hljs-type">int</span> pth_canceltype;<br>        u_int pth_canceled;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="底层创建"><a href="#底层创建" class="headerlink" title="底层创建"></a>底层创建</h4><p>​仿照<code>env_alloc</code>实现了<code>thread_alloc</code>当创建线程时都会调用其创建一个线程控制块Pth，并完成一定的初始化。</p><ul><li>类似于循环链表的方式，在Env的Pth线程控制块数组中找到空闲的线程控制块</li><li>而后对该Pth进行一定的初始化，包括基础信息和相应函数所要用的信息<ul><li>值得注意的是，该函数可能在内核态创建进程时调用，因此需要一定的初始化，如有别的设置另外在<code>pthread_create</code>函数中进行设定</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">thread_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, <span class="hljs-keyword">struct</span> Pth **newp)</span> &#123;<br>        <span class="hljs-keyword">if</span> (e-&gt;env_pth_num &gt;= NPTH) &#123;<br>                <span class="hljs-keyword">return</span> -E_NO_FREE_PTH;<br>        &#125;<br>        <span class="hljs-comment">//basic message</span><br>        u_int no = e-&gt;env_pth_num;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (e-&gt;env_pth[no].pth_status != ENV_FREE) &#123;<br>                no = (no + <span class="hljs-number">1</span>) % NPTH;<br>                count++;<br>                <span class="hljs-keyword">if</span> (count &gt;= NPTH) &#123;<br>                        <span class="hljs-keyword">return</span> -E_NO_FREE_PTH;<br>                &#125;<br>        &#125;<br>        e-&gt;env_pth_num++;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pth</span> *<span class="hljs-title">p</span> =</span> &amp;e-&gt;env_pth[no];<br>        p-&gt;pth_id = ((e-&gt;env_id &lt;&lt; <span class="hljs-number">3</span>) | no);<br>        p-&gt;pth_in_ienv = no;<br>        p-&gt;pth_envid = e-&gt;env_id;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread %d in env %d is alloc\n&quot;</span>, p-&gt;pth_id, e-&gt;env_id);<br>        p-&gt;pth_status = ENV_RUNNABLE;<br>        p-&gt;pth_tf.cp0_status = <span class="hljs-number">0x10001004</span>;<br>        p-&gt;pth_tf.regs[<span class="hljs-number">29</span>] = USTACKTOP - <span class="hljs-number">4</span> * BY2PG * no;<br>        <span class="hljs-comment">//exit</span><br>        p-&gt;pth_exit_ptr = (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br>        p-&gt;pth_exit_value = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//cancel</span><br>        p-&gt;pth_cancelstate = THREAD_CANCEL_ENABLE;<br>        p-&gt;pth_canceltype = THREAD_CANCEL_DEFERRED;<br>        <span class="hljs-comment">//join</span><br>        LIST_INIT(&amp;p-&gt;pth_joined_list);<br>        *newp = p;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关于进程创建的修改"><a href="#关于进程创建的修改" class="headerlink" title="关于进程创建的修改"></a>关于进程创建的修改</h4><p>​原先，我们以创建进程来运行程序，但在修改成线程架构后，我们需要在创建进程的同时，创建一个0号线程，将主程序交给该线程来管理。</p><ul><li>在<code>env_alloc</code>中默认调用一次<code>thread_alloc</code>，将0号线程作为运行主程序的载体。</li><li>在<code>load_icode</code>中原先对于env_tf的设置移植到pth_tf上，让线程掌握运行的上下文，并且将pth加入调度队列<code>pth_sched_list</code>。</li><li>在<code>env_create_prioirty</code>中给pth设置其优先级<code>pth_pri</code></li></ul><h4 id="用户接口pthread-create"><a href="#用户接口pthread-create" class="headerlink" title="用户接口pthread_create"></a>用户接口pthread_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> pthread, <span class="hljs-type">void</span> *(*start_rountine)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure><p>​该接口用于在程序中创建相对的“子线程”。主要分为三部分，申请线程控制块Pth、控制块设定、设置线程状态让其进入调度（后续调度部分详细说明）</p><p>​为了实现该接口，创建了<code>syscall_thread_alloc</code>和<code>syscall_set_thread_status</code>的系统调用。</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>​前文提到我们将系统调度的实现交到了线程手上，因此对应的调度需要做出改变。由于基本调度逻辑不变，因此线程状态的种类就照搬了进程的状态。</p><ul><li>用<code>pth_sched_list</code>代替原来的<code>env_sched_list</code>，并在线程创建完成后将其加入调度队列，删去原先的env调度</li><li>同理在<code>sched_yield</code>函数中，完全地用<code>pth_sched_list</code>替换掉<code>env_sched_list</code>即可，基本调度逻辑不变</li></ul><h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p>​既然调度对象改为了线程，那么就要实现对其状态的修改，内核态中可以直接修改，所以我们还要完成用户态可用的系统调用<code>syscall_set_thread_status</code>，本质上就是修改对应线程的状态，并相应的将其加入或取出调度队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_set_thread_status</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, u_int threadid, u_int status)</span> &#123;<br>        <span class="hljs-keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE &amp;&amp; status != ENV_FREE) &#123;<br>                <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pth</span> *<span class="hljs-title">p</span>;</span><br>        <span class="hljs-type">int</span> r;<br>        <span class="hljs-keyword">if</span> ((r = envid2env((threadid &gt;&gt; <span class="hljs-number">3</span>), &amp;e, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        p = &amp; e-&gt;env_pth[threadid &amp; <span class="hljs-number">0x7</span>];<br>        <span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pth_list</span> <span class="hljs-title">pth_sched_list</span>[2];</span><br>        <span class="hljs-keyword">if</span> (status == ENV_RUNNABLE &amp;&amp; p-&gt;pth_status != ENV_RUNNABLE) &#123;<br>                LIST_INSERT_HEAD(pth_sched_list, p, pth_sched_link);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; p-&gt;pth_status == ENV_RUNNABLE) &#123;<br>                LIST_REMOVE(p, pth_sched_link);<br>        &#125;<br>        p-&gt;pth_status = status;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="终止之cancel"><a href="#终止之cancel" class="headerlink" title="终止之cancel"></a>终止之cancel</h3><p>​有条件的终止某个进程，涉及到<code>cancelstate</code>和<code>canceltype</code>两个线程状态</p><h4 id="pthread-cancelstate"><a href="#pthread-cancelstate" class="headerlink" title="pthread_cancelstate"></a>pthread_cancelstate</h4><p>​<code>cancelstate</code>包括<code>THREAD_CANCEL_ENABLE</code>和<code>THREAD_CANCEL_DISABLE</code>两种状态，简单来说就是能否被终止。</p><p>​对此我们实现了<code>pthread_setcancelstate</code>函数，提供修改线程<code>cancelstate</code>的功能，并通过<code>oldvalue</code>返回其原先的状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_setcancelstate</span><span class="hljs-params">(<span class="hljs-type">int</span> state, <span class="hljs-type">int</span> *oldvalue)</span>;<br></code></pre></td></tr></table></figure><h4 id="pthread-canceltype"><a href="#pthread-canceltype" class="headerlink" title="pthread_canceltype"></a>pthread_canceltype</h4><p>​<code>canceltype</code>也包括两种状态：</p><ul><li><code>PTHREAD_CANCEL_DEFERRED</code> 此状态下线程不立刻被删除，而是等到删除点（Cancel Point）才被删除，与<code>pthread_testcancel</code>搭配</li><li><code>PTHREAD_CANCEL_ASYNCHRONOUS</code> 此状态下线程会立即被删除</li></ul><p>同样，我们实现了<code>pthread_setcanceltype</code>函数，提供修改线程<code>canceltype</code>的功能，并通过<code>oldvalue</code>返回其原先的状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_setcanceltype</span><span class="hljs-params">(<span class="hljs-type">int</span> type, <span class="hljs-type">int</span> *oldvalue)</span><br></code></pre></td></tr></table></figure><h4 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h4><p>根据线程的状态来完成立即终止或后续定点终止</p><ul><li>检查<code>cancelstate</code>，若是<code>THREAD_CANCEL_DISABLE</code>则报错</li><li>确认线程能被删除后，检查<code>canceltype</code>，若为<code>THREAD_CANCEL_ASYNCHRONOUS</code>则调用<code>syscall_thread_destroy</code>终止该线程，否则将<code>pth_canceled</code>置为1，表明该线程在遇到<strong>cancelPoint</strong>的时候可以被终止</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span> &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pth</span> *<span class="hljs-title">p</span> =</span> &amp;env-&gt;env_pth[thread &amp; <span class="hljs-number">0x7</span>];<br>        writef(<span class="hljs-string">&quot;cancelstate is %d\n&quot;</span>, p-&gt;pth_cancelstate);<br>        <span class="hljs-keyword">if</span> (p-&gt;pth_cancelstate == THREAD_CANCEL_DISABLE) &#123;<br>                writef(<span class="hljs-string">&quot;cancel failed !!\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        p-&gt;pth_exit_value = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span> (p-&gt;pth_canceltype == THREAD_CANCEL_ASYNCHRONOUS) &#123;<br>                syscall_thread_destroy(thread);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                p-&gt;pth_canceled = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="pthread-testcancel"><a href="#pthread-testcancel" class="headerlink" title="pthread_testcancel"></a>pthread_testcancel</h4><p>​该函数充当了上述<strong>cancelPoint</strong>的角色，当线程调用该函数时，看看是不是延时终止，若是则将其终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_testcancel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">pthread_t</span> thread = syscall_getthreadid();<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pth</span> *<span class="hljs-title">p</span> =</span> &amp;env-&gt;env_pth[thread &amp; <span class="hljs-number">0x7</span>];<br>        <span class="hljs-keyword">if</span> (p-&gt;pth_id != thread || p-&gt;pth_status == ENV_FREE) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p-&gt;pth_canceled &amp;&amp; p-&gt;pth_cancelstate == THREAD_CANCEL_ENABLE) &#123;<br>                p-&gt;pth_exit_value = <span class="hljs-number">-1</span>;<br>                syscall_thread_destroy(p-&gt;pth_id);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>​这部分主要是实现了<code>pthread_join</code></p><h4 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h4><p>​该函数用于实现线程间的同步，具体来说就是将某一线程挂载另一线程后，当另一线程完成后再唤醒该线程，从而安排线程间的调度关系。</p><ul><li>将该线程存入被挂载线程的<code>pth_joined_list</code>中，以便后续唤醒</li><li>将该线程设置为<code>NOT_RUNNABLE</code>，使其无法被调度</li><li>切换线程，使系统继续运行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_thread_join</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, u_int threadid, <span class="hljs-type">void</span> **thread_return)</span> &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pth</span> *<span class="hljs-title">p</span>;</span><br>        pthid2pth(threadid, &amp;p);<br>        <span class="hljs-keyword">if</span> (p-&gt;pth_status == ENV_FREE) &#123;<br>                <span class="hljs-keyword">if</span> (thread_return != <span class="hljs-number">0</span>) &#123;<br>                        *thread_return = p-&gt;pth_exit_ptr;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        LIST_INSERT_HEAD(&amp;p-&gt;pth_joined_list, curpth, pth_joined_link);<br>        curpth-&gt;pth_join_value_ptr = thread_return;<br>        sys_set_thread_status(<span class="hljs-number">0</span>, curpth-&gt;pth_id, ENV_NOT_RUNNABLE);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> *<span class="hljs-title">trap</span> =</span> (<span class="hljs-keyword">struct</span> Trapframe *)(KERNEL_SP - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe));<br>        trap-&gt;regs[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br>        trap-&gt;pc = trap-&gt;cp0_epc;<br>        sys_yield();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="部分细节"><a href="#部分细节" class="headerlink" title="部分细节"></a>部分细节</h3><ul><li><p>线程id有进程id和其在进程中的控制块编号组成，即 <code>(envid &lt;&lt; 3) | i</code></p></li><li><p>给每个线程分配栈空间采用了固定分配<code>p-&gt;pth_tf.regs[29] = USTACKTOP - 4 * BY2PG * i;</code></p></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="一、pthread-create-amp-pthread-exit测试"><a href="#一、pthread-create-amp-pthread-exit测试" class="headerlink" title="一、pthread_create &amp; pthread_exit测试"></a>一、pthread_create &amp; pthread_exit测试</h4><p>测试程序如下，主要测试了线程能否被正常创建且传递参数，以及exit函数能否正常终止线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib.h&quot;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">fun1</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>        <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>        writef(<span class="hljs-string">&quot;create success!\n&quot;</span>);<br>        writef(<span class="hljs-string">&quot;arg[0] is %d\n&quot;</span>, ((<span class="hljs-type">int</span> *)arg)[<span class="hljs-number">0</span>]);<br>        writef(<span class="hljs-string">&quot;arg[1] is %d\n&quot;</span>, ((<span class="hljs-type">int</span> *)arg)[<span class="hljs-number">1</span>]);<br>        pthread_exit(&amp;r);<br>        writef(<span class="hljs-string">&quot;arg[2] is %d\n&quot;</span>, ((<span class="hljs-type">int</span> *)arg)[<span class="hljs-number">2</span>]);<br>        writef(<span class="hljs-string">&quot;fun1 out\n&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">umain</span><span class="hljs-params">()</span> &#123;<br>        writef(<span class="hljs-string">&quot;\n--basictest start---\n&quot;</span>);<br>        <span class="hljs-type">pthread_t</span> th1;<br>        u_int trans[<span class="hljs-number">3</span>];<br>        trans[<span class="hljs-number">0</span>] = <span class="hljs-number">114514</span>;<br>        trans[<span class="hljs-number">1</span>] = <span class="hljs-number">19260817</span>;<br>        trans[<span class="hljs-number">2</span>] = <span class="hljs-number">20373025</span>;<br>        <span class="hljs-type">int</span> r = pthread_create(&amp;th1, <span class="hljs-literal">NULL</span>, fun1, (<span class="hljs-type">void</span> *)trans);<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">1000000</span>;i++);<br>        writef(<span class="hljs-string">&quot;test end!\n&quot;</span>);<br>        *(<span class="hljs-type">int</span> *) KERNBASE = <span class="hljs-number">0</span>;<br>&#125;<br>    <span class="hljs-comment">//输出结果</span><br>--basictest start---<br>create success!<br>arg[<span class="hljs-number">0</span>] is <span class="hljs-number">114514</span><br>arg[<span class="hljs-number">1</span>] is <span class="hljs-number">19260817</span><br>test end!<br></code></pre></td></tr></table></figure><h4 id="二、pthread-cancel测试"><a href="#二、pthread-cancel测试" class="headerlink" title="二、pthread_cancel测试"></a>二、pthread_cancel测试</h4><p>​主要检测了不同cancel状态下，能否以正确的cancel方式终止线程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib.h&quot;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">test1</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> oldvalue;<br>        pthread_setcancelstate(THREAD_CANCEL_DISABLE, &amp;oldvalue);<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++);<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> oldvalue;<br>        pthread_setcanceltype(THREAD_CANCEL_ASYNCHRONOUS, &amp;oldvalue);<br>        syscall_yield();<br>        writef(<span class="hljs-string">&quot;asynchronous fail!\n&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">test3</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>        <span class="hljs-type">int</span> oldvalue;<br>        pthread_setcanceltype(THREAD_CANCEL_DEFERRED, &amp;oldvalue);<br>        syscall_yield();<br>        writef(<span class="hljs-string">&quot;test3 wait for cancel point\n&quot;</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>                pthread_testcancel();<br>        &#125;<br>        writef(<span class="hljs-string">&quot;deferred fail!\n&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">umain</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">pthread_t</span> p1, p2, p3;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">int</span> ret = pthread_create(&amp;p1, <span class="hljs-literal">NULL</span>, test1, <span class="hljs-literal">NULL</span>);<br>        ret = pthread_create(&amp;p2, <span class="hljs-literal">NULL</span>, test2, <span class="hljs-literal">NULL</span>);<br>        ret = pthread_create(&amp;p3, <span class="hljs-literal">NULL</span>, test3, <span class="hljs-literal">NULL</span>);<br>        syscall_yield();<br>        pthread_cancel(p1);<br>        pthread_cancel(p2);<br>        pthread_cancel(p3);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">100000</span>;i++);<br>        *(<span class="hljs-type">int</span> *)KERNBASE = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//输出</span><br>cancel failed !! <br>test3 wait <span class="hljs-keyword">for</span> cancel point<br></code></pre></td></tr></table></figure><ul><li>test1中将线程p1设置为<code>THREAD_CANCEL_DISABLE</code>，因此在<code>pthread_destroy</code>函数中输出<code>cancel failed！！</code></li><li>test2中将线程p2设置为<code>THREAD_CANCEL_ASYNCHRONOUS</code>，可以被立即终止，因此没有输出后续的<code>deferred fail!</code></li><li>test3中将线程p3设置为<code>THREAD_CANCEL_DEFERRED</code>，需要等待中断点到来，因此在<code>syscall_yield()</code>后仍能输出<code>test3 wait for cancel point</code>，并且在某一次<code>pthread_testcancel</code>中被终止。</li></ul><h4 id="三、pthread-join测试"><a href="#三、pthread-join测试" class="headerlink" title="三、pthread_join测试"></a>三、pthread_join测试</h4><p>在该测试程序中，测试了pthread_join能否正确阻塞线程，且在目标线程完成后正确唤醒被阻塞线程</p><p>该样例设置了<code>umain--&gt;test3--&gt;test2--&gt;test1</code>的join次序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib.h&quot;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">test1</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>        syscall_yield();<br>        writef(<span class="hljs-string">&quot;test1 end!\n&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>        <span class="hljs-type">pthread_t</span> p1 = ((u_int *)arg)[<span class="hljs-number">0</span>];<br>        pthread_join(p1, <span class="hljs-literal">NULL</span>);<br>        writef(<span class="hljs-string">&quot;test2 end!\n&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">test3</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>        <span class="hljs-type">pthread_t</span> p2 = ((u_int *)arg)[<span class="hljs-number">1</span>];<br>        pthread_join(p2,<span class="hljs-literal">NULL</span>);<br>        writef(<span class="hljs-string">&quot;test3 end!\n&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">umain</span><span class="hljs-params">()</span> &#123;<br>        writef(<span class="hljs-string">&quot;-----jointest begin-----\n&quot;</span>);<br>        u_int a[<span class="hljs-number">3</span>];<br>        <span class="hljs-type">pthread_t</span> p1, p2, p3;<br>        <span class="hljs-type">int</span> r;<br>        r = pthread_create(&amp;p1, <span class="hljs-literal">NULL</span>, test1, (<span class="hljs-type">void</span> *)a);<br>        a[<span class="hljs-number">0</span>] = p1;<br>        r = pthread_create(&amp;p2, <span class="hljs-literal">NULL</span>, test2, (<span class="hljs-type">void</span> *)a);<br>        a[<span class="hljs-number">1</span>] = p2;<br>        r = pthread_create(&amp;p3, <span class="hljs-literal">NULL</span>, test3, (<span class="hljs-type">void</span> *)a);<br>        pthread_join(p3, <span class="hljs-literal">NULL</span>);<br>        syscall_yield();<br>        <span class="hljs-type">int</span> i;<br>        writef(<span class="hljs-string">&quot;umain end!\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">100000</span>; i++);<br>&#125; <br><span class="hljs-comment">//输出</span><br>-----jointest begin-----<br>test1 end!<br>test2 end!<br>test3 end!<br>umain end!<br></code></pre></td></tr></table></figure><h4 id="四、共享空间测试"><a href="#四、共享空间测试" class="headerlink" title="四、共享空间测试"></a>四、共享空间测试</h4><p>本测试旨在测试同一进程间的线程是否共享同一虚拟空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib.h&quot;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>        u_int *ta = ((u_int *)arg)[<span class="hljs-number">0</span>];<br>        writef(<span class="hljs-string">&quot;a get in another thread is %d\n&quot;</span>, *ta);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">umain</span><span class="hljs-params">()</span> &#123;<br>        writef(<span class="hljs-string">&quot;-----sharetest begin-----\n&quot;</span>);<br>        u_int a = <span class="hljs-number">114514</span>;<br>        u_int arg[<span class="hljs-number">3</span>];<br>        arg[<span class="hljs-number">0</span>] = &amp;a;<br>        <span class="hljs-type">pthread_t</span> p;<br>        <span class="hljs-type">int</span> r  = pthread_create(&amp;p, <span class="hljs-literal">NULL</span>, test, (<span class="hljs-type">void</span> *)arg);<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100000</span>; i++);<br>        writef(<span class="hljs-string">&quot;test end!\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">//输出</span><br>-----sharetest begin-----<br>a get in umain thread is <span class="hljs-number">114514</span><br>a get in test thread is <span class="hljs-number">114514</span><br>test end!<br></code></pre></td></tr></table></figure><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>根据要求，我们需要实现无名信号量，所以完成进程内部的同步与通信即可，不涉及进程间的交互，因此设计相对简单。值得注意的是，为了保证信号量操作的<strong>原子性</strong>，笔者将为其实际操作都完成了相应的系统调用。</p><h3 id="信号量控制块Sem"><a href="#信号量控制块Sem" class="headerlink" title="信号量控制块Sem"></a>信号量控制块Sem</h3><p>具体成员介绍见注释</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Sem</span> &#123;</span><br>        u_int sem_value; <span class="hljs-comment">//表示资源的数量</span><br>        u_int sem_status; <span class="hljs-comment">//信号量的状态，分为有效与无效</span><br>        u_int sem_shared; <span class="hljs-comment">//涉及到进程间的关联，由于未要求所以没有相应的使用</span><br>        u_int sem_envid; <span class="hljs-comment">//记录了该信号量所属的进程id</span><br>        u_int sem_wait_list[<span class="hljs-number">8</span>]; <span class="hljs-comment">//阻塞队列，用于后续唤醒调度，前面我们限定了一个进程最多8个线程</span><br>        u_int sem_wait_num; <span class="hljs-comment">//被阻塞线程的个数</span><br>        u_int sem_wait_i; <span class="hljs-comment">//标记，实现类似于循环数组的功能</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="sem-init"><a href="#sem-init" class="headerlink" title="sem_init"></a>sem_init</h3><p>​顾名思义，完成对信号量的初始化设置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_sem_init</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, <span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> shared, u_int value, u_int envid)</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sem_init for %d\n&quot;</span>, sem);<br>        sem-&gt;sem_value = value;<br>        sem-&gt;sem_status = <span class="hljs-number">1</span>;<br>        sem-&gt;sem_shared = shared;<br>        sem-&gt;sem_envid = envid;<br>        sem-&gt;sem_wait_num = <span class="hljs-number">0</span>;<br>        sem-&gt;sem_wait_i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NWAITSEM; i++) &#123;<br>                sem-&gt;sem_wait_list[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sem-destroy"><a href="#sem-destroy" class="headerlink" title="sem_destroy"></a>sem_destroy</h3><p>​用于删除某信号量，具体来说若某信号量的status为<code>SEM_FREE</code>，则说明其以及被删除失效了。值得注意的是，若删除某信号量时，仍有线程被该信号量阻塞，则删除失败。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_sem_destroy</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, <span class="hljs-type">sem_t</span> *sem)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sem-&gt;sem_status == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sem-&gt;sem_wait_num != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sem_destroy fail::  there are waiting threads!\n&quot;</span>);<br>        &#125;<br>        sem-&gt;sem_status = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sem-wait"><a href="#sem-wait" class="headerlink" title="sem_wait"></a>sem_wait</h3><p>​信号量的P操作，用于线程申请资源.</p><ul><li>若资源充足，则给申请线程分配一个<code>sem_value--</code></li><li>若资源不足，则要阻塞该线程，而后切换线程，使系统继续运行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_sem_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, <span class="hljs-type">sem_t</span> *sem)</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sem_wait for  %d\n&quot;</span>, sem);<br>        <span class="hljs-keyword">if</span> (sem-&gt;sem_value &gt; <span class="hljs-number">0</span>) &#123;<br>                sem-&gt;sem_value--;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        sys_set_thread_status(<span class="hljs-number">0</span>, curpth-&gt;pth_id, ENV_NOT_RUNNABLE);<br>        sem-&gt;sem_wait_list[sem-&gt;sem_wait_i] = curpth-&gt;pth_id;<br>        sem-&gt;sem_wait_i = (sem-&gt;sem_wait_i + <span class="hljs-number">1</span>) % NWAITSEM;<br>        sem-&gt;sem_wait_num++;<br>        curpth-&gt;pth_tf.regs[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>; <br>        curpth-&gt;pth_tf.pc = curpth-&gt;pth_tf.cp0_epc;<br>        sys_yield();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sem-trywait"><a href="#sem-trywait" class="headerlink" title="sem_trywait"></a>sem_trywait</h3><p>​该函数也是信号量的P操作，资源充足时操作与<code>sem_wait</code>相同，但同若资源不足则直接返回，而不进行阻塞，在这里我通过返回负数表明资源不足的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_sem_trywait</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, <span class="hljs-type">sem_t</span> *sem)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sem-&gt;sem_value &gt; <span class="hljs-number">0</span>) &#123;<br>                sem-&gt;sem_value--;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sem-post"><a href="#sem-post" class="headerlink" title="sem_post"></a>sem_post</h3><p>​信号量的V操作，用于某线程归还资源，如若有其他线程被阻塞等待，则唤醒被阻塞的线程并将资源分配给它，具体实现就是修改被唤醒线程的状态为<code>RUNNABLE</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_sem_post</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, <span class="hljs-type">sem_t</span> *sem)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sem-&gt;sem_wait_num == <span class="hljs-number">0</span>) &#123;<br>                sem-&gt;sem_value++;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        u_int id = sem-&gt;sem_wait_list[(sem-&gt;sem_wait_i + NWAITSEM - sem-&gt;sem_wait_num) % NWAITSEM];<br>        sys_set_thread_status(<span class="hljs-number">0</span>, id, ENV_RUNNABLE);<br>        sem-&gt;sem_wait_num--;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="sem-getvalue"><a href="#sem-getvalue" class="headerlink" title="sem_getvalue"></a>sem_getvalue</h3><p>​用于获取信号量对应的资源量，记录在传入的value之中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_sem_getvalue</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, <span class="hljs-type">sem_t</span> *sem, u_int *value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-number">0</span>) &#123;<br>                *value = sem-&gt;sem_value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="部分细节-1"><a href="#部分细节-1" class="headerlink" title="部分细节"></a>部分细节</h3><ul><li><p>线程被阻塞后，修改了其pc值而后切换至线程，使其被唤醒后可以直接继续执行，不用回到<code>sem_wait</code>之中</p></li><li><p>阻塞队列采用了循环数组的形式实现</p><ul><li>添加阻塞线程时，记录在<code>sem-&gt;sem_wait_list[sem-&gt;sem_wait_i]</code>中，并使<code>sem-&gt;sem_wait_i = (sem-&gt;sem_wait_i + 1) % NWAITSEM;</code></li><li>释放阻塞线程时，我们释放线程为阻塞队列中的第<code>(sem-&gt;sem_wait_i + NWAITSEM - sem-&gt;sem_wait_num) % NWAITSEM</code>，具体来说就是最早进入且未被释放的对应线程</li></ul></li></ul><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><h4 id="一、信号量简单测试"><a href="#一、信号量简单测试" class="headerlink" title="一、信号量简单测试"></a>一、信号量简单测试</h4><p>​本测试设置了信号量sem1，并初始化其value为0，即一开始资源不足，设置了test1进行P操作和test2进行V操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib.h&quot;</span></span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">test1</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>        <span class="hljs-type">sem_t</span> *sem1 = (<span class="hljs-type">sem_t</span> *)((<span class="hljs-type">int</span> *)arg)[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (sem_trywait(sem1) &lt; <span class="hljs-number">0</span>)<br>                writef(<span class="hljs-string">&quot;\ntest1 wait sem1 %d \n&quot;</span>, sem1);<br>        <span class="hljs-type">int</span> value;<br>        sem_getvalue(sem1, &amp;value);<br>        writef(<span class="hljs-string">&quot;sem1&#x27;s value is %d\n&quot;</span>, value);<br>        sem_wait(sem1);<br>        writef(<span class="hljs-string">&quot;test1 get sem1\n&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> *<span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span> &#123;<br>        <span class="hljs-type">sem_t</span> *sem1 = (<span class="hljs-type">sem_t</span> *)((<span class="hljs-type">int</span> *)arg)[<span class="hljs-number">0</span>];<br>        writef(<span class="hljs-string">&quot;test2 post sem1\n&quot;</span>);<br>        sem_post(sem1);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">umain</span><span class="hljs-params">()</span> &#123;<br>        writef(<span class="hljs-string">&quot;-----semtest begin-----\n&quot;</span>);<br>        <span class="hljs-type">sem_t</span> sem1;<br>        sem_init(&amp;sem1, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-type">pthread_t</span> pt1;<br>        <span class="hljs-type">pthread_t</span> pt2;<br>        <span class="hljs-type">int</span> r;<br>        <span class="hljs-type">int</span> a[<span class="hljs-number">2</span>];<br>        a[<span class="hljs-number">0</span>] = &amp;sem1;<br>        r = pthread_create(&amp;pt1, <span class="hljs-literal">NULL</span>, test1, (<span class="hljs-type">void</span> *)a);<br>        syscall_yield();<br>        r = pthread_create(&amp;pt2, <span class="hljs-literal">NULL</span>, test2, (<span class="hljs-type">void</span> *)a);<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++);<br>        writef(<span class="hljs-string">&quot;semtest end!\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 输出</span><br>-----semtest begin-----<br>sem_init <span class="hljs-keyword">for</span> <span class="hljs-number">2134892424</span> <span class="hljs-comment">//sem_init</span><br>test1 wait sem1 <span class="hljs-number">2134892424</span> <span class="hljs-comment">//sem_trywait</span><br>sem1<span class="hljs-number">&#x27;</span>s value is <span class="hljs-number">0</span> <span class="hljs-comment">//sem_getvalue</span><br>sem_wait <span class="hljs-keyword">for</span>  <span class="hljs-number">2134892424</span> <span class="hljs-comment">//sem_wait</span><br>test2 post sem1 <span class="hljs-comment">//sem_post</span><br>test1 get sem1 <span class="hljs-comment">//sem_post</span><br>semtest end! <br></code></pre></td></tr></table></figure><h2 id="遇到的问题与解决方案"><a href="#遇到的问题与解决方案" class="headerlink" title="遇到的问题与解决方案"></a>遇到的问题与解决方案</h2><ul><li>程序中创建的“子进程”不能正常结束，因此笔者在<code>pthread_create</code>创建线程创建过程中设置了<code>p-&gt;pth_tf.regs[31] = exit;</code>，使得线程结束后自动跳转到<code>user/liboc.c</code>的exit函数中，完成对于线程的删除与退出。</li><li>由于任务的代码量很大，因此在debug时笔者采用了在各函数中设置输出实时状态，锁定有问题的地方，实现了高效调试。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​lab4的挑战性任务完成的比较匆忙，因此没有实现很完整的架构体系，仅达成了基础要求。从我个人而言，我认为本次任务的难点主要在于进程功能到线程的迁移，需要对原先的架构有一个较好的认识，同时熟练掌握系统调用的创建以及内核态与用户态间的切换，确实很有“挑战性”。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统实验报告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSlab6实验报告</title>
    <link href="/20220627/OSlab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/20220627/OSlab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="lab6实验报告"><a href="#lab6实验报告" class="headerlink" title="lab6实验报告"></a>lab6实验报告</h1><h2 id="实验思考题"><a href="#实验思考题" class="headerlink" title="实验思考题"></a>实验思考题</h2><h3 id="Thinking6-1"><a href="#Thinking6-1" class="headerlink" title="Thinking6.1"></a>Thinking6.1</h3><blockquote><p>示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？ </p></blockquote><ul><li>读写进程的操作相同，这里只是父子进程的角色互换，因此对换彼此的操作即可。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> fildes[<span class="hljs-number">2</span>];<br><span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> status;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>status = pipe(fildes);<br><span class="hljs-keyword">if</span> (status == <span class="hljs-number">-1</span> ) &#123;<span class="hljs-comment">/* an error occurred */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">switch</span> (fork()) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>: <span class="hljs-comment">/* Handle error */</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">//这是子进程，作为“写这”发送信息</span><br>close(fildes[<span class="hljs-number">0</span>]); <br>write(fildes[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;Hello world\n&quot;</span>, <span class="hljs-number">12</span>); <br>close(fildes[<span class="hljs-number">1</span>]); <br><span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br><span class="hljs-keyword">default</span>: <span class="hljs-comment">//这是父进程，作为“读者”接受信息</span><br>            close(fildes[<span class="hljs-number">1</span>]); <br>read(fildes[<span class="hljs-number">0</span>], buf, <span class="hljs-number">100</span>); <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;father-process read:%s&quot;</span>,buf); <br>close(fildes[<span class="hljs-number">0</span>]); <br><span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Thiking6-2"><a href="#Thiking6-2" class="headerlink" title="Thiking6.2"></a>Thiking6.2</h3><blockquote><p>上面这种不同步修改 pp_ref 而导致的进程竞争问题在 user&#x2F;fd.c 中的dup 函数中也存在。请结合代码模仿上述情景，分析一下我们的 dup 函数中为什么会出现预想之外的情况？ </p></blockquote><ul><li><p>dup函数的作用</p><ul><li>将一个文件描述符<code>oldfd</code>映射到另一个文件描述符<code>newfd</code>，是为了实现文件的多处打开。其中<code>syscall_mem_map</code>会修改pp_ref的值，因此可能会导致与<code>close()</code>类似的进程竞争问题。</li></ul></li><li><p>进程竞争问题分析</p><ul><li><p>在原来的dup函数中，先添加映射了fd块本身，再映射文件存储的内容。</p></li><li><p>现考虑这一种情况（代码见下方）</p><ul><li>fork后先执行子进程，完成了<code>dup(p[1])</code>但还没开始<code>read(p[0])</code>，切换到父进程</li><li>当执行到<code>dup(p[0])</code>建立了对p[0]的fd块本身的映射后，还未给对应pipe进行映射，发生中断切换回子进程</li><li>可以发现刚好p[0]在子进程中<code>pp_ref+1</code>，pipe在父进程中<code>pp_ref+1</code>在子进程中不变，此时有<code>pageref([0]) == pageref(pipe)</code>，根据之前的设定我们判定此时写端关闭了，从而子进程退出导致出错。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>    dup(p[<span class="hljs-number">1</span>]);<br>    read(p[<span class="hljs-number">0</span>]);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    dup(p[<span class="hljs-number">0</span>]);<br>    write(p[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Thinking6-3"><a href="#Thinking6-3" class="headerlink" title="Thinking6.3"></a>Thinking6.3</h3><blockquote><p>为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析。</p></blockquote><ul><li><p>系统调用一定是原子操作。根据上述材料我们知道导致非原子错误的根源是中断，而后进程切换导致了这一情况。而在系统调用的过程中，紧随<code>SAVE_ALL宏</code>后的<code>CLI宏</code>关闭了中断，保证了这一次系统调用不会被中途打断，因此是原子性的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.macro CLI<br>    mfc0 t0, CP0_STATUS <br>    li t1, (STATUS_CU0 | 0x1) #将中断位置为1，表明不允许中断<br>    or t0, t1 <br>    xor t0, 0x1 <br>    mtc0 t0, CP0_STATUS <br>.endm<br></code></pre></td></tr></table></figure></li></ul><h3 id="Thinking6-4"><a href="#Thinking6-4" class="headerlink" title="Thinking6.4"></a>Thinking6.4</h3><blockquote><p>仔细阅读上面这段话，并思考下列问题</p><p>• 按照上述说法控制 pipeclose 中 fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。</p><p>• 我们只分析了 close 时的情形，那么对于 dup 中出现的情况又该如何解决？请模仿上述材料写写你的理解。</p></blockquote><ul><li>可以解决。如若先解除fd的映射，重现上述的场景，我们发现本应出错的地方，此时<code>pageref(p[0]) == 1</code>而<code>pageref(pipe) == 3</code>，无论执行顺序如何都不可能出现<code>pageref(p[0]) == pageref(pipe)</code>的“间隙”，从而解决了该场景的进程竞争问题。</li><li>与上述解决方法同理，因为总有<code>pageref(pipe) &gt;= pageref(p[])</code>,我们先完成对文件内容的映射，再完成对fd块的映射，这样<code>pageref(pipe)</code>总是先增加，就也不会出现<code>pageref(p[]) == pageref(pipe)</code>的间隙，成功避免了进程竞争导致的问题。</li></ul><h3 id="Thinking6-5"><a href="#Thinking6-5" class="headerlink" title="Thinking6.5"></a>Thinking6.5</h3><blockquote><p>bss 在 ELF 中并不占空间，但 ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是 0。请回答你设计的函数是如何实现上面这点的？</p></blockquote><ul><li>.bss段位于bin_size结束到sg_size之间，用<code>syscall_mem_alloc</code>为该段申请内存，就能使其占据空间了。除此之外，由于<code>syscall_mem_alloc</code>中为申请页面调用的<code>page_alloc</code>，使用了<code>bzero函数</code>已经将页面初始化为0，不需要再有额外的操作。具体操作如下</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (i &lt; sgsize) &#123;<br><span class="hljs-keyword">if</span> ((r = syscall_mem_alloc(child_envid, va + i, PTE_V | PTE_R)) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> r;<br>&#125;<br>i += BY2PG;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Thinking6-6"><a href="#Thinking6-6" class="headerlink" title="Thinking6.6"></a>Thinking6.6</h3><blockquote><p>为什么我们的 *.b 的 text 段偏移值都是一样的，为固定值？</p></blockquote><ul><li>因为在<code>user/user.lds</code>中我们对text段偏移值进行了设置，是固定值0x00400000</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">. = 0x00400000;<br>_text = .; /* Text and read-only data */<br>.text : &#123;<br>*(.text)<br>*(.fixup)<br>*(.gnu.warning)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Thinking6-7"><a href="#Thinking6-7" class="headerlink" title="Thinking6.7"></a>Thinking6.7</h3><blockquote><p>在哪步，0 和 1 被” 安排” 为标准输入和标准输出？请分析代码执行流程，给出答案。</p></blockquote><ul><li>在<code>user/init.c</code>中，调用了<code>opencons函数</code>创建控制台，并将0和1设置为了标准输入和标准输出，见下方代码</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//user/console.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">opencons</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-type">int</span> r; <br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">fd</span>;</span><br>        <span class="hljs-keyword">if</span> ((r = fd_alloc(&amp;fd)) &lt; <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> r;<br>        <span class="hljs-keyword">if</span> ((r = syscall_mem_alloc(<span class="hljs-number">0</span>, (u_int)fd, PTE_V|PTE_R|PTE_LIBRARY)) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> r;<br>        fd-&gt;fd_dev_id = devcons.dev_id;<br>        fd-&gt;fd_omode = O_RDWR;<br>        <span class="hljs-keyword">return</span> fd2num(fd);<br>&#125;<br><span class="hljs-comment">//user/init.c</span><br>close(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> ((r = opencons()) &lt; <span class="hljs-number">0</span>)<br>user_panic(<span class="hljs-string">&quot;opencons: %e&quot;</span>, r);<br><span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>)<br>user_panic(<span class="hljs-string">&quot;first opencons used fd %d&quot;</span>, r);<br><span class="hljs-keyword">if</span> ((r = dup(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>)<br>user_panic(<span class="hljs-string">&quot;dup: %d&quot;</span>, r);<br></code></pre></td></tr></table></figure><h2 id="实验难点图示"><a href="#实验难点图示" class="headerlink" title="实验难点图示"></a>实验难点图示</h2><h3 id="进程竞争问题"><a href="#进程竞争问题" class="headerlink" title="进程竞争问题"></a>进程竞争问题</h3><table><thead><tr><th></th><th>pageref(p[0])</th><th>pageref(p[1])</th><th>pageref(pipe)</th></tr></thead><tbody><tr><td>fork前</td><td>1</td><td>1</td><td>2</td></tr><tr><td>fork后</td><td>2</td><td>2</td><td>4</td></tr><tr><td>子进程完成close(p[1])</td><td>2</td><td>1</td><td>3</td></tr><tr><td>父进程在close(p[0])中解除对pipe的映射</td><td>2</td><td>1</td><td>2</td></tr><tr><td>回到子进程</td><td>2</td><td>1</td><td>2</td></tr></tbody></table><p>​经过上述过程，在“回到子进程”时，<code>pageref(p[0]) == pageref(pipe)</code>导致误以为写端关闭，子进程关闭发生错误。</p><h3 id="Shell的管道连接"><a href="#Shell的管道连接" class="headerlink" title="Shell的管道连接"></a>Shell的管道连接</h3><p>​<img src="/20220627/OSlab6%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220627184643135.png" alt="image-20220627184643135"></p><h2 id="体会与感想"><a href="#体会与感想" class="headerlink" title="体会与感想"></a>体会与感想</h2><p>​通过lab6的学习，了解了管道pipe的实现机制，同时对于Shell实现有了一定了解，算是对操作系统这两大组件有了进一步的理论性学习。但是相较于其他lab，由于lab6临近考期因此完成的比较匆忙，而且没有上机就没有花费精力对其进行细致深入的理解，只能算是粗略的学习并实现了一遍任务，这个伏笔或许需要在将来再回过头来学习补足。</p><p>​至此本学期的OS学习算是基本完成，从一开始的摸不着头脑到现在的得心应手，我学到了很多，也成长了许多，从一开始的OS小白到现在对于OS算是有了一定的了解与实现能力，一路上少不了老师与助教们的教导与帮助，在此感谢老师与助教们的辛勤付出与奉献，也祝老师和助教们在往后的工作学习顺利。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统实验报告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OO第四单元总结</title>
    <link href="/20220627/OO%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/20220627/OO%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="OO第四单元总结"><a href="#OO第四单元总结" class="headerlink" title="OO第四单元总结"></a>OO第四单元总结</h1><h2 id="本单元架构设计"><a href="#本单元架构设计" class="headerlink" title="本单元架构设计"></a>本单元架构设计</h2><h3 id="任务概要"><a href="#任务概要" class="headerlink" title="任务概要"></a>任务概要</h3><p>​本单元作业要求补全一个UML解析器，实现对UML图相关信息的整合与查询，以及部分规则的规范性验证。具体为第十三次作业实现UML类图相关指令，第十四次作业实现UML顺序图和状态图的相关指令，第十五次实现部分规则的规范性验证。</p><p>​值得注意的是，本单元的官方包已经为你完成了对于输入数据的预处理，将其整理为<code>UmlElement数组</code>传递给你，需要完成的任务可分为以下三部步：</p><ul><li>识别传入的UmlElement的具体类型</li><li>将对应类型的数据存储到构造好的容器中用于查询，以及完成一定的预处理</li><li>根据要求实现相关指令</li></ul><h3 id="输入架构"><a href="#输入架构" class="headerlink" title="输入架构"></a>输入架构</h3><p>​Uml图的元素间有着一定的依赖、上下级关系，在输入的过程中以合适的顺序分批对不同种类的元素进行存储，可以保证关联的对象已经存在，从而正确的构建存储模型，避免出现需要的对象还未载入的情况。</p><p>​输入顺序的安排可通过Uml元素间的关系来排布，主要有父子关系，以及source、target等索引关系，笔者的处理流程由下图展示，输入架构一共分五轮，顺序为从左往右，保证了输入时的依赖与索引关系。</p><p><img src="/20220627/OO%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/image-20220626193331040.png" alt="image-20220626193331040"></p><h3 id="存储架构"><a href="#存储架构" class="headerlink" title="存储架构"></a>存储架构</h3><p>​本单元的作业核心就在于对于数据的存储，笔者构建<code>MyUml***</code>类，将原有的Uml变量与自建的容器相结合结合，并在其中添加为实现指令要求所需要的方法，并在“作业顶层”<code>MyImplementation</code>中用容器存储这些类，用于指令函数中进行查询与调用相关方法。</p><p>​其中，笔者选用的容器为HashMap和HashSet。因为题目限定了UmlElement的id唯一，因此以各自id为Key，对象为value十分好用；而HashSet自带去重功能，某些指令需要完成字符串去重，使用HashSet就直接完成了这一要求。</p><h4 id="记忆化"><a href="#记忆化" class="headerlink" title="记忆化"></a>记忆化</h4><p>​值得一提的是，本单元的题目具有一次构造，多次查询的特点，因此笔者采用了记忆化的特点以提升程序性能，具体操作时给待查询的量设置一个标志位，判断其是否以为计算得到，若未则进一步进行计算，否则直接返回已存储下的值。</p><h4 id="迭代模块化设计"><a href="#迭代模块化设计" class="headerlink" title="迭代模块化设计"></a>迭代模块化设计</h4><p>​本单元的三次作业间界限分明，因此可以将每次作业的新增指令或Rule封装成一个模块来进行管控（其实还有一个考虑就是CheckStyle限制了一个类的篇幅，难以在<code>MyImplementation类</code>中完成所有指令的主体部分。就第三次作业来说，笔者用单例模式新建了<code>MyRule类</code>，里面存储了相关Rule有无违反的标志位以及部分检测过程，同时由于单例模式，让各类都可以便捷地访问该类并进行Rule违反的标志。而在具体的<code>checkForUml00*</code>的用户接口中，只需查询对应的标志位抛出异常即可。</p><h4 id="部分细节"><a href="#部分细节" class="headerlink" title="部分细节"></a>部分细节</h4><h5 id="NotFound-amp-Duplicated-异常"><a href="#NotFound-amp-Duplicated-异常" class="headerlink" title="NotFound &amp; Duplicated 异常"></a>NotFound &amp; Duplicated 异常</h5><p>​这两个异常在大部分指令中都需要考虑，笔者实现方式是遍历一遍对应容器，用count记录满足要求的个数，如若最终count为0则是NotFoundException，count大于1就是DuplicatedException。我们可以将这一过程封装成专门的方法，可以有效降低程序的复杂度。</p><h5 id="Rule003-循环继承检查"><a href="#Rule003-循环继承检查" class="headerlink" title="Rule003 循环继承检查"></a>Rule003 循环继承检查</h5><p>​该规则的检查可以使用dfs或者类Floyd最短路的算法，笔者采用的是后者，即将最短路中的路径长度改为两者是否连同，执行一遍Floyd算法后，若某类或接口自己和自己联通则说明其发生了循环继承。</p><p>​注意使用一般的拓扑序列无法实现该检查，因为数据中可能出现自己继承自己的情况，即出现自环。如下述情况，可能会导致错把也当作循环继承的一份子。</p><p><img src="/20220627/OO%E7%AC%AC%E5%9B%9B%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/image-20220626222507396.png" alt="image-20220626222507396"></p><h4 id="单元总结"><a href="#单元总结" class="headerlink" title="单元总结"></a>单元总结</h4><p>​通过本单元的学习，我对UML图有了十分深入的理解，同时在容器选取、数据架构、数据交互等方面都得到了很好的锻炼，同时程序设计更趋于模块化，整体架构更加清晰明确，写代码能力进一步提升，收获巨大。</p><h2 id="架构设计思维及OO方法理解的演进"><a href="#架构设计思维及OO方法理解的演进" class="headerlink" title="架构设计思维及OO方法理解的演进"></a>架构设计思维及OO方法理解的演进</h2><h3 id="第一单元——表达式解析"><a href="#第一单元——表达式解析" class="headerlink" title="第一单元——表达式解析"></a>第一单元——表达式解析</h3><p>​刚接触面向对象，我凭着大一经验，在Main函数中直接实现了第一次作业，完成了一个面向过程的程序，觉得挺简单的自信满满。但是第二次作业出现的三角函数立马就打脸了，多项东西的嵌套使得面向过程的实现异常艰难，我开始真正接触面向对象，并且最终构造出了<code>多项式-项-基元-多项式</code>的循环嵌套模型，初步理解了面向对象的巧妙所在，同时也体会到了其中的封装性，算是入门了面向对象。</p><h3 id="第二单元——电梯调度系统"><a href="#第二单元——电梯调度系统" class="headerlink" title="第二单元——电梯调度系统"></a>第二单元——电梯调度系统</h3><p>​第二单元是第一次接触到多线程编程，其中最关键的是线程间的交互与安全问题。经过三次作业迭代，在学习了诸多面向对象程序架构后，我采用了<strong>生产者-消费者模式</strong>，设计了**<code>InputThread输入线程-Schedule调度线程-Elevator处理线程</code>**的电梯调度系统，分别实现了输入处理、任务发布和任务实现的三个部分，并在实现过程中是用了synchronized和读写锁&#96;的方式来保证线程安全。</p><p>​在这个单元中，我学习了面向对象对于资源的分配以及共享，对不同对象间的交互与安全有了更深的理解。同时，在设计不同的电梯与不同场景下的功能，体会到了面向对象继承性和多态性的意义所在，正确的面向对象性质利用可以降低程序的耦合性，极大提升程序的效率。</p><h3 id="第三单元——JML规格训练之社交网络模拟"><a href="#第三单元——JML规格训练之社交网络模拟" class="headerlink" title="第三单元——JML规格训练之社交网络模拟"></a>第三单元——JML规格训练之社交网络模拟</h3><p>​这一单元训练的是JML语言的阅读以及将其实现为代码的能力。除了每次作业中的简单图论问题，基本上没有思考的难度，重点在于如何规范地、简洁的实现规格的要求。</p><p>​总得来说这一单元的架构较为清晰简单，主要就是实现规格要求的几个<code>My***类</code>，在类中选用HashMap等合适的容器存储相关信息以及实现类间的关联，最后根据信息和一定的算法完成指令即可。但值得注意的是，在具体实现过程中，要做好预处理与记忆化，不然可能会因此出现超时的情况。</p><p>​虽然这单元实现起来较为简单，但我认为对我个人编码能力的提升是很有作用的，主要体现在<strong>代码规范性</strong>这一点上。因为JML已给出了规格，在编码的过程中，我会更加注重实现过程是否清晰明了、有无繁杂重复，旨在让自己的代码具有高效率、可读性高的特点。以此要求自己，我发现写代码的过程中思绪清晰，且事后证明程序出现的功能性错误也较少，因此我深刻认识到了代码规格性以及简洁性之重要，在日后我也会继续这样要求自己。</p><h3 id="第四单元——UML图解析"><a href="#第四单元——UML图解析" class="headerlink" title="第四单元——UML图解析"></a>第四单元——UML图解析</h3><p>​第四单元简单来说就是要实现对UML图的解析，提取其中的信息并完成一些查询指令，其架构在本总结开头就是阐明，就不在此赘述了。</p><p>​在前几个单元我对于UML图一直缺乏理解，一直都是为了完成任务得过且过，而这个单元最大的收获我觉得就是对于UML图有的一个系统、清晰的认识，总算是真正掌握了其原理与实现。除此之外，这一单元需要存储的信息量很大，如何用较少的类和容器实现题目要求的指令是一个关键问题，在不断规整和设计的过程中，我对这一方面也有了更深的理解。</p><h2 id="测试理解与实践的演进"><a href="#测试理解与实践的演进" class="headerlink" title="测试理解与实践的演进"></a>测试理解与实践的演进</h2><p>​随着四个单元的不断训练，我对于代码的测试愈发熟练且习以为常。</p><h3 id="第一单元"><a href="#第一单元" class="headerlink" title="第一单元"></a>第一单元</h3><p>​第一个单元我对于测试还没有什么清晰的认知，认为只要能通过网站的测试就是ok了，并没有对自己程序的正确性有很好的“责任感”。数据也仅仅是随意捏造一些简单的小数据，希冀sin（0）之类的数据可以hack到别人优化的错误，没有很好地检查自己程序的正确性，在第二次作业三角函数的处理中出现了错误。</p><h3 id="第二单元"><a href="#第二单元" class="headerlink" title="第二单元"></a>第二单元</h3><p>​第二单元的背景是实现一个电梯调度系统，具有现实意义，我认识到对于程序的测试和完成程序应是不可分割的，要及时检验这样才能减少交付使用后可能出现的问题，这是我们程序员的责任，要尽量做到对程序的全面性测试，充分考虑到将来程序使用中的各种情况与场景。构造数据时，我往往会设计一个背景来有针对性地进行测试，注重于对某个部件或功能的检验，以及多部份间协作可能导致的错误。例如在第三次作业的横向电梯中，我就设计了诸多横向的请求，以求的横向电梯可达性实现部分进行检测。</p><h3 id="第三单元-amp-第四单元"><a href="#第三单元-amp-第四单元" class="headerlink" title="第三单元&amp;第四单元"></a>第三单元&amp;第四单元</h3><p>​后两个单元相较于前两个单元，规范性较强，简单的数据不容易查出问题且手动造数据较为困难，同时我还意识到程序所经历的场景是复杂多变的，有时候单凭人手很难有一个较为全面的测试，需要通过测试机通过随机和大量来提升测试的效果。因此我开始接触自动测试，尝试写了一个测试机，可以实现通过jar包运行大量数据得到结果并且自动对不同的结果进行对拍，反馈出有差异的数据点，进而再通过具体的数据点去发现问题，极大提升了程序检测的效率。</p><p>​比较可惜的就是我本人并没有自主实现一个数据生成器，在随机产生数据这一方面的能力还有所缺陷，在接下来我也会学习去尝试这方面的实现逻辑，并希望以后在还有机会的时候能自己完成一个数据生成器。</p><h2 id="OO课程收获"><a href="#OO课程收获" class="headerlink" title="OO课程收获"></a>OO课程收获</h2><h3 id="面向对象概念"><a href="#面向对象概念" class="headerlink" title="面向对象概念"></a>面向对象概念</h3><p>​通过四个单元的学习，对面向对象的理解与实现逐步加深，在写代码过程中不断领会到封装性、继承性、多态性的优势所在，熟练掌握了面向对象的编码方式。同时，拥有了面向对象的思考角度，面对问题时能够尝试将其细分，从对象的角度出发，合理规划信息的存储以其功能的实现。</p><h3 id="线程交互与安全"><a href="#线程交互与安全" class="headerlink" title="线程交互与安全"></a>线程交互与安全</h3><p>​第二单元中接触到了全新的线程知识，掌握了线程的创建、交互以及锁的使用，同时了学习了多种模型与单例模式、生产者-消费者模式等，对于我的编程理念来说一个跨越式的提升。</p><h3 id="程序测试"><a href="#程序测试" class="headerlink" title="程序测试"></a>程序测试</h3><p>​认识到了程序测试的重要性，同时也制造数据和检验程序的能力也得到了有效锻炼。从一开始的随随便便造点数据应付一下，到后来的专门测试且初步造了一个检测机，可谓是在程序测试能力方面有了一个全面的提升。</p><h3 id="代码习惯"><a href="#代码习惯" class="headerlink" title="代码习惯"></a>代码习惯</h3><p>​一方面，在于CheckStyle斗智斗勇的过程中，渐渐有了规范化的编码习惯，经历一个学期后写出的代码明显变得更加简洁优美；另一方面，通过根据规格要求的代码训练，对代码规范性有了全新的认识，在写代码过程中注重代码的规范与可读性，不再会写出原来繁杂冗余的代码。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​至此OO的课程就暂告一段落了，总得来说OO是一门综合性强、知识量丰富的课程，其训练模式让同学们在加深知识理解的过程中，也锻炼了代码的编写与检查能力，即使如此也不感枯燥，是一门十分成功的课程。在这门课的学习中，我收获良多，在此再次感谢老师与助教们的悉心教导与付出。</p><h2 id="一些课程改进建议"><a href="#一些课程改进建议" class="headerlink" title="一些课程改进建议"></a>一些课程改进建议</h2><h3 id="关于课程内容"><a href="#关于课程内容" class="headerlink" title="关于课程内容"></a>关于课程内容</h3><ul><li>UML图的内容可以早一些系统地讲讲。第一第二单元的博客作业都有明确要求对UML图的制作，但是早期未曾系统学习，导致有些茫然无措，我认为早一些对UML进行一定的系统教学有助于在制图中更好地理解其规则与意义。</li><li>个人认为研讨课的主题可以再修改一下，虽然这学期的研讨课都给出了几个主题供大家选择，但是最后因为同学们大多都没准备而选择了叙述本单元作业实现的主题，导致最后的内容分享就是十个组上台讲述基本相同的内容，个人感觉意义不大。一种可能的建议是不要设置这种分享作业实现方式的研讨主题，而是限定一些任务量小的探究型主题，可以让同学们有更多的收获。</li></ul><h3 id="关于作业与指导书"><a href="#关于作业与指导书" class="headerlink" title="关于作业与指导书"></a>关于作业与指导书</h3><ul><li><p>建议可以给每次作业的指导书适当加上目录索引，方便做题时快速查看要求。</p></li><li><p>第四单元指导书的内容有些冗余，特别是迭代至第三次作业可以发现大部分的内容其实并无改动，只是罗列前两次作业的要求，导致信息检索与获取有些困难，建议指导书可以将前两次的内容用链接指向之前的指导书，而在新的指导书中只给出本次的新增内容，以及罗列出有改动的部分即可。</p></li><li><p>在OO作业的完成过程中，本人经常的一个操作就是翻阅微信群中的大量消息，从而找寻可能的出错情况。建议可以在OO网站中给每次作业开设一个“错误分享区”，鼓励同学们在该区给出自己遇见的错误以及解决方式，再进一步可以给出一定的对设计的思考，给同学们一个更好的做作业体验，也降低了助教在微信群中的答疑压力。另外建议可以实现答疑贴中在问题下直接回复，而不是在后面使用@来进行回复，一定程度上可以提升网站使用的观感。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面向对象单元总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSlab5实验报告</title>
    <link href="/20220613/OSlab5%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/20220613/OSlab5%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="lab5实验报告"><a href="#lab5实验报告" class="headerlink" title="lab5实验报告"></a>lab5实验报告</h1><h2 id="实验思考题"><a href="#实验思考题" class="headerlink" title="实验思考题"></a>实验思考题</h2><h3 id="Thinking5-1"><a href="#Thinking5-1" class="headerlink" title="Thinking5.1"></a>Thinking5.1</h3><blockquote><p>查阅资料，了解 Linux&#x2F;Unix 的 &#x2F;proc 文件系统是什么？有什么作用？ Windows 操作系统又是如何实现这些功能的？proc 文件系统这样的设计有什么好处和可以改进的地方？</p></blockquote><ul><li>&#x2F;proc文件系统是在内核中构建的一个伪文件系统，实现了一种内核和用户间信息交互的机制，通过它可以让用户<strong>实时</strong>与内核内部数据结构进行交互，获取相关信息。需要注意的是，这是一个伪文件系统，在使用中读取的“文件”，实际上是调用了一个<strong>接口</strong>，映射为内核内部一个数据结构被实时读取并且返回的字符串，呈现成文件的样子。</li><li>windows系统中通过一系列的APIs实现了与内核的交互</li><li>&#x2F;proc文件系统的优点是把与内核的交互简化为了与文件系统的交互，使得操作更加简便。可改进的地方可以参考后来的&#x2F;sysfs文件系统，相比之下，&#x2F;proc系统缺少规则与结构，导出的虚拟文件会有内部格式，增加了操作的复杂度，而&#x2F;sysfs的数据格式则更统一，操作更加简化。</li></ul><h3 id="Thinking5-2"><a href="#Thinking5-2" class="headerlink" title="Thinking5.2"></a>Thinking5.2</h3><blockquote><p>如果我们通过 kseg0 读写设备，我们对于设备的写入会缓存到 Cache 中。通过 kseg0 访问设备是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请你思考：这么做这会引起什么问题？对于不同种类的设备（如我们提到的串口设备和 IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存刷新的策略来考虑。</p></blockquote><ul><li>在Cache缓存内存内容后，很有可能出现外部设备响应并修改内存后，缓存并未得到更新，最终引发不可预知的问题。</li><li>有差异，拿题目中的串口设备与IDE硬盘来比较，串口设备的读写十分频繁，则其发生错误的概率会高于IDE磁盘。</li></ul><h3 id="Thinking5-3"><a href="#Thinking5-3" class="headerlink" title="Thinking5.3"></a>Thinking5.3</h3><blockquote><p>比较 MOS 操作系统的文件控制块和 Unix&#x2F;Linux 操作系统的 inode 及相关概念，试述二者的不同之处。</p></blockquote><ul><li>MOS操作系统中的文件控制块具体实现为File结构体，里面存储了文件名、文件大小、文件类型、文件具体内容指针、文件所述目录等内容。</li><li>而Unix&#x2F;Linux 操作系统的 文件控制块可以粗略理解为<strong>文件名+索引节点（inode）</strong>，因为文件查找只需要比较文件名，如此可以减少查找时的信息冗余。而索引节点inode则是一个指向文件其余具体信息的指针。</li><li>题中两者相比较而言，MOS系统中的文件控制块是文件具体信息的结合体，而inode则只是指向具体信息的一个指针。前者结构更加<strong>完整严谨</strong>，而后者则是更加<strong>灵活高效</strong>。</li></ul><h3 id="Thinking5-4"><a href="#Thinking5-4" class="headerlink" title="Thinking5.4"></a>Thinking5.4</h3><blockquote><p>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件 控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为 多大？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> BY2BLKBY2PG <span class="hljs-comment">//一个块的大小正好是一页4096Byte</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT2BLK(BY2BLK*8) <span class="hljs-comment">//这里算的是BLK的bit，所以自然是*8</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BY2FILE     256 <span class="hljs-comment">//一个file结构体的大小 256Byte</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBLOCK 1024  <span class="hljs-comment">//一个disk里面有1024块</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE2BLK  (BY2BLK/sizeof(struct File)) <span class="hljs-comment">//一个块里面有多少个file结构体</span></span><br></code></pre></td></tr></table></figure><ul><li><p>一个磁盘块大小为4096B，一个文件控制块大小为256B，因此一个磁盘块最多能存储16个文件控制块</p></li><li><p>一个指向磁盘块的指针为4B ，则一个目录算上直接和间接指针所能指向的磁盘块数总共为（4096B&#x2F;4B）即1024个，因此能存的文件个数就是（1024*16）即16384个</p></li><li><p>与目录类似，单个文件最多可以用1024个磁盘块来存，则最大为（1024*4KB）即4MB。</p></li></ul><h3 id="Thinking5-5"><a href="#Thinking5-5" class="headerlink" title="Thinking5.5"></a>Thinking5.5</h3><blockquote><p>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？</p></blockquote><ul><li>要满足磁盘块缓存的设计，缓冲区需要与磁盘的各磁盘块一一对应，因此能支持的最大磁盘大小就是缓冲区的大小<code>DISKMAX 0x40000000</code>，即1GB。</li></ul><h3 id="Thinking5-6"><a href="#Thinking5-6" class="headerlink" title="Thinking5.6"></a>Thinking5.6</h3><blockquote><p>如果将 DISKMAX 改成 0xC0000000, 超过用户空间，我们的文件系统还能正常工作吗？为什么？</p></blockquote><ul><li>不能。首先，文件系统是在用户态下实现的，改成0xC0000000涉及到了内核空间，在用户态下无法正常访问。其次，映射到内核空间会影响到内核存储的系统内容，导致系统异常。</li></ul><h3 id="Thinking5-7"><a href="#Thinking5-7" class="headerlink" title="Thinking5.7"></a>Thinking5.7</h3><blockquote><p>在 lab5 中，fs&#x2F;fs.h、include&#x2F;fs.h 等文件中出现了许多结构体和宏定 义，写出你认为比较重要或难以理解的部分，并进行解释。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//磁盘文件系统相关宏定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BY2BLKBY2PG <span class="hljs-comment">//一个块的大小正好是一页4096Byte</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT2BLK(BY2BLK*8) <span class="hljs-comment">//这里算的是BLK的bit，所以自然是*8</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BY2FILE     256 <span class="hljs-comment">//一个file结构体的大小 256Byte</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBLOCK 1024  <span class="hljs-comment">//一个disk里面有1024块</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE2BLK  (BY2BLK/sizeof(struct File)) <span class="hljs-comment">//一个块里面有多少个file结构体</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NDIRECT         10 <span class="hljs-comment">//直接指针最多能有10个</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NINDIRECT       (BY2BLK/4) <span class="hljs-comment">//间接指针的个数，为1024（包括了占位的10个直接指针）</span></span><br><br><span class="hljs-comment">//相关结构体</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_</span>* &#123;</span><br>    ...<br>&#125; <span class="hljs-comment">//这个是为fsipc中每一项服务专门建立的Fsreq结构体，用于给serve进程传递响应服务所需要的数据</span><br></code></pre></td></tr></table></figure><h3 id="Thinking5-8"><a href="#Thinking5-8" class="headerlink" title="Thinking5.8"></a>Thinking5.8</h3><blockquote><p>阅读 user&#x2F;file.c，你会发现很多函数中都会将一个 struct Fd* 型的 指针转换为 struct Filefd* 型的指针，请解释为什么这样的转换可行。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> <span class="hljs-title">f_fd</span>;</span><br>        u_int f_fileid;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">f_file</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>观察<code>user/fd.h</code>中对于<code>struct Filefd</code>的定义我们可以发现，<code>struct Fd</code>是Filefd的第一个成员，因此本质上指向他们的<strong>地址是相同的</strong>，只要通过指针类型转换，就可以访问其对应的内容。</li></ul><h3 id="Thinking5-9"><a href="#Thinking5-9" class="headerlink" title="Thinking5.9"></a>Thinking5.9</h3><blockquote><p>在lab4 的实验中我们实现了极为重要的fork 函数。那么fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成练习5.8和5.9的基础上编写一个程序进行验证。</p></blockquote><ul><li><p>会共享（这不就是lab5-2-exam的内容么）</p><p>验证程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> r, fdnum, n;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">520</span>];<br><span class="hljs-keyword">if</span> ((r = open(<span class="hljs-string">&quot;/motd&quot;</span>, O_RDWR)) &lt; <span class="hljs-number">0</span>) &#123;<br>    user_panic(<span class="hljs-string">&quot;open wrong\n&quot;</span>);<br>&#125;<br>fdnum = r;<br><span class="hljs-keyword">if</span> ((r = fwritef(fdnum, <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>    user_panic(<span class="hljs-string">&quot;fwritef wrong\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> ((r = fork()) == <span class="hljs-number">0</span>) &#123;<br>    n = read(fdnum, buf, <span class="hljs-number">5</span>);<br>    writef(<span class="hljs-string">&quot;child read is %s\n&quot;</span>, buf);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    n = read(fdnum, buf, <span class="hljs-number">5</span>);<br>    writef(<span class="hljs-string">&quot;father read is %s\n, buf&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">father read is abcde<br>child read is fghij<br></code></pre></td></tr></table></figure><p>不难验证在fork创建父子进程后，两者<strong>共享</strong>了文件描述符和定位指针，导致父进程读了abcde后，子进程接着往下读了fghij</p></li></ul><h3 id="Thinking5-10"><a href="#Thinking5-10" class="headerlink" title="Thinking5.10"></a>Thinking5.10</h3><blockquote><p>请解释Fd, Filefd, Open 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</p></blockquote><ul><li><code>struct Fd</code>：文件描述符，用于在打开文件时存取相关信息<ul><li><code>fd_dev_id</code> 对应外设的id</li><li><code>fd_offset</code> 读写位置的偏移量，避免了从头读到尾的浪费</li><li><code>fd_omode</code> 记录打开文件的模式</li></ul></li><li><code>Filefd</code>：可以看作是一个更全面记录文件信息的<strong>整合体</strong><ul><li><code>f_fd</code> 存储该文件的文件描述符Fd</li><li><code>f_fileid</code> 记录该文件的id</li><li><code>f_file</code> 存储该文件的文件控制块</li></ul></li><li><code>Open</code>：用于在<strong>打开文件这一过程</strong>中来抽象地整合信息<ul><li><code>*o_file</code> 指向被打开文件的文件控制块Fd</li><li><code>o_fileid</code> 记录该文件的id</li><li><code>o_mode</code> 记录文件的打开模式</li><li><code>*o_ff</code> 指向该文件的信息整合体Filefd</li></ul></li><li>三者都是单纯的内存数据，抽象层次由低到高为<code>Fd→Filefd→Open</code></li></ul><h3 id="Thinking5-11"><a href="#Thinking5-11" class="headerlink" title="Thinking5.11"></a>Thinking5.11</h3><blockquote><p>UML时序图中有多种不同形式的箭头，请结合UML 时序图的规范，解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</p></blockquote><ul><li><p>UML时序图中一共有六种消息</p><ul><li><p>同步消息：用黑三角箭头搭配实线表示。表现为发送者传递消息给接收者后<strong>暂停活动</strong>，等待回应。</p></li><li><p>异步消息：用开三角箭头搭配实现表示。表现为发送消息后，发送者不等待回应<strong>立即</strong>开始另一活动。</p></li><li><p>返回消息：用开三角箭头搭配虚线表示。和同步消息结合使用，唤醒同步消息的发送者。</p></li><li><p>创建消息：用开三角箭头搭配虚线，并注明<code>&lt;&lt;create&gt;&gt;</code>。用于创建一个实例。</p></li><li><p>摧毁消息：用黑三角箭头搭配实现表示，并注明<code>&lt;&lt;destroy&gt;&gt;</code>。用于摧毁一个实例</p></li><li><p>Lost and Found消息：用黑色实心点、黑三角箭头搭配实线表示。用于不关心发送者或接收者的情况。</p></li></ul></li><li><p>如何实现进程通信</p><ul><li>目前我们操作系统实现的是<strong>同步信息和返回信息</strong>的进程通信<ul><li>某一进程调用<code>ipc_recv</code>，向负责响应的进程<strong>发出同步消息</strong>并暂停活动，即完成进程切换</li><li><strong>响应进程</strong>收到消息后唤醒，通过<code>ipc_send</code>向对应地址映射内容完成<strong>返回消息的发送</strong>，再通过进程切换唤醒原来的进程</li></ul></li><li>在lab4-1-Extra中我们还实现了异步消息的进程通信<ul><li>不同于之前的进程通信，进程在调用<code>ipc_recv</code>后不通过进程却换来暂停活动，而是将请求记录下来，然后<strong>直接开始</strong>下一活动</li><li>响应进程调用<code>ipc_send</code>，则是通过请求记录，逐一进行处理</li></ul></li></ul></li></ul><h3 id="Thinking5-12"><a href="#Thinking5-12" class="headerlink" title="Thinking5.12"></a>Thinking5.12</h3><blockquote><p>阅读serv.c&#x2F;serve函数的代码，我们注意到函数中包含了一个死循环for (;;) {…}，为什么这段代码不会导致整个内核进入panic 状态？</p></blockquote><ul><li>serve进程是一个提供文件系统服务的进程，只有在其他进程向其发起请求的时候才会被唤醒，并且完成响应后再度沉睡。<strong>具体实现</strong>为：紧跟着<code>for (;;)</code>之后就有一句<code>req = ipc_recv(&amp;whom, REQVA, &amp;perm);</code>可见在每次循环的开始调用**<code>ipc_recv</code><strong>从而让出当前进程的位置陷入沉睡，直到其他进程调用文件系统相关接口时，调用了对应的<code>ipc_send</code>，serve进程被唤醒完成服务后</strong>又进入下一次循环**。</li></ul><h2 id="实验难点图示"><a href="#实验难点图示" class="headerlink" title="实验难点图示"></a>实验难点图示</h2><h3 id="①文件存储结构"><a href="#①文件存储结构" class="headerlink" title="①文件存储结构"></a>①文件存储结构</h3><ul><li>文件查询、文件创建都需要通过下图的存储逻辑进行索引查找。</li></ul><p><img src="/20220613/OSlab5%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220613091658713.png" alt="image-20220613091658713"></p><h3 id="②磁盘块缓冲工作流程"><a href="#②磁盘块缓冲工作流程" class="headerlink" title="②磁盘块缓冲工作流程"></a>②磁盘块缓冲工作流程</h3><ul><li>实际上我们在用户态下对磁盘数据的读写都是<strong>已经映射到块缓冲区</strong>的内容，操作时始终都是在内存上进行的。而这样的目的是，我们可以通过缓冲区的一个块，获取到不同磁盘上对应块的内容，只需要对该块解除对上一磁盘的映射，并建立对新磁盘的映射就可以实现，从而使得电脑有了很大的存储空间。</li></ul><p><img src="/20220613/OSlab5%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220613092801173.png" alt="image-20220613092801173"></p><h3 id="③文件系统服务流程"><a href="#③文件系统服务流程" class="headerlink" title="③文件系统服务流程"></a>③文件系统服务流程</h3><p><img src="/20220613/OSlab5%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220613094652147.png" alt="image-20220613094652147"></p><h2 id="体会与感想"><a href="#体会与感想" class="headerlink" title="体会与感想"></a>体会与感想</h2><p>​lab5的学习总体来说难度中规中矩，抽象层次明晰，对我理解操作系统不同层次间的交互模式起到了很大的帮助。在学习过程中，磁盘块、文件块、索引指针等概念给我造成了一定的困扰，分不清其中的转换关系，但在学习到块缓冲的部分后，我逐渐掌握了精髓，就是要分清楚文件系统中<strong>物理与虚拟</strong>、<strong>承载与被承载</strong>的角色，如此文件系统的结构便清晰明了了起来。操作系统的概念多且绕，但是在抓住某个关键点去理解后，便会有豁然开朗的感觉。</p><p>​至此OS的每周上机就告一段落了，虽然很折磨，但也变相压迫我加深了对每个lab的理解，同时千辛万苦做出Extra后也让人感到身心愉悦，在此十分感谢课程组的课程安排以及助教们的辛勤付出。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统实验报告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSlab5笔记</title>
    <link href="/20220608/OSlab5%E7%AC%94%E8%AE%B0/"/>
    <url>/20220608/OSlab5%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="lab5笔记"><a href="#lab5笔记" class="headerlink" title="lab5笔记"></a>lab5笔记</h1><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>fsformat.c实现对磁盘模拟的整体规划，fs.c实现磁盘到内存的交互</p><p>fsformat可以理解为每挂载一个磁盘时，就会运行一次，在fsformat的主函数中可以看到通过命令行对磁盘镜像进行了设置。disk是针对当前这一磁盘处理时显式的磁盘块。</p><h2 id="前置设定"><a href="#前置设定" class="headerlink" title="前置设定"></a>前置设定</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//一些宏</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BY2BLKBY2PG <span class="hljs-comment">//一个块的大小正好是一页4096Byte</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BIT2BLK(BY2BLK*8) <span class="hljs-comment">//这里算的是BLK的bit，所以自然是*8</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BY2FILE     256 <span class="hljs-comment">//一个file结构体的大小 256Byte</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NBLOCK 1024  <span class="hljs-comment">//一个disk里面有1024块</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FILE2BLK  (BY2BLK/sizeof(struct File)) <span class="hljs-comment">//一个块里面有多少个file结构体</span></span><br></code></pre></td></tr></table></figure><h4 id="磁盘模拟"><a href="#磁盘模拟" class="headerlink" title="磁盘模拟"></a>磁盘模拟</h4><p>在<code>fs/fsformat.c</code>中对磁盘进行了模拟，读取数据的时候可以通过<code>(disk[i].data)[j]</code>的形式来读取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Block</span> &#123;</span><br>    <span class="hljs-type">uint8_t</span> data[BY2BLK]; <span class="hljs-comment">//数据存储区 4096B</span><br>    <span class="hljs-type">uint32_t</span> type; <span class="hljs-comment">//磁盘块类型</span><br>&#125; disk[NBLOCK];<br></code></pre></td></tr></table></figure><h4 id="磁盘块类型"><a href="#磁盘块类型" class="headerlink" title="磁盘块类型"></a>磁盘块类型</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    BLOCK_FREE  = <span class="hljs-number">0</span>,<br>    BLOCK_BOOT  = <span class="hljs-number">1</span>,<br>    BLOCK_BMAP  = <span class="hljs-number">2</span>,<br>    BLOCK_SUPER = <span class="hljs-number">3</span>,<br>    BLOCK_DATA  = <span class="hljs-number">4</span>,<br>    BLOCK_FILE  = <span class="hljs-number">5</span>,<br>    BLOCK_INDEX = <span class="hljs-number">6</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="磁盘文件系统布局"><a href="#磁盘文件系统布局" class="headerlink" title="磁盘文件系统布局"></a>磁盘文件系统布局</h2><p>MOS 操作系统把磁盘最开始的一个磁盘块 (4096 字节) 当作启动扇区和分区表使用。接下来的一个磁盘块作为超级块 </p><h3 id="文件信息存储"><a href="#文件信息存储" class="headerlink" title="文件信息存储"></a>文件信息存储</h3><h4 id="File结构体"><a href="#File结构体" class="headerlink" title="File结构体"></a>File结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> &#123;</span><br>    u_char f_name[MAXNAMELEN]; <span class="hljs-comment">//文件名，MAXNAMELEN是最大长度</span><br>    u_int f_size; <span class="hljs-comment">//文件大小</span><br>    u_int f_type; <span class="hljs-comment">//文件类型：普通文件、文件夹</span><br>    u_int f_direct[NDIRECT]; <span class="hljs-comment">//直接指针</span><br>    u_int f_indirect; <span class="hljs-comment">//间接指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f_dir</span>;</span> <span class="hljs-comment">//指向文件所属的文件目录</span><br>    u_char f_pad[BY2FILE - MAXNAMELEN - <span class="hljs-number">4</span> - <span class="hljs-number">4</span> - NDIRECT * <span class="hljs-number">4</span> - <span class="hljs-number">4</span> - <span class="hljs-number">4</span>]; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>NDIRECT &#x3D; 10 即最多有10个直接指针，若文件大于40KB，则需要通过<code>f_indirect</code>指向一个间接磁盘块，用来存储剩余的间接指针。另外，为了简化，间接磁盘块中前十个指针会空出来，假装是直接指针占用了。</li><li>f_pad 是为了让File的大小规范化，使其大小为BY2FILE 256B，一个磁盘块能刚好存16个文件控制块。</li></ul><p><img src="/20220608/OSlab5%E7%AC%94%E8%AE%B0/lab5-pic-3.png" alt="[lab5-file block]"></p><h4 id="文件查找过程"><a href="#文件查找过程" class="headerlink" title="文件查找过程"></a>文件查找过程</h4><ul><li>目录文件指向的磁盘块存储着各个文件对应的文件控制块<ul><li>从超级块中读根目录的文件控制块</li><li>文件控制块 –&gt; 通过指针到达对应磁盘块 –&gt;获取下一文件控制块 （在这磁盘块是存储文件控制块的地方）</li><li>最终找到文件</li></ul></li></ul><h4 id="Exe5-4-create-file函数"><a href="#Exe5-4-create-file函数" class="headerlink" title="Exe5.4 create_file函数"></a>Exe5.4 create_file函数</h4><p>​该函数通关传入的目录指针，在该目录下创建一个文件。<strong>实际上就是在该目录下找一个空文件块，返回其指针，其余的操作概不负责。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> File *<span class="hljs-title function_">create_file</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *dirf)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">dirblk</span>;</span><br>    <span class="hljs-type">int</span> i, bno, found, j;<br>    <span class="hljs-type">int</span> nblk = dirf-&gt;f_size / BY2BLK; <span class="hljs-comment">//先根据目录大小获得磁盘块的个数</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nblk; i++) &#123; <br>                <span class="hljs-keyword">if</span> (i &lt; NDIRECT) &#123;<br>                        bno = dirf-&gt;f_direct[i]; <span class="hljs-comment">//直接指针直接取</span><br>                &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//简介指针需要到指向的磁盘块获得相应指针</span><br>                        bno = ((<span class="hljs-type">uint32_t</span> *)(disk[dirf-&gt;f_indirect].data))[i];<br>                &#125;<br>                dirblk = (<span class="hljs-keyword">struct</span> File *)(disk[bno].data); <span class="hljs-comment">//设置对应磁盘块后的文件块头指针</span><br>                <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; FILE2BLK; j++) &#123;<br>                        <span class="hljs-keyword">if</span> (dirblk[j].f_name[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123; <span class="hljs-comment">//文件名被重置了，说明原文件被删除</span><br>                                <span class="hljs-keyword">return</span> &amp;dirblk[j]; <span class="hljs-comment">//返回该文件块的指针</span><br>                        &#125;<br>                &#125;<br>        &#125;<br>    <span class="hljs-comment">//找了一遍当前的磁盘块中的文件块都无空闲，则直接新增一个磁盘块，来创立新文件块</span><br>        bno = make_link_block(dirf, nblk); <br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">struct</span> File *)disk[bno].data; <span class="hljs-comment">//由于是一个新磁盘块，直接返回第一个文件块即可</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>要注意过程是找到磁盘块，再在磁盘块中找文件控制块</p></li><li><p>本质上是同地址，不同类型间的转换，再通过指针偏移来获取对应块的数据</p></li><li><p>创建新磁盘块的过程中调用了<code>make_link_block next_block save_block_link</code>三个函数</p><ul><li><p>&#96;&#96;&#96;c<br>int make_link_block(struct File *dirf, int nblk) {<br>int bno &#x3D; next_block(BLOCK_FILE); &#x2F;&#x2F;获取一个新类型为文件的磁盘块<br>save_block_link(dirf, nblk, bno); &#x2F;&#x2F;为这个磁盘块设立链接<br>dirf-&gt;f_size +&#x3D; BY2BLK; &#x2F;&#x2F;修改原目录的长度<br>return bno; &#x2F;&#x2F;最终返回块号<br>}</p><p>int next_block(int type) { &#x2F;&#x2F;设置磁盘块的类型并返回块号<br>disk[nextbno].type &#x3D; type;<br>return nextbno++;<br>}</p><p>void save_block_link(struct File *f, int nblk, int bno)<br>{<br>assert(nblk &lt; NINDIRECT); &#x2F;&#x2F;判断要存为直接指针还是间接指针<br><br>if(nblk &lt; NDIRECT) {<br>    f-&gt;f_direct[nblk] &#x3D; bno; &#x2F;&#x2F;记录块号<br>}<br>else {<br>    if(f-&gt;f_indirect &#x3D;&#x3D; 0) { &#x2F;&#x2F;如果未创建过 存简介指针 的磁盘块，则建一个<br>        &#x2F;&#x2F; create new indirect block.<br>        f-&gt;f_indirect &#x3D; next_block(BLOCK_INDEX);<br>    }<br>    ((uint32_t *)(disk[f-&gt;f_indirect].data))[nblk] &#x3D; bno; &#x2F;&#x2F;记录块号<br>}<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### 磁盘块缓存<br><br>`DISKMAP~DISKMAP + DISKMAP`，即`<span class="hljs-number">0x10000000</span><span class="hljs-number">-0x4fffffff</span>`，在虚存空间中当作**磁盘的缓冲区**，我们在其中申请页面，用于给磁盘读入时进行映射。<br><br>- 要搞清一个概念：磁盘可以有很多个，但统一磁块号对应的缓冲区块只有一个（？）<br><br>#### Exe5<span class="hljs-number">.5</span> diskaddr函数<br><br>该函数用来通过磁盘块号获取对应的缓冲区地址<br><br>```c<br>u_int<br>diskaddr(u_int blockno)<br>&#123;<br>        <span class="hljs-keyword">if</span> (super) &#123;<br>                <span class="hljs-keyword">if</span> (blockno &gt;= super-&gt;s_nblocks) &#123; <span class="hljs-comment">//若磁盘块超过的块上限，则报错</span><br>                        user_panic(<span class="hljs-string">&quot;blockno wrong : no super&quot;</span>);<br>                &#125;<br>        &#125;<br>        <span class="hljs-comment">//writef(&quot;%d : %x\n&quot;, blockno, (DISKMAP + (blockno * BY2BLK)));</span><br>        return (DISKMAP + (blockno * BY2BLK)); <span class="hljs-comment">//本质上就是num * size</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Exe5-6-map-block函数"><a href="#Exe5-6-map-block函数" class="headerlink" title="Exe5.6 map_block函数"></a>Exe5.6 map_block函数</h4><p>该函数用于给磁盘块映射内存，会首先检查是否已经映射，如若没有就申请新的一页来映射。</p><ul><li>检验映射用到了<code>block_is_mapped 和 va_is_mapped</code>，本质上就是获取到目标的虚拟地址va，然后通过页表和页表项来该地址判断有无被映射。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">map_block</span><span class="hljs-params">(u_int blockno)</span><br>&#123;<br>        u_int va;<br>        <span class="hljs-keyword">if</span> (block_is_mapped(blockno) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> syscall_mem_alloc(<span class="hljs-number">0</span>, diskaddr(blockno), PTE_V | PTE_R);<br>&#125;<br><br>u_int <span class="hljs-title function_">block_is_mapped</span><span class="hljs-params">(u_int blockno)</span><br>&#123;<br>        u_int va = diskaddr(blockno);<br>        <span class="hljs-keyword">if</span> (va_is_mapped(va)) &#123;<br>                <span class="hljs-keyword">return</span> va;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>u_int <span class="hljs-title function_">va_is_mapped</span><span class="hljs-params">(u_int va)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> (((*vpd)[PDX(va)] &amp; (PTE_V)) &amp;&amp; ((*vpt)[VPN(va)] &amp; (PTE_V)));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Exe5-7-dir-lookup函数"><a href="#Exe5-7-dir-lookup函数" class="headerlink" title="Exe5.7 dir_lookup函数"></a>Exe5.7 dir_lookup函数</h4><p>​该函数用于查找目录下有无<code>name</code>对应的文件</p><p>​查询的过程类似<code>create_file</code></p><ul><li><code>file_get_block</code>通过目录f获取其中的第<code>filebno</code>个块并为其分配物理内存，然后用<code>read_block</code>读取磁盘块内容到内存上，最后用blk返回该块对应的虚拟地址</li><li><code>file_map_block</code><ul><li><code>file_block_walk</code>是查询块号的最终实现者</li><li><code>alloc_block</code>调用<code>alloc_block_num</code>获取一个空闲的磁盘块号，然后用<code>map_block</code>给这个块建立内存映射</li></ul></li><li><code>read_block</code>将blockno对应的块读到其内存映射的地址上，并用blk返回虚拟地址，isnew为1说明了是刚刚建立了映射。</li></ul><p><strong>注意两个号的区分：一个是目录下第几个文件的文件号filebno，一个是实际上磁盘中的块号diskbno！！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dir_lookup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *dir, <span class="hljs-type">char</span> *name, <span class="hljs-keyword">struct</span> File **file)</span><br>&#123;<br>        <span class="hljs-type">int</span> r;<br>        u_int i, j, nblock;<br>        <span class="hljs-type">void</span> *blk;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f</span>;</span><br>        nblock = (dir-&gt;f_size, BY2BLK) /BY2BLK; <span class="hljs-comment">//通过f_size获取磁盘块的个数</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nblock; i++) &#123; <br>                <span class="hljs-keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="hljs-number">0</span>) &#123; <br>                    <span class="hljs-comment">//获取对应块在虚存中的地址，用blk返回</span><br>                        <span class="hljs-keyword">return</span> r;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; FILE2BLK; j++) &#123; <br>                        f = ((<span class="hljs-keyword">struct</span> File *)blk) + j; <br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>((<span class="hljs-type">char</span> *)f-&gt;f_name, name) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//若找到则直接返回对应文件块</span><br>                                f-&gt;f_dir = dir; <span class="hljs-comment">//因为这是直接通过目录查找，可能之前未对f_dir进行赋值</span><br>                                *file = f; <span class="hljs-comment">//返回文件块</span><br>                                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                        &#125;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -E_NOT_FOUND;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">file_get_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f, u_int filebno, <span class="hljs-type">void</span> **blk)</span><br>&#123;<br>        <span class="hljs-type">int</span> r;<br>        u_int diskbno;<br>        u_int isnew;<br>        <span class="hljs-keyword">if</span> ((r = file_map_block(f, filebno, &amp;diskbno, <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r; <span class="hljs-comment">//获取diskbno，即filebno对应的块号</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> ((r = read_block(diskbno, blk, &amp;isnew)) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r; <span class="hljs-comment">//将这个块读进内存中</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">file_map_block</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f, u_int filebno, u_int *diskbno, u_int alloc)</span><br>&#123;<br>        <span class="hljs-type">int</span> r;<br>        u_int *ptr;<br>        <span class="hljs-keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, alloc)) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r; <span class="hljs-comment">//根据filebno获取对应块的地址</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (*ptr == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//若返回的ptr是空指针</span><br>                <span class="hljs-keyword">if</span> (alloc == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> -E_NOT_FOUND;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> ((r = alloc_block()) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//申请一个新的磁盘块</span><br>                        <span class="hljs-keyword">return</span> r;<br>                &#125;<br>                *ptr = r;<br>        &#125;<br>        *diskbno = *ptr;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">read_block</span><span class="hljs-params">(u_int blockno, <span class="hljs-type">void</span> **blk, u_int *isnew)</span><br>&#123;<br>        u_int va;<br>        <span class="hljs-keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks) &#123; <span class="hljs-comment">//异常：块号越界</span><br>                user_panic(<span class="hljs-string">&quot;reading non-existent block %08x\n&quot;</span>, blockno);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno)) &#123; <span class="hljs-comment">//异常：查询块未被映射</span><br>                user_panic(<span class="hljs-string">&quot;reading free block %08x\n&quot;</span>, blockno);<br>        &#125;<br>        va = diskaddr(blockno); <span class="hljs-comment">//获取对应的虚拟地址</span><br>        <span class="hljs-keyword">if</span> (block_is_mapped(blockno)) &#123; <span class="hljs-comment">// the block is in memory</span><br>                <span class="hljs-keyword">if</span> (isnew) &#123;<br>                        *isnew = <span class="hljs-number">0</span>;<br>                &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-comment">// the block is not in memory</span><br>                <span class="hljs-keyword">if</span> (isnew) &#123;<br>                        *isnew = <span class="hljs-number">1</span>;<br>                &#125;<br>                syscall_mem_alloc(<span class="hljs-number">0</span>, va, PTE_V | PTE_R); <span class="hljs-comment">//申请物理页面</span><br>                ide_read(<span class="hljs-number">0</span>, blockno * SECT2BLK, (<span class="hljs-type">void</span> *)va, SECT2BLK); <span class="hljs-comment">//从磁盘读入</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (blk) &#123;<br>                *blk = (<span class="hljs-type">void</span> *)va; <span class="hljs-comment">//返回对应虚拟地址</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">file_block_walk</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> File *f, u_int filebno, u_int **ppdiskbno, u_int alloc)</span><br>&#123;<br>        <span class="hljs-type">int</span> r;<br>        u_int *ptr;<br>        <span class="hljs-type">void</span> *blk;<br>        <span class="hljs-keyword">if</span> (filebno &lt; NDIRECT) &#123; <span class="hljs-comment">//通过直接指针直接获取磁盘块号</span><br>                ptr = &amp;f-&gt;f_direct[filebno];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (filebno &lt; NINDIRECT) &#123;<br>                <span class="hljs-keyword">if</span> (f-&gt;f_indirect == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//还未创建“间接指针”磁盘块</span><br>                        <span class="hljs-keyword">if</span> (alloc == <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-keyword">return</span> -E_NOT_FOUND;<br>                        &#125;<br><br>                        <span class="hljs-keyword">if</span> ((r = alloc_block()) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//创建一个新的磁盘块</span><br>                                <span class="hljs-keyword">return</span> r;<br>                        &#125;<br>                        f-&gt;f_indirect = r; <span class="hljs-comment">//记录下块号</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> ((r = read_block(f-&gt;f_indirect, &amp;blk, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> r; <span class="hljs-comment">//将磁盘内容读入内存中，blk返回的是内存中磁盘块对应的虚拟地址</span><br>                &#125;<br>                ptr = (u_int *)blk + filebno; <br>            <span class="hljs-comment">//这里返回的是 存简介指针磁盘块 的 第filebno个间接指针 的地址，目的是返回磁盘块号</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>        *ppdiskbno = ptr;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">alloc_block</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-type">int</span> r, bno;<br>        <span class="hljs-keyword">if</span> ((r = alloc_block_num()) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// failed.</span><br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        bno = r;<br>        <span class="hljs-keyword">if</span> ((r = map_block(bno)) &lt; <span class="hljs-number">0</span>) &#123;<br>                free_block(bno);<br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> bno;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="用户接口"><a href="#用户接口" class="headerlink" title="用户接口"></a>用户接口</h2><p>操作系统的设计是将磁盘文件系统当作了一个serv进程来设计，而不是系统内核本身对所有进程开放，两者有着本质区别。既然作为一个进程，就需要实现用户态下的用户接口，用于文件系统的相关操作。</p><blockquote><p>文件系统属于用户态进程，以服务的形式供其他进程调用。这个过程中，不仅涉及了不同进程之间通信的问题，也涉及了文件系统如何隔离底层的文件系统实现，抽象地表示一个文件的问题。我们引入文件描述符（file descriptor）作为用户程序管理、操作文件资源的方式。</p></blockquote><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><h4 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h4><ul><li>Dev 诸多文教操作外设的方法集合</li><li>Fd 文件描述符，用于</li><li>Stat ？</li><li>Filefd 文件描述符与文件控制块的整合体</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dev</span> &#123;</span><br>        <span class="hljs-type">int</span> dev_id;<br>        <span class="hljs-type">char</span> *dev_name;<br>        <span class="hljs-type">int</span> (*dev_read)(<span class="hljs-keyword">struct</span> Fd *, <span class="hljs-type">void</span> *, u_int, u_int);<br>        <span class="hljs-type">int</span> (*dev_write)(<span class="hljs-keyword">struct</span> Fd *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *, u_int, u_int);<br>        <span class="hljs-type">int</span> (*dev_close)(<span class="hljs-keyword">struct</span> Fd *);<br>        <span class="hljs-type">int</span> (*dev_stat)(<span class="hljs-keyword">struct</span> Fd *, <span class="hljs-keyword">struct</span> Stat *);<br>        <span class="hljs-type">int</span> (*dev_seek)(<span class="hljs-keyword">struct</span> Fd *, u_int);<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> &#123;</span><br>        u_int fd_dev_id; <span class="hljs-comment">//对应外设的id</span><br>        u_int fd_offset; <span class="hljs-comment">//读写位置的偏移量</span><br>        u_int fd_omode; <span class="hljs-comment">//打开模式</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stat</span> &#123;</span><br>        <span class="hljs-type">char</span> st_name[MAXNAMELEN];<br>        u_int st_size;<br>        u_int st_isdir;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dev</span> *<span class="hljs-title">st_dev</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> <span class="hljs-title">f_fd</span>;</span><br>        u_int f_fileid;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> <span class="hljs-title">f_file</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="Exe5-8-open函数"><a href="#Exe5-8-open函数" class="headerlink" title="Exe5.8 open函数"></a>Exe5.8 open函数</h4><p>​该函数是用户态打开文件的接口，通过传入的文件路径和打开模式，最终返回文件描述符的编号</p><ul><li>新建一个文件描述符</li><li>通过fsipc_open使得fd中载入了对应的文件信息</li><li>通过fsipc_map将该文件的所有块载入内存之中</li></ul><blockquote><p>当用户进程向文件系统发送打开文件的请求时，文件系统进程会将这些基本信息记录在内存中，然后由操作系统将用户进程请求的地址映射到同一个物理页上，因此一个文件描述符至少需要独占一页的空间。当用户进程获取了文件大小等基本信息后，再次向文件系统发送请求将文件内容映射到指定内存空间中。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">int</span> mode)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">fd</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filefd</span> *<span class="hljs-title">ffd</span>;</span><br>        u_int size, fileid;<br>        <span class="hljs-type">int</span> r;<br>        u_int va;<br>        u_int i;<br>        <span class="hljs-keyword">if</span> ((r = fd_alloc(&amp;fd)) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//创建一个新的文件描述符fd</span><br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>         <span class="hljs-keyword">if</span> ((r = fsipc_open(path, mode, fd)) &lt; <span class="hljs-number">0</span>) &#123; <br>                <span class="hljs-keyword">return</span> r; <span class="hljs-comment">//通过进程通信</span><br>        &#125;<br>        ffd = (<span class="hljs-keyword">struct</span> Filefd *)fd; <span class="hljs-comment">//将fd直接转换为Fildfd，访问f_fileid和f_file字段</span><br>        va = fd2data(fd);<br>        fileid = ffd-&gt;f_fileid;<br>        size = ffd-&gt;f_file.f_size;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i += BY2BLK) &#123; <span class="hljs-comment">//为该文件的每个块，映射入内存</span><br>                <span class="hljs-keyword">if</span> ((r = fsipc_map(fileid, i, va + i)) &lt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> r;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> fd2num(fd); <span class="hljs-comment">//最后返回这个fd的序号</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Exe5-9-read函数"><a href="#Exe5-9-read函数" class="headerlink" title="Exe5.9 read函数"></a>Exe5.9 read函数</h4><blockquote><p>当我们要读取一个大文件中间的一小部分内容时，从头读到尾是极为浪费的，因此我们需要一个指针帮助我们在文件中定位。在读写期间，每次读写也会更新该指针的值。 <strong>见fd_offset</strong></p></blockquote><ul><li>获取对应的fd块以及设备块</li><li>判断权限</li><li>通过设备块中的read操作完成读操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fdnum, <span class="hljs-type">void</span> *buf, u_int n)</span><br>&#123;<br>        <span class="hljs-type">int</span> r;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dev</span> *<span class="hljs-title">dev</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fd</span> *<span class="hljs-title">fd</span>;</span><br>        <span class="hljs-keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//获取fd</span><br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r; <span class="hljs-comment">//获取该fd对应的设备操作体</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_WRONLY) &#123; <span class="hljs-comment">//检验权限</span><br>                writef(<span class="hljs-string">&quot;[%08x] read %d -- bad mode\n&quot;</span>, env-&gt;env_id, fdnum);<br>                <span class="hljs-keyword">return</span> -E_INVAL;        &#125;<br>        <span class="hljs-keyword">if</span> (debug) writef(<span class="hljs-string">&quot;read %d %p %d via dev %s\n&quot;</span>, fdnum, buf, n, dev-&gt;dev_name);<br>    <span class="hljs-comment">//这个是debug模式下的输出，不用管</span><br>        r = (*dev-&gt;dev_read)(fd, buf, n, fd-&gt;fd_offset); <br>    <span class="hljs-comment">//调用了设备操作中的read操作，将内容存到缓冲区buf中</span><br>        <span class="hljs-keyword">if</span> (r &gt; <span class="hljs-number">0</span>) &#123;<br>                fd-&gt;fd_offset += r; <span class="hljs-comment">//实现前文所述的指针，提升读写效率</span><br>        &#125;<br>        ((<span class="hljs-type">char</span> *)buf)[r] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>注：</p><ul><li>file_read是read底层的一个函数，在read中通过<code>(*dev-&gt;dev_read)</code>调用，实现了读取文件中一定长度内容的功能。</li><li>同理open和file_open的关系也是如此，open中调用了fsipc_open最终在底层的serve_open中调用了file_open，总体上是通过path得到了该文件的文件控制块fd</li></ul><h3 id="文件服务系统"><a href="#文件服务系统" class="headerlink" title="文件服务系统"></a>文件服务系统</h3><ul><li>serv进程类似于系统调用，fs&#x2F;serv.c中的serve函数，通过<code>ipc_recv</code>函数的返回值，即对应的操作号，调用相应的serve函数完成文件系统的相应操作。</li><li>在fsipc()函数中将第二个进程默认为serve进程，创建时也要注意将其放在第二个</li><li>！！要始终明白文件系统的操作是在内存上的，磁盘只实现了存储和磁盘块的读与写。<ul><li>在需要打开文件时，前文提到的块缓存中通过fsipc_open和fsipc_map（最终是file_get_block）将磁盘内容存入了内存中</li><li>调用unmap_block会检验dirty标志，如若被修改过了，会将内容重新写入磁盘中</li></ul></li></ul><h4 id="Exe5-10-删除操作"><a href="#Exe5-10-删除操作" class="headerlink" title="Exe5.10 删除操作"></a>Exe5.10 删除操作</h4><p>需要完成三个函数：user&#x2F;fsipc.c的fsipc_remove user.file.c的remove fs&#x2F;serv.c的serve_remove</p><p>三者的关系是 <strong>用户接口remove – 底层申请操作fsipc_remove – 文件系统响应服务serve_remove</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span><br>&#123;<br>        <span class="hljs-keyword">return</span> fsipc_remove(path); <span class="hljs-comment">//用户态的remove接口</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fsipc_remove</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Fsreq_remove</span>* <span class="hljs-title">f</span>;</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(path) &gt;= MAXPATHLEN) &#123; <span class="hljs-comment">//检验path是否合法</span><br>                <span class="hljs-keyword">return</span> -E_BAD_PATH;<br>        &#125;<br>        f = (<span class="hljs-keyword">struct</span> Fsreq_remove *)fsipcbuf; <span class="hljs-comment">//创建申请操作的req</span><br>        <span class="hljs-built_in">strcpy</span>((<span class="hljs-type">char</span> *)f-&gt;req_path, path); <span class="hljs-comment">//传入需要删除文件的地址</span><br>        <span class="hljs-keyword">return</span> fsipc(FSREQ_REMOVE, f, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">serve_remove</span><span class="hljs-params">(u_int envid, <span class="hljs-keyword">struct</span> Fsreq_remove *rq)</span><br>&#123;<br>        <span class="hljs-type">int</span> r; <br>        u_char path[MAXPATHLEN];<br>        <span class="hljs-built_in">strcpy</span>(path, (<span class="hljs-type">char</span> *)rq-&gt;req_path); <br>        path[MAXPATHLEN - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">//保证路径有效</span><br>        r = file_remove(path); <span class="hljs-comment">//删除文件</span><br>        ipc_send(envid, r, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//完成响应后将反馈发送出去</span><br>&#125; <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">file_remove</span><span class="hljs-params">(<span class="hljs-type">char</span> *path)</span><br>&#123;<br>        <span class="hljs-type">int</span> r;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> *<span class="hljs-title">f</span>;</span><br>        <span class="hljs-keyword">if</span> ((r = walk_path(path, <span class="hljs-number">0</span>, &amp;f, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r; <span class="hljs-comment">//在磁盘中找到对应的文件（控制块）</span><br>        &#125;<br>        file_truncate(f, <span class="hljs-number">0</span>); <span class="hljs-comment">//删除文件的相关块的（不太清楚）</span><br>        f-&gt;f_name[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>; <span class="hljs-comment">//将名字重置以表示该文件被删除</span><br>        file_flush(f); <span class="hljs-comment">//将相应块标为dirty，说明需要写回更新</span><br>        <span class="hljs-keyword">if</span> (f-&gt;f_dir) &#123;<br>                file_flush(f-&gt;f_dir); <span class="hljs-comment">//目录所在块同样需要更新</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统实验笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OO第三单元总结</title>
    <link href="/20220606/OO%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/20220606/OO%E7%AC%AC%E4%B8%89%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="OO第三单元总结"><a href="#OO第三单元总结" class="headerlink" title="OO第三单元总结"></a>OO第三单元总结</h1><h2 id="数据构造"><a href="#数据构造" class="headerlink" title="数据构造"></a>数据构造</h2><p>​基于JML规格构造数据本质上就是检查方法能否满足<strong>功能与异常情况</strong>，</p><h3 id="异常检验"><a href="#异常检验" class="headerlink" title="异常检验"></a>异常检验</h3><p>​异常一般看的是前置条件，分为抛出型异常以及隐性异常。</p><p>​比较常见的是抛出型异常，对于该种异常的检验，我们应针对触发异常的条件专门去构造数据，从而检查程序能否正确抛出相应异常，做到不重不漏，同时要注意不同异常触发条件间的包含关系。</p><p>​除此之外，隐形异常在触发后不会抛出，但会阻止原有代码，并使方法正常结束，例如在<code>addToGroup</code>中当Group中的people人数大于等于1111后，遍会组织新的People再加入，对此我们亦要构造相应数据，检验是否能正确处理相应异常。</p><h3 id="功能性检验"><a href="#功能性检验" class="headerlink" title="功能性检验"></a>功能性检验</h3><p>​功能检验主要看的是后置条件，大致有三个方面：保持原状的成员、新加入的成员、计算所得的结果。一般来说保持原状的成员这一点如果不整什么骚操作不会导致错误，所以重点检查后两者是否正确。</p><p>​功能性的检验一般是在不触发异常的情况下，尽可能构造多种的情况，以检验实现过程的正确性。例如在派发Message时要检验各类Message是否正确被发送，这需要多个指令相互协作来检验；另外，对于每次作业的图论题，则是要多构造一些图，来检验图论算法的正确性。</p><p>​值得注意的是，由于数据量的限定，算法的时间复杂度也是一个需要注意检查的点，十分容易没想清楚最终导致超时，这在后续会再详细分析。</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="任务与迭代"><a href="#任务与迭代" class="headerlink" title="任务与迭代"></a>任务与迭代</h3><p>​本次作业的架构整体上都由JML给出，要求实现一个基础的社交网络，拥有主体Person、Group，主体间交互的Message，以及实现环境模拟的Network对象。除此之外，在每次作业中，都有一个图论算法需要我们去学习实现。</p><h4 id="第九次作业"><a href="#第九次作业" class="headerlink" title="第九次作业"></a>第九次作业</h4><p>​第三单元的第一次作业比较基础，旨在让我们熟悉JML语言，要求实现社交网络中的人员与团体的添加、人员关联以及相关值的查询功能。</p><p>​其中的qci检查两人是否能通过社交链关联的指令，涉及到并查集，为了避免超时，我采用了路径压缩的优化方法，即在查询过程中，主动得将并查集的子节点连接到根节点上，如此可使每次得根节点查询优化到O(1)，极大节约了时间。</p><h4 id="第十次作业"><a href="#第十次作业" class="headerlink" title="第十次作业"></a>第十次作业</h4><p>​引入了社交网络中的Message概念，需要实现Message的添加及发送，涉及到Person间的相关值变动。</p><p>​图论算法考察的是最小生成树，在理解JML规格要求和，不难简化出要求为求出最小生成树的边权和，我选择了prim算法，但由于实现的错误最后导致了超时，在后面的性能分析中会再次提到。</p><h4 id="第十一次作业"><a href="#第十一次作业" class="headerlink" title="第十一次作业"></a>第十一次作业</h4><p>​最后一次作业主要是丰富了Message的种类（通过继承实现），分为原来的普通，表情，红包以及emoji共四种，需要我们分辨Message的种类，并实现相应的具体功能，如此使得设计网络更丰富更贴切实际。</p><p>​图论考察了最短路算法，通过给出某个Person，经过ar关联关系找到另一个Person，最终返回该路径的总值。我采用了经典的迪杰斯特拉算法，并加以堆优化以提升效率，java中可以直接使用priority_queue，其帮我们完成了最小堆的构建，十分方便。</p><h3 id="数据维护"><a href="#数据维护" class="headerlink" title="数据维护"></a>数据维护</h3><p>​在数据维护的过程中，由于各对象具有共同特点——具有唯一id，因此在存储的时候我基本采用了HashMap来进行存储，以id为Key具体对象为Value，通过使用containsKey等方法，使得对象的检索获取等步骤极大简化，且由于哈希的特性，使得我们无须在此类操作上顾虑时间消耗。但值得注意的是，HashMap中存储为乱序，不具有List的顺序特性，需要留意JML规格是否需要该容器满足List的特性，选用正确的容器。</p><h2 id="性能问题及修复"><a href="#性能问题及修复" class="headerlink" title="性能问题及修复"></a>性能问题及修复</h2><p>​在这个单元的作业中，性能问题是十分关键的一个点，在经过了大量随机数据的对拍检验后，在不考虑性能问题的前提下，程序的正确性基本能够得到保证。因此，由于性能问题一般是由于思维漏洞亦或是不严谨导致，往往容易被忽略，这也成为了导致强测出错以及互测hack的一个关键点。</p><p>​就我个人而言，本次出现的问题主要出现在<code>query_group_value_sum</code>和<code>query_least_connection</code>两个指令上。</p><p>​<code>qgvs</code>需要统计Group中所有Person的Value之和，我在原来实现的是每一次查询都遍历一遍所有Person重新算一遍该值，导致我每次查询的时间复杂度都到达了O(n)，当有大量的qgvs查询时，遍很容易导致超时。对此我们需要了解到<strong>动态维护</strong>的思想，对于上述情况我们可以修改为，在每次addPerson、delPerson以及ar建立关系（即所有可能进行可能会影响到ValueSum的操作）时，动态地根据当前操作对ValueSum进行维护，这样就可以使得每一次的<code>qgvs</code>查询只需要O(1)的时间复杂度，极大得提升了程序的性能。</p><p>​qlc则是一个最小生成树算法的实现，这里出现的性能问题则是我对算法的理解与实现产生了偏差。我采用了Prim算法，从某一点出发，每次找寻一条权值最小且未曾与出发点关联的边，不断进行拓展直至关联所有点。在我错误的实现中，并没有采用普遍的类似于迪杰斯特拉算法的形式，而是将所有新拓展的边加入边集中，每次找边都花费了大量时间去过滤掉那些已经处于出发点集合内的边，最终导致了超时。正确的实现方式应该是在每次拓展后，根据新拓展的边去更新到达每个点的最小边，这般便可以将每次拓展找边的时间复杂度从O(m)降低到O(n)，就不会导致超时了。可见算法的实现方式，是保证实现预期效果的重要一环。</p><h2 id="拓展设计"><a href="#拓展设计" class="headerlink" title="拓展设计"></a>拓展设计</h2><p>根据要求，我们对Person进行继承拓展，新增一下三种Person</p><ul><li>Advertiser：持续向外发送产品广告</li><li>Producer：产品生产商，通过Advertiser来销售产品</li><li>Customer：消费者，会关注广告并选择和自己偏好匹配的产品来购买 – 所谓购买，就是直接通过Advertiser给相应Producer发一个购买消息</li></ul><p>除此之外，为了直线上述Person间的交互，还需新增相应的Message种类</p><ul><li>AdvertiseMessge：Advertiser告知Customer，向其发送产品广告</li><li>PurchaseMessage：Advertiser给相应Producer发送购买信息，帮助Customer购买产品</li></ul><p>核心业务功能接口方法的JML规格</p><ul><li>委托销售，即将对应产品委托Advertiser推销，id1为产品id，id2为PersonId</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*@ public normal_behavior</span><br><span class="hljs-comment">@ requires (\exists int i; 0 &lt;= i &amp;&amp; i &lt; persons.length; persons[i].getId() == id2)&amp;&amp;</span><br><span class="hljs-comment">@         (\exists int i; 0 &lt;= i &amp;&amp; i &lt; products.length; products[i].getId() == id1) &amp;&amp;</span><br><span class="hljs-comment">@ assignable getPerson(id2);</span><br><span class="hljs-comment">@ ensures (\forall Procut i; \old(getPerson(id2).hasProduct(i));</span><br><span class="hljs-comment">@          getPerson(id2).hasProduct(i));</span><br><span class="hljs-comment">@ ensures getPerson(id2).hasProduct(getPerson(id1));</span><br><span class="hljs-comment">@ also</span><br><span class="hljs-comment">@ public exceptional_behavior</span><br><span class="hljs-comment">@ signals(PersonIdNotFoundException e)!(\exists int i; 0 &lt;= i &amp;&amp; i &lt;persons.length;</span><br><span class="hljs-comment">@          persons[i].getId() == id2);</span><br><span class="hljs-comment">@ signals(ProductIdNotFoundException e)(\exists int i; 0 &lt;= i &amp;&amp; i &lt;persons.length;</span><br><span class="hljs-comment">@       persons[i].getId() == id2)&amp;&amp;!(\exists int i; 0 &lt;= i &amp;&amp; i &lt; products.length;</span><br><span class="hljs-comment">@           product[i].getId() == id1);</span><br><span class="hljs-comment">@ signals (EqualProductIdException e) (\exists int i;0 &lt;= i &amp;&amp; i &lt; personss.length;</span><br><span class="hljs-comment">@        groups[i].getId() == id2) &amp;&amp; (\exists int i; 0 &lt;= i &amp;&amp; i &lt;product.length;</span><br><span class="hljs-comment">@           people[i].getId() == id1) &amp;&amp; getPerson(id2).hasProduct(getPerson(id1));</span><br><span class="hljs-comment">@*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">promoteProduct</span><span class="hljs-params">(<span class="hljs-type">int</span> id1, <span class="hljs-type">int</span> id2, <span class="hljs-type">int</span> id3)</span> <span class="hljs-keyword">throws</span> PersonIdNotFoundException, ProductIdNotFoundException, EqualProductIdException;<br></code></pre></td></tr></table></figure><ul><li>发送广告<ul><li>id1为广告商id，id2为顾客id，id3为产品id</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*@ public normal_behavior </span><br><span class="hljs-comment">@ requires containsAdvertiser(id1) &amp;&amp; containsCustomer(id1) &amp;&amp; containsProduct(id3)</span><br><span class="hljs-comment">@ assignable messages;</span><br><span class="hljs-comment">@ ensures (\exist AdvertiserMessage i; i.getTyper() == 0 &amp;&amp; </span><br><span class="hljs-comment">@ i.getPerson1().getId() == id1 &amp;&amp; i.getPerson2().getId() == id2 &amp;&amp; </span><br><span class="hljs-comment">@ i.getProduct().getId() == id3) &amp;&amp; </span><br><span class="hljs-comment">@ containsMessage(i.getId()) &amp;&amp; </span><br><span class="hljs-comment">@ (\all AdvertiserMessage i; (\old)contains(i.getId()) ==&gt; contains(i.getId))</span><br><span class="hljs-comment">@ public exceptional_behavior</span><br><span class="hljs-comment">@ sinals (AdvertiserIdNotFound e) !containsAdvertiser(id1)</span><br><span class="hljs-comment">@ sinals (CustomerIdNotFound e) !containsCustomer(id1)</span><br><span class="hljs-comment">@ sinals (ProductIdNotFound e) !containsProduct(id3)</span><br><span class="hljs-comment">@*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addAdvertisement</span><span class="hljs-params">(<span class="hljs-type">int</span> id1, <span class="hljs-type">int</span> id2, <span class="hljs-type">int</span> id3)</span> <span class="hljs-keyword">throws</span> AdvertiserIdNotFound, CustomerIdNotFound, ProductIdNotFound;<br></code></pre></td></tr></table></figure><ul><li>购买产品：顾客给钱（允许欠钱），同时添加广告商发送给厂家的购买信息<ul><li>id1为顾客id，id2为产品id，id3为广告商id</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*@ public normal_behavior</span><br><span class="hljs-comment">@ requires containsPerson(id1) &amp;&amp; ContainsProduct(id2) &amp;&amp; containsAdvertiser(id3)</span><br><span class="hljs-comment">@ assignable messages getPerson(id1).money</span><br><span class="hljs-comment">@ ensures (\old(getPerson(id1).money) == getPerson(id1).money + getProduct(id2).value) &amp;&amp;</span><br><span class="hljs-comment">@ ensures (\exist PurchaseMessage i; i.getPerson1() == getAdvertiser(id3) &amp;&amp; i.getPerson2() == getProduct(id2).getProduce; containsMessage(i.getId()))</span><br><span class="hljs-comment">@ also</span><br><span class="hljs-comment">@ public exceptional_behavior</span><br><span class="hljs-comment">@ sinals (PersonIdNotFound e) !containsPerson(id1)</span><br><span class="hljs-comment">@ sinals (ProductIdNotFound e) !containsProduct(id2)</span><br><span class="hljs-comment">@ sinals (AdvertiserIdNotFound e) !contasinAdvertiser(id3)</span><br><span class="hljs-comment">@*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">purchase</span><span class="hljs-params">(<span class="hljs-type">int</span> id1, <span class="hljs-type">int</span> id2)</span> <span class="hljs-keyword">throws</span> PersonIdNotFound, ProductIdNotFound, AdvertiserIdNotFound;<br></code></pre></td></tr></table></figure><h2 id="学习心得"><a href="#学习心得" class="headerlink" title="学习心得"></a>学习心得</h2><p>​通过本单元的学习，了解了JML规格描述基础知识，并锻炼了将JML从阅读理解到实现的能力。在以前我写代码都有些“随心所欲”，认为只要实现功能就可以，不注重代码的规范性。但在本单元的学习与训练中，我逐渐领会到了规范性的优点与必要性。对于JML规格描述乃至其他的规范描述，我认为有几处优点：一是其最基础的作用，通过规范的描述，使得程序员在实现程序的过程中保证正确的理解，避免常规描述产生的理解二异性；二是任务明晰，降低了思考的难度，也减少了出错的可能。通过这个单元的锻炼，我写代码的风格更加规范明晰，注重架构设计，同时还努力去避免繁杂的冗余代码，深刻体会到了规范之于代码的重要性。</p><p>​除此之外，在这个单元，我有了更多的对拍经历，自己去尝试写一个简易的评测机，实现数据的生成与构造，也收获到许多。总体来说，这个单元的所学所写，都十分得有意义，对于我今后的代码生涯起到了很大的指导和启发作用，再次感谢老师和助教们精选的教学设计，令我受益匪浅。</p>]]></content>
    
    
    <categories>
      
      <category>面向对象单元总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSlab4实验报告</title>
    <link href="/20220602/OSlab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/20220602/OSlab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="lab4实验报告"><a href="#lab4实验报告" class="headerlink" title="lab4实验报告"></a>lab4实验报告</h1><h2 id="实验思考题"><a href="#实验思考题" class="headerlink" title="实验思考题"></a>实验思考题</h2><h4 id="Thinking-4-1"><a href="#Thinking-4-1" class="headerlink" title="Thinking 4.1"></a>Thinking 4.1</h4><blockquote><ul><li><em>内核在保存现场的时候是如何避免破坏通用寄存器的？</em></li><li><em>系统陷入内核调用后可以直接从当时的$a0-$a3参数寄存器中得到用户调用msyscall留下的信息吗？</em></li><li><em>我们是怎么做到让sys开头的函数“认为”我们提供了和用户调用msyscall时同样的参数的？</em></li><li><em>内核处理系统调用的过程对Trapframe做了哪些更改？这种修改对应的用户态的变化是？</em></li></ul></blockquote><ul><li>在保存现场时，首先调用了<code>SAVE_ALL</code>宏，将通用寄存器的内容存入栈中；在退出异常时，<code>ret_from_exception</code>中使用了<code>RESTORE_SOME</code>宏将栈中存的内容<strong>重新存入通用寄存器中</strong>。</li><li>可以。在陷入内核态前，系统经历了调用<code>msyscall</code>后，经过异常分发进入了<code>handle_sys</code>函数，期间并<strong>未</strong>对$a0~$a3寄存器进行过修改，可以直接使用用户调用msyscall时在其中留下的信息。</li><li>观察<code>SAVE_ALL</code>我们发现在$29存了用户栈的地址，凭此我们可以取出相应的参数，在将它们<strong>存入内核栈中</strong>，从而让sys_*获取到对应的参数</li><li>在最开始给EPC设置了合适的值；在最后通过<code>sw v0, TF_REG2(sp)</code>将函数的返回值从内核态的$v0中存入了用户态$v0 暂时存储的地方，即完成了函数<strong>返回值的传递</strong>。</li></ul><h4 id="Thinking-4-2"><a href="#Thinking-4-2" class="headerlink" title="Thinking 4.2"></a>Thinking 4.2</h4><blockquote><p><em>请回顾 lib&#x2F;env.c 文件中 <code>mkenvid()</code> 函数的实现，该函数不会返回 0，请结合系统调用和 IPC 部分的实现 与 <code>envid2env()</code> 函数的行为进行解释。</em></p></blockquote><ul><li>在操作系统中，常常把某个参数置为0当作某种特殊的情况，例如在<code>sys_ipc_can_send</code>函数中就把srcva设为0定为只穿value值的一种特殊情况。而观察<code>envid2env</code>函数我们发现当envid为0时会返回当前的<code>curenv</code>，从而可以方便地获取当前的环境进程，因此mkenvid函数不会返回0，即不会生成为0的envid以免和前面所述的获取环境进程情况产生<strong>冲突</strong>。</li></ul><h4 id="Thinking-4-3"><a href="#Thinking-4-3" class="headerlink" title="Thinking 4.3"></a>Thinking 4.3</h4><blockquote><ul><li><em>子进程完全按照 fork() 之后父进程的代码执行，说明了什么？</em></li><li><em>但是子进程却没有执行 fork() 之前父进程的代码，又说明了什么？</em></li></ul></blockquote><ul><li>说明子进程与父进程掌握着相同的程序进行执行，同时说明可以在出现不同前暂时共享相同的页面。</li><li>说明子进程是在fork之后才诞生与父进程“分道扬镳”，在fork之前就只有父进程本身。</li></ul><h4 id="Thinking-4-4"><a href="#Thinking-4-4" class="headerlink" title="Thinking 4.4"></a>Thinking 4.4</h4><blockquote><p><em>关于 fork 函数的两个返回值，下面说法正确的是</em></p></blockquote><p>​C、<em>fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值</em>是正确的。</p><p>子进程是在父进程中，fork调用到结束的过程中才被产生，但父、子进程均会在结束fork时各返回一个值。</p><h4 id="Thinking-4-5"><a href="#Thinking-4-5" class="headerlink" title="Thinking 4.5"></a>Thinking 4.5</h4><blockquote><p><em>我们并不应该对所有的用户空间页都使用<code>duppage</code>进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？ 请结合本章的后续描述、mm&#x2F;pmap.c 中 <code>mips_vm_init</code> 函数进行的页面映射以及 include&#x2F;mmu.h 里的内存布局图进行思考。</em></p></blockquote><ul><li>在考虑对空间页保护时，我们应针对那些用户即进程间所使用到的空间页。因此需要保护的是<code>UTEXT</code>到<code>USTACKTOP</code>之间的页面。</li><li>除此之外，对于上述空间页，我们还要考虑其类型，对于只读、写时复制、共享页面都无需进行保护。</li></ul><h4 id="Thinking-4-6"><a href="#Thinking-4-6" class="headerlink" title="Thinking 4.6"></a>Thinking 4.6</h4><blockquote><ul><li><em>vpt和vpd的作用是什么？怎样使用它们？</em></li><li><em>从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</em></li><li><em>它们是如何体现自映射设计的？</em></li><li><em>进程能够通过这种方式来修改自己的页表项吗？</em></li></ul></blockquote><ul><li>vpt和vpd使得用户可以在用户态中访问到页表项，利用形如<code>((Pte *)(*vpt))[VPN(va)] ((Pde *)(*vpd))[PDX(va)]</code>即可访问相关的页目录项或页表项</li><li>每个进程有自己的一套虚拟内存，同时在实验的系统架构中采用了<strong>自映射设计</strong>，使得可以通过，因此使得可以直接通过vpt、vpd和va三者直接找到对应的页目录项或页表项。</li><li><code>vpd</code>的定义为<code>.word (UVPT+(UVPT&gt;&gt;12)*4)</code>实现了自映射的设计</li><li>不能，用户态是没有修改页表项的权限的，只是能凭借vpt和vpd进行读取罢了</li></ul><h4 id="Thinking-4-7"><a href="#Thinking-4-7" class="headerlink" title="Thinking 4.7"></a>Thinking 4.7</h4><blockquote><ul><li><em>这里实现了一个支持类似于“中断重入”的机制，而在什么时候会出现这种“中断重入”？</em></li><li><em>内核为什么需要将异常的现场Trapframe复制到用户空间？</em></li></ul></blockquote><ul><li><p>​这里的“中断重入”是为了应对触发页写入异常的处理过程中又触发了另一个页写入异常的情况，但从目前实现的系统来看，这种情况不会出现。</p><p>​但是从系统可拓展性的角度来看，观察可以发现异常处理函数是可以由用户自定义的，如若我们的自定义的处理函数中可能会再次触发页写入异常，那么此处“中断重入”的实现便显得尤为重要</p></li><li><p>页写入异常的处理一大特点就是在<strong>用户态</strong>下完成最后的异常处理，因此需要将异常现场复制到用户空间用于用户态下读取。</p></li></ul><h4 id="Thinking-4-8"><a href="#Thinking-4-8" class="headerlink" title="Thinking 4.8"></a>Thinking 4.8</h4><blockquote><ul><li><em>在用户态处理页写入异常，相比于在内核态处理有什么优势？</em></li><li><em>从通用寄存器的用途角度讨论，在可能被中断的用户态下进行现场的恢复，要如何做到不破坏现场中的通用寄存器？</em></li></ul></blockquote><ul><li>用户态处理页写入异常的优势<ul><li>将主要部分交给用户态，即减少了内核的工作量，也使得异常的处理更加灵活，一定程度上提升了操作系统的可靠性与灵活性。</li><li>体现了微内核的思想，减少了不同功能间的相互干扰，使得各功能可以更好更可靠的实现。</li></ul></li><li>在触发页写入异常到完成异常处理之间，我们将栈指针指向了专门的异常处理栈；同时，在遇到中断时，对寄存器进行了压栈存储的保护，恢复后从栈中弹出并恢复相应寄存器，从而保证了现场中的通用寄存器不被破坏。</li></ul><h4 id="Thinking-4-9"><a href="#Thinking-4-9" class="headerlink" title="Thinking 4.9"></a>Thinking 4.9</h4><blockquote><ul><li><em>为什么需要将<code>set_pgfault_handler</code>的调用放置在<code>syscall_env_alloc</code>之前？</em></li><li><em>如果放置在写时复制保护机制完成之后会有怎样的效果？</em></li><li><em>子进程是否需要对在entry.S定义的字__pgfault_handler赋值？</em></li></ul></blockquote><ul><li>在最开始设置好页写入异常，可以避免在创建进程后还需要分别对父子进程进行设置。</li><li>若放置在写时保护机制完成之后，则可能导致存放<code>__pgfault_handler</code>的页面也受到COW的保护，而后在修改<code>__pgfault_handler</code>的时候触发页写入异常，最终无限陷入其中，系统崩溃。</li><li>不需要，因为<code>__pgfault_handler</code>设置在创建进程之前，因此父子进程都共享了该值，无须再设置。</li></ul><h2 id="实验难点图示"><a href="#实验难点图示" class="headerlink" title="实验难点图示"></a>实验难点图示</h2><h4 id="①系统调用流程"><a href="#①系统调用流程" class="headerlink" title="①系统调用流程"></a>①系统调用流程</h4><p><img src="/20220602/OSlab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220602185916873.png" alt="image-20220602185916873"></p><h4 id="②页写入异常处理机制"><a href="#②页写入异常处理机制" class="headerlink" title="②页写入异常处理机制"></a>②页写入异常处理机制</h4><p><img src="/20220602/OSlab4%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/4_fork_process.png" alt="fork 流程图"></p><p><em>（注：图片来源于BUAA_OS指导书</em></p><p>页写入异常分为<strong>注册</strong>和<strong>异常处理</strong>两部分</p><ul><li><p>fork新建进程时，先是用<code>set_pgfault_handler</code>为父进程注册，后还为子进程调用<code>syscall_set_pgfault_handler</code>进行注册</p><ul><li><code>set_pgfault_handler</code>函数<ul><li>为异常栈分配物理页面</li><li>并调用<code>syscall_set_pgfault_handler</code></li><li>最后将**全局变量<code>__pgfault_handler</code>**设置为<code>pgfault</code>的入口，会在<code>__asm_pgfault_handler</code>被用于具体处理</li></ul></li><li><code>syscall_set_pgfault_handler</code>函数<ul><li>将给进程后文用到的<code>env_pgfault_handler</code>设置为<strong>处理函数<code>__asm_pgfault_handler</code>的入口</strong></li><li>设置<code>env_xstacktop</code>设置相应的异常栈地址</li></ul></li></ul></li><li><p>写COW页面触发页写入异常 </p><ul><li>（内核态）调用处理函数handle_mod </li><li>跳转到page_fault_handler函数<ul><li>将异常现场压入异常栈</li><li>设置epc值为<code>env_pgfault_handler</code>（进程块中记录<strong>处理函数入口</strong>的变量），使得回到用户态后跳转掉相应异常处理函数</li></ul></li><li>（用户态）退出异常后，根据前面设置好的PC值跳转到处理的<strong>核心函数<code>__asm_pgfault_handler</code></strong><ul><li>获取发生异常的地址</li><li>跳转到<code>__pgfault_handler</code>设置好的函数，即pgfault函数，完成相应页面拷贝、映射等操作</li><li>至此异常已解决，后续完成一系列的现场恢复即可<strong>完成整个页写入异常的处理</strong>了</li></ul></li></ul></li></ul><h2 id="体会与感想"><a href="#体会与感想" class="headerlink" title="体会与感想"></a>体会与感想</h2><p>​相比于lab3的“顺风顺水”，lab4的难度有所提升，但也更显巧妙，让我对操作系统的理解又深入一分。总得来说，lab4的学习给人一种“山重水复疑无路，柳暗花明又一村”的感觉，只有沉下心慢慢去琢磨，才能体会其中的巧妙。像在ipc部分的学习中，我花费了许多时间弄明白了两进程之间的交互关系，使得我在上机时能很快就领会了题意，并最终成功完成，可以说，课下的理解与熟悉，是上机做题十分重要的前置条件。</p><p>​除此之外，我认为4-2的页写入异常机制是十分有意义的一个内容，通过对异常处理函数初始化和后续异常处理机制的实现，极大加深了对内核态和用户态间相互作用的理解，同时也了解了将处理函数传入这一种灵活的编码方式。可惜就是这部分内容有点绕没能理解透彻，加之上机任务量过大，最后没能做出来。总而言之，lab4的难度确实是有的，但也让我实打实有了许多不一样的收获，这也便足矣。在之后的学习里面，仍旧是要抓住对实验内容的理解不断深入这一要点，争取做出更多的Extra。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统实验报告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSlab4笔记</title>
    <link href="/20220525/OSlab4%E7%AC%94%E8%AE%B0/"/>
    <url>/20220525/OSlab4%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="lab4笔记"><a href="#lab4笔记" class="headerlink" title="lab4笔记"></a>lab4笔记</h1><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><ul><li>用户态和内核态由<code>CPU0 SR</code>寄存器中KUc位的值标志</li><li>用户空间和内核空间：指虚拟内存中的区域划分，MOS中用户空间位<code>kuseg</code>，而内核空间包括<code>kseg0和</code>kseg1&#96;<ul><li>虚拟地址处于 0x80000000~0x9fffffff (kseg0)，则将虚拟地址的最高位置 0得到物理地址，通过 cache 访存。这一部分用于存放内核代码与数据结构。</li><li>虚拟地址处于 0xa0000000~0xbfffffff (kseg1)，则将虚拟地址的最高 3 位置0 得到物理地址，不通过 cache 访存。这一部分用于映射外设。</li><li>虚拟地址处于 0x00000000~0x7fffffff (kuseg)，则需要通过 TLB 来获取物理地址，通过 cache 访存。</li></ul></li><li>进程与内核：<strong>进程是资源分配与调度的基本单位</strong>，拥有独立的地址空间，而<strong>内核负责管理系统资源和调度进程</strong>，使进程能够<strong>并发</strong>运行。 与前两对概念不同，进程和内核并不是对立的存在，可以认为<strong>内核是存在于所有进程地址空间中的一段代码</strong>。</li></ul><h5 id="lab4关键点"><a href="#lab4关键点" class="headerlink" title="lab4关键点"></a>lab4关键点</h5><p>​实现用户态与内核态的区分，需实现程序严格在用户态下执行和<strong>系统调用</strong>，不可以直接读写内核空间地址。</p><h4 id="内核调度进程"><a href="#内核调度进程" class="headerlink" title="内核调度进程"></a>内核调度进程</h4><ul><li>恢复进程上下文 + 使用rfe指令进入用户态</li></ul><h5 id="Ex4-0-用户态设置"><a href="#Ex4-0-用户态设置" class="headerlink" title="Ex4.0 用户态设置"></a>Ex4.0 用户态设置</h5><p>​给新创建的进程控制块，将<code>env_tf.cp0_status</code>的值设置为0x1000100c，即设置进程初始为用户态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">e-&gt;env_tf.cp0_status = <span class="hljs-number">0x1000100c</span>;<br></code></pre></td></tr></table></figure><h3 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h3><h4 id="puts函数执行过程"><a href="#puts函数执行过程" class="headerlink" title="puts函数执行过程"></a>puts函数执行过程</h4><p>​调用<code>puts</code>函数完成部分准备 –&gt; 调用<code>write</code>函数为寄存器设置相应值 –&gt; 调用<code>syscall</code>进入内核态 –&gt; 执行内核态函数<code>syscall_putchar</code>完成相关服务 –&gt; 回到用户态的<code>write</code>函数从相关寄存器取回结果 –&gt; 最后在那个返回<code>puts</code>函数结束调用</p><p>​注意：通过系统调用陷入到内核态时，需要在用户态与内核态之间进行<strong>数据传递与保护</strong></p><h4 id="系统调用的定义与作用"><a href="#系统调用的定义与作用" class="headerlink" title="系统调用的定义与作用"></a>系统调用的定义与作用</h4><p>​内核将自己所能提供的服务<strong>以系统调用的方式</strong>提供给用户空间，以供用户完成一些特殊的<strong>系统级操作</strong>。用户只能将服务相关的参数交给操作系统，然后陷入内核态，交由内核实现服务，如此<strong>保证了系统的安全性</strong>。</p><p>​同时，由于直接使用系统调用比较麻烦，一般有一系列用户空间的<strong>API定义</strong>，提升用户调用的层次。对于用户来说，只需考虑API的接口，而无需接触底层的实际调用方式，这使得程序更加灵活，具有更好的可移植性。</p><h4 id="系统调用的具体实现"><a href="#系统调用的具体实现" class="headerlink" title="系统调用的具体实现"></a>系统调用的具体实现</h4><h5 id="系统调用的流程"><a href="#系统调用的流程" class="headerlink" title="系统调用的流程"></a>系统调用的流程</h5><ul><li>用户态调用**<code>syscall_*</code>函数**<ul><li><code>syscall_*</code>的函数是我们在用户空间中最接近的内核的也是最原子的函数</li></ul></li><li><code>syscall_*</code>中调用**<code>msyscall函数</code><strong>并传递对应</strong>系统调用号<code>SYS_*</code>**</li><li>执行<code>syscall</code>操作，使系统进入内核态，同时发出异常</li><li>经过异常分发（8号异常）进入<code>handle_sys</code>函数，传递参数并跳转到对应的内核实现函数<code>sys_*</code></li><li>最终在函数<code>sys_*</code>中完成具体实现部分</li></ul><h5 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h5><blockquote><p>​进入函数体时会通过对栈指针做减法（压栈）的方式为该函数自身的<strong>局部变量、返回地址、调用函数的参数</strong>分配存储空间（叶函数没有后两者），在函数调用结束之后会对栈指针做加法（弹栈）来释放这部分空间，我们把这部分空间称为<strong>栈帧（Stack Frame）</strong></p><p>​进一步，MIPS寄存器使用规范中指出，寄存器$a0-$a3用于存放函数调用的前四个参数（但在栈中仍然需要为其预留空间），剩余的参数仅存放在栈中。</p></blockquote><p>​就系统调用的函数而言，一共有6个参数，前四个参数会被<code>syscall_*</code>的函数分别存入<code>$a0-$a3</code>寄存器（寄存器传参的部分）同时栈帧底部保留16字节的空间（不要求存入参数的值）， 后2个参数只会被存入在预留空间之上的8字节空间内（没有寄存器传参），于是总共24字节的空间用于参数传递。（见下图）</p><p><img src="/20220525/OSlab4%E7%AC%94%E8%AE%B0/4-register-params.png" alt="寄存器传参示意图"></p><h5 id="Ex4-1-msyscall函数"><a href="#Ex4-1-msyscall函数" class="headerlink" title="Ex4.1 msyscall函数"></a>Ex4.1 msyscall函数</h5><p>​参数的转递已在<code>syscall_*</code>函数中被完成，<code>msyscall</code>函数实际上只需要完成调用<code>syscall</code>指令使系统陷入内核态即可</p><p>​Ps.不将 syscall 指令置于跳转指令的延迟槽中可以简化内核中的后续处理（什么意思？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">LEAF(msyscall)<br>    // TODO: you JUST need to execute a `syscall` instruction and return from msyscall<br>        syscall<br>        jr ra<br>        nop<br>END(msyscall)<br></code></pre></td></tr></table></figure><h5 id="系统调用号排布"><a href="#系统调用号排布" class="headerlink" title="系统调用号排布"></a>系统调用号排布</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> UNISTD_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> UNISTD_H</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __SYSCALL_BASE 9527</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __NR_SYSCALLS 20</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_putchar             ((__SYSCALL_BASE ) + (0 ) ) </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_getenvid            ((__SYSCALL_BASE ) + (1 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_yield               ((__SYSCALL_BASE ) + (2 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_env_destroy         ((__SYSCALL_BASE ) + (3 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_set_pgfault_handler ((__SYSCALL_BASE ) + (4 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_mem_alloc           ((__SYSCALL_BASE ) + (5 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_mem_map             ((__SYSCALL_BASE ) + (6 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_mem_unmap           ((__SYSCALL_BASE ) + (7 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_env_alloc           ((__SYSCALL_BASE ) + (8 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_set_env_status      ((__SYSCALL_BASE ) + (9 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_set_trapframe       ((__SYSCALL_BASE ) + (10 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_panic               ((__SYSCALL_BASE ) + (11 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_ipc_can_send        ((__SYSCALL_BASE ) + (12 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_ipc_recv            ((__SYSCALL_BASE ) + (13 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_cgetc               ((__SYSCALL_BASE ) + (14 ) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h5 id="Ex4-2-handle-sys函数"><a href="#Ex4-2-handle-sys函数" class="headerlink" title="Ex4.2 handle_sys函数"></a>Ex4.2 handle_sys函数</h5><p>​该函数主要实现了相关的参数存储传递，并识别系统调用号完成具体内核功能函数的跳转，最终返回参数并退出异常</p><blockquote><p>​陷入内核态的操作并不是从一个函数跳转到了另一个函数，此处的<strong>栈指针$sp是内核空间的栈指针</strong>，系统从用户态切换到内核态后，<strong>内核首先需要将原用户进程的运行现场保存到内核空间</strong>（其保存的结构与结构体<code>struct Trapframe</code>等同），栈指针指向这个结构体的起始位置， 因此我们正是借助这个保存的结构体来<strong>获取用户态中传递过来的值</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs assembly">NESTED(handle_sys,TF_SIZE, sp)<br>    SAVE_ALL                            // Macro used to save trapframe<br>    CLI                                 // Clean Interrupt Mask<br>    nop<br>    .set at                             // Resume use of $at<br><br>    // TODO: Fetch EPC from Trapframe, calculate a proper value and store it back to trapframe.<br>        lw      t0, TF_EPC(sp)<br>        lw      t1, TF_CAUSE(sp)<br>        lui     t2, 0x8000<br>        and     t1, t1, t2<br>        bnez    t1, BD#判断是不是延迟槽的指令，如果不是则EPC + 4，是则无需 +4<br>        nop<br>        addiu   t0, t0, 4<br>        j BD_END<br>        nop<br>BD:<br>BD_END:<br>        sw      t0, TF_EPC(sp)<br>    // TODO: Copy the syscall number into $a0.<br>        lw      a0, TF_REG4(sp)#取得$a0寄存器的内容，即系统调用号，用于区分需实现的功能<br>    addiu   a0, a0, -__SYSCALL_BASE     // a0 &lt;- relative syscall number<br>    sll     t0, a0, 2                   // t0 &lt;- relative syscall number times 4<br>    la      t1, sys_call_table          // t1 &lt;- syscall table base<br>    addu    t1, t1, t0                  // t1 &lt;- table entry of specific syscall<br>    lw      t2, 0(t1)                   // t2 &lt;- function entry of specific syscall<br><br>    lw      t0, TF_REG29(sp)            // t0 &lt;- user&#x27;s stack pointer<br>    lw      t3, 16(t0)                  // t3 &lt;- the 5th argument of msyscall<br>    lw      t4, 20(t0)                  // t4 &lt;- the 6th argument of msyscall<br><br>    // TODO: Allocate a space of six arguments on current kernel stack and copy the six arguments to proper location<br>        lw      a0, TF_REG4(sp)#按照栈帧的存储要求，前四个参数存入寄存器<br>        lw      a1, TF_REG5(sp)<br>        lw      a2, TF_REG6(sp)<br>        lw      a3, TF_REG7(sp)<br>        addiu   sp, sp, -24<br>        sw      t3, 16(sp)#后两个参数存入栈中，但预留的是6个参数的栈空间<br>        sw      t4, 20(sp)<br>    jalr    t2                          // Invoke sys_* function<br>    nop<br><br>    // TODO: Resume current kernel stack<br>        addiu   sp, sp, 24<br>    sw      v0, TF_REG2(sp)             // Store return value of function sys_* (in $v0) into trapframe<br>#即将sys_*函数的返回值存入寄存器中返回<br>    j       ret_from_exception          // Return from exeception #调用该函数实现恢复现场并退出异常状态<br>    nop<br>END(handle_sys)<br></code></pre></td></tr></table></figure><h4 id="系统调用的基础函数"><a href="#系统调用的基础函数" class="headerlink" title="系统调用的基础函数"></a>系统调用的基础函数</h4><h5 id="Ex4-3-sys-mem-alloc函数"><a href="#Ex4-3-sys-mem-alloc函数" class="headerlink" title="Ex4.3 sys_mem_alloc函数"></a>Ex4.3 sys_mem_alloc函数</h5><p>​顾名思义，该函数的作用就是分配内存，用户可通过通过该系统调用在允许范围内为虚拟内存分配物理内存</p><p>​因为该函数已处在内核态中，因此具体的实现其实就是page的申请与链接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_mem_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, u_int envid, u_int va, u_int perm)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">ppage</span>;</span><br>        <span class="hljs-type">int</span> ret;<br>        ret = <span class="hljs-number">0</span>; <br>        <span class="hljs-keyword">if</span> (va &lt; <span class="hljs-number">0</span> || va &gt;= UTOP) &#123;<span class="hljs-comment">//检验虚拟地址是否合法，要求是用户态可访问的地址，即[0,UTOP]</span><br>                <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (((perm &amp; PTE_V) == <span class="hljs-number">0</span>) || (perm &amp; PTE_COW)) &#123; <span class="hljs-comment">//根据要求perm需要有PTE_V但不能有PTE_COW</span><br>                <span class="hljs-keyword">return</span> -E_INVAL; <span class="hljs-comment">//PTE_COW是用于后面创建子进程时用到的标志位，不应该直接在申请内存中设置</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = envid2env(envid, &amp;env, <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//获取对应进程块</span><br>                <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = page_alloc(&amp;ppage)) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//申请一个页面</span><br>                <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = page_insert(env-&gt;env_pgdir, ppage, va, perm)) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//完成页面与该进程虚拟地址的链接</span><br>                <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Ex4-4-sys-mem-map函数"><a href="#Ex4-4-sys-mem-map函数" class="headerlink" title="Ex4.4 sys_mem_map函数"></a>Ex4.4 sys_mem_map函数</h5><blockquote><p>​将源进程地址空间中的相应内存映射到目标进程的相应 地址空间的相应虚拟内存中去。换句话说，此时两者共享一页物理内存。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_mem_map</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, u_int srcid, u_int srcva, u_int dstid, u_int dstva,</span><br><span class="hljs-params">                                u_int perm)</span><br>&#123;<br>        <span class="hljs-type">int</span> ret;<br>        u_int round_srcva, round_dstva;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">srcenv</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">dstenv</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">ppage</span>;</span><br>        Pte *ppte;<br>        ppage = <span class="hljs-literal">NULL</span>;<br>        ret = <span class="hljs-number">0</span>;<br>        round_srcva = ROUNDDOWN(srcva, BY2PG);<br>        round_dstva = ROUNDDOWN(dstva, BY2PG);<br>        <span class="hljs-keyword">if</span> (srcva &lt; <span class="hljs-number">0</span> || srcva &gt;= UTOP || dstva &lt; <span class="hljs-number">0</span> || dstva &gt;= UTOP) &#123; <span class="hljs-comment">//检查虚拟地址是否合法[0,UTOP]</span><br>                <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((perm &amp; PTE_V) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//要求权限为PTE_V</span><br>                <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = envid2env(srcid, &amp;srcenv, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//找到src进程</span><br>                <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = envid2env(dstid, &amp;dstenv, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//找到dst进程</span><br>                <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ppage = page_lookup(srcenv-&gt;env_pgdir, round_srcva, &amp;ppte)) == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">//通过src进程找到所需要连接的页面</span><br>                <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (((*ppte &amp; PTE_R) == <span class="hljs-number">0</span>) &amp;&amp; ((perm &amp; PTE_R) != <span class="hljs-number">0</span>)) &#123; <span class="hljs-comment">//这里需要考虑perm与页面的可写性</span><br>                <span class="hljs-keyword">return</span> -E_INVAL;  <span class="hljs-comment">//若该页面不可写但perm要求可写则显然需要报错</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = page_insert(dstenv-&gt;env_pgdir, ppage, round_dstva, perm)) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> ret; <span class="hljs-comment">//将dst对应的虚拟地址，连接到src对应的页面上，实现共享同一物理页面</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Ex4-5-sys-mem-unmap函数"><a href="#Ex4-5-sys-mem-unmap函数" class="headerlink" title="Ex4.5 sys_mem_unmap函数"></a>Ex4.5 sys_mem_unmap函数</h5><p>​同样顾名思义，就是解除某虚拟地址和物理地址的映射关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_mem_unmap</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, u_int envid, u_int va)</span><br>&#123;<br>        <span class="hljs-type">int</span> ret;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span> <br>        <span class="hljs-keyword">if</span> (va &lt; <span class="hljs-number">0</span> || va &gt;= UTOP) &#123;  <span class="hljs-comment">//检查虚拟地址是否合法[0,UTOP]</span><br>                <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = envid2env(envid, &amp;env, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//获取对应进程块</span><br>                <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        page_remove(env-&gt;env_pgdir, va);  <span class="hljs-comment">//解除映射</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Ex4-6-sys-yield函数"><a href="#Ex4-6-sys-yield函数" class="headerlink" title="Ex4.6 sys_yield函数"></a>Ex4.6 sys_yield函数</h5><p>​这是一个进程调度函数，实现用户进程对CPU的放弃，从而调度其他进程。具体实现过程就是保存现场，然后调用我们之前写好的<code>sched_yield</code>函数。</p><p>​值得注意的是，我们根据指导书要求写的<code>sched_yield</code>函数，仅调度一次有可能并不足以使CPU放弃当前进程，但在询问助教后我们得到了只需调用一次<code>sched_yield</code>函数的回复，因此便乖乖实现了。</p><ul><li>时钟中断时保存在<code>TIMESTACK</code>；但由于系统调用时保存在<code>KERNEL_SP</code>，且env_run时默认保存在<code>TIMESTACK</code>，因此我们首先需要将<code>KERNEL_SP</code>中的上下文复制到<code>TIMESTACK</code>中去</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sys_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> *<span class="hljs-title">old</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> *<span class="hljs-title">new</span>;</span><br>        old = (<span class="hljs-keyword">struct</span> Trapframe *)(KERNEL_SP - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe));<br>        new = (<span class="hljs-keyword">struct</span> Trapframe *)(TIMESTACK - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe));<br>        bcopy((<span class="hljs-type">void</span>*) old, (<span class="hljs-type">void</span>*) new, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe)); <span class="hljs-comment">//</span><br>        sched_yield();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进程与内核的关系"><a href="#进程与内核的关系" class="headerlink" title="进程与内核的关系"></a>进程与内核的关系</h4><blockquote><p>​进程与内核间的关系并非对立</p></blockquote><p>​在内核处理进程发起的系统调用时，我们并没有切换 CPU 的地址空间（页目录地址），也不需要将进程上下文（<code>Trapframe</code>）保存到进程控制块中，只是切换到内核态下， 执行了一些内核代码，这些操作始终没有与当前进程脱离，因此<strong>系统调用中断与时钟中断有着本质区别</strong>，这也是分别有<code>KERNEL_SP</code> 和 <code>TIMESTACK</code> 两种机制来保存进程上下文的一个原因。</p><h3 id="系统调用处理具体流程"><a href="#系统调用处理具体流程" class="headerlink" title="系统调用处理具体流程"></a>系统调用处理具体流程</h3><ul><li>用户态调用了<code>msyscall</code></li><li>调用了<code>syscall</code>指令出发了系统异常</li><li>进入到<code>except_vec3</code>进行了异常分发进入<code>handle_sys</code></li><li>在<code>handle_sys</code>中使用了<code>SAVE_ALL</code>宏保存寄存器，还使用了<code>get_sp</code>获取应使用的临时栈</li><li>然后进入具体的异常处理程序之中进行处理</li><li>最后在<code>ret_from_exception</code>中还原上下文，调用<code>rfe</code>退出异常</li></ul><h2 id="进程间通信机制（IPC）"><a href="#进程间通信机制（IPC）" class="headerlink" title="进程间通信机制（IPC）"></a>进程间通信机制（IPC）</h2><blockquote><p>进程间通信机制(IPC)是微内核最重要的机制之一。</p></blockquote><h3 id="什么是通信？"><a href="#什么是通信？" class="headerlink" title="什么是通信？"></a>什么是通信？</h3><ul><li><p>通信机制，即IPC，使得系统中的进程之间拥有了相互传递消息的能力，简而言之就是<strong>交换数据</strong></p></li><li><p>IPC需要通过系统调用来实现，同时与进程的数据、页面等信息有关</p></li></ul><h3 id="通信的实现"><a href="#通信的实现" class="headerlink" title="通信的实现"></a>通信的实现</h3><h4 id="实现基础"><a href="#实现基础" class="headerlink" title="实现基础"></a>实现基础</h4><p>​交换数据面临的最大问题是<strong>各进程间拥有独立的地址空间</strong>。</p><p>​阅读<code>env_setup_vm</code>我们发现，每个进程实际上共享了[UTOP,4G]这总共2G的内核空间，对于任意进程，这2G都是一样的，因此我们可以借助内核的空间，实现数据的共享。进一步讲，通过系统调用我们便可完成数据的存放与读取，实现通信。</p><h4 id="进程块中的IPC成员"><a href="#进程块中的IPC成员" class="headerlink" title="进程块中的IPC成员"></a>进程块中的IPC成员</h4><table><thead><tr><th align="center">env_ipc_value</th><th>进程传递的具体数值</th></tr></thead><tbody><tr><td align="center">env_ipc_from</td><td>发送方的进程ID</td></tr><tr><td align="center">env_ipc_recving</td><td>1：等待接受数据中；0：不可接受数据</td></tr><tr><td align="center">env_ipc_dstva</td><td>接收到的页面需要与自身的哪个虚拟页面完成映射</td></tr><tr><td align="center">env_ipc_perm</td><td>传递的页面的权限位设置</td></tr></tbody></table><h4 id="通信的发送与接受"><a href="#通信的发送与接受" class="headerlink" title="通信的发送与接受"></a>通信的发送与接受</h4><p>​前文提到，我们通过系统调用来实现数据的存放与读取，这是两步是分别由两个进程来完成，我们通过<code>recv</code>和<code>send</code>两个函数来实现。</p><p>具体流程图如下：</p><p><img src="/20220525/OSlab4%E7%AC%94%E8%AE%B0/4-ipc.png" alt="IPC流程图"></p><h5 id="Ex4-7-①sys-ipc-recv函数"><a href="#Ex4-7-①sys-ipc-recv函数" class="headerlink" title="Ex4.7 ①sys_ipc_recv函数"></a>Ex4.7 ①sys_ipc_recv函数</h5><p>​该函数用于接收消息，注意是要先调用该函数表明等待接受发起通信。</p><p>具体流程如下：</p><ul><li>将自身的<code>env_ipc_recving</code>设置为1，表明该进程准备接受发送方的消息</li><li>给<code>env_ipc_dstva</code>赋值，表明自己要将接受到的页面与<code>dstva</code>完成映射</li><li>阻塞当前进程，即把当前进程的状态置为不可运行</li><li>最后放弃CPU（调用相关函数重新进行调度），安心等待发送方将数据发送过来<ul><li>注意：因为我们前面将该进程<strong>阻塞</strong>了，因此在调度过程中，即使当前进程时间片未用完也会被切换掉</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sys_ipc_recv</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, u_int dstva)</span><br>&#123;<br>        <span class="hljs-keyword">if</span> (dstva &lt; <span class="hljs-number">0</span> || dstva &gt;= UTOP) &#123; <span class="hljs-comment">//判断地址是否合法</span><br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        curenv-&gt;env_ipc_recving = <span class="hljs-number">1</span>;  <span class="hljs-comment">//表明等待接收数据</span><br>        curenv-&gt;env_ipc_dstva = dstva; <span class="hljs-comment">//记录接受到的数据应该存在哪里</span><br>        curenv-&gt;env_status = ENV_NOT_RUNNABLE; <span class="hljs-comment">//阻塞该进程</span><br>        sys_yield(); <span class="hljs-comment">//切换进程</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Ex4-7-②sys-ipc-can-send函数"><a href="#Ex4-7-②sys-ipc-can-send函数" class="headerlink" title="Ex4.7 ②sys_ipc_can_send函数"></a>Ex4.7 ②sys_ipc_can_send函数</h5><p>​该函数用于发送消息，用于另一进程对请求通信的进程完成响应。</p><p>具体流程如下：</p><ul><li>根据envid找到相应进程，如果指定进程为可接收状态(env_ipc_recving)，则发送成功；否则，函数返回<code>-E_IPC_NOT_RECV</code>，表示目标进程未处于接受状态</li><li>清除接收进程的接收状态，将相应数据填入进程控制块，传递物理页面的映射关系<ul><li><strong>注意</strong>：我们规定，使用<strong>srcva为0</strong>的调用来表示只传value值，而<strong>不需要</strong>传递物理页面</li></ul></li><li>修改进程控制块中的进程状态，使接受数据的进程可继续运行</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_ipc_can_send</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, u_int envid, u_int value, u_int srcva,</span><br><span class="hljs-params">                                         u_int perm)</span><br>&#123;<br>        <span class="hljs-type">int</span> r;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span>;</span><br>        <span class="hljs-keyword">if</span> (srcva &lt; <span class="hljs-number">0</span> || srcva &gt;= UTOP) &#123;<br>                <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((r = envid2env(envid, &amp;e, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e-&gt;env_ipc_recving == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//判断是否发送正确</span><br>                <span class="hljs-keyword">return</span> -E_IPC_NOT_RECV;<br>        &#125;<br>        e-&gt;env_ipc_recving = <span class="hljs-number">0</span>; <span class="hljs-comment">//表明完成通信了</span><br>        e-&gt;env_ipc_from = curenv-&gt;env_id; <span class="hljs-comment">//给接收者记录通信的发送者</span><br>        e-&gt;env_ipc_value = value; <span class="hljs-comment">//记录传递的value</span><br>        e-&gt;env_status = ENV_RUNNABLE; <span class="hljs-comment">//取消接受进程的阻塞</span><br>        <span class="hljs-keyword">if</span> (srcva != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//若srcva不为零，建立页面映射，完成数据传递</span><br>                Pte *pte;<br>                e-&gt;env_ipc_perm = perm;<br>                <span class="hljs-keyword">if</span> ((p = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pte)) &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> -E_INVAL; <span class="hljs-comment">//找到数据所在的页面</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((r = page_insert(e-&gt;env_pgdir, p, e-&gt;env_ipc_dstva, perm)) &lt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> r; <span class="hljs-comment">//将数据所在页面映射到接受页面，实现数据的传递</span><br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="FORK"><a href="#FORK" class="headerlink" title="FORK"></a>FORK</h2><p>​fork函数的作用是创建子进程，并且子进程开始运行时的大部分上下文状态与原进程相同，包括程序镜像、通用寄存器和程序计数器 PC 等。</p><ul><li>注意：fork函数是在用户台中执行的，大部分操作都需要通过系统调用处理</li></ul><h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><p><img src="/20220525/OSlab4%E7%AC%94%E8%AE%B0/4_fork_process.png" alt="fork 流程图"></p><h4 id="Copy-On-Write"><a href="#Copy-On-Write" class="headerlink" title="Copy On Write"></a>Copy On Write</h4><p>​顾名思义，写时复制指当进程试图写一个被COW保护的页面时，会产生一个页写入异常，并在<strong>处理函数</strong>中将该页面重新映射到一个新分配的物理页中，<strong>复制</strong>原本的内容后再退出异常进行写操作。</p><p>​COW的引入，使得fork调用后父进程和子进程可以<strong>暂时</strong>共用页面，实现<strong>将父进程的状态完全“复制”到子进程中，并保证在后续操作中相互独立</strong></p><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>​我们认为在处理完fork返回用户态时，经历了同样的恢复过程，区别主要在于<strong>父进程是从系统调用中返回时恢复现场，而子进程则是在进程被调度时恢复现场</strong>。</p><h5 id="Ex4-8-sys-env-alloc函数"><a href="#Ex4-8-sys-env-alloc函数" class="headerlink" title="Ex4.8 sys_env_alloc函数"></a>Ex4.8 sys_env_alloc函数</h5><p>​该函数用来初步创建一个进程，即给一个进程分配其进程控制块（PCB），并完成部分进程设置。</p><ul><li>复制父进程的进程上下文</li><li>设置异常返回的指令地址</li><li>根据fork的要求将返回值<code>$v0</code>设置为0</li><li>阻塞该子进程避免其立刻被调度，以保证后续的设置正常完成</li><li>其余相关信息的设置(env_pri)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_env_alloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-type">int</span> r;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br>        <span class="hljs-keyword">if</span> ((r = env_alloc(&amp;e, curenv-&gt;env_id)) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//获取一个新的PCB</span><br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        e-&gt;env_status = ENV_NOT_RUNNABLE;  <span class="hljs-comment">//阻塞子进程</span><br>        bcopy((<span class="hljs-type">void</span> *)(KERNEL_SP - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe)), (<span class="hljs-type">void</span> *)(&amp;(e-&gt;env_tf)), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe)); <br>    <span class="hljs-comment">//复制上下文</span><br>        e-&gt;env_tf.pc = e-&gt;env_tf.cp0_epc; <span class="hljs-comment">//设置PC值</span><br>        e-&gt;env_pri = curenv-&gt;env_pri; <span class="hljs-comment">//设置</span><br>        e-&gt;env_tf.regs[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// $v0 = 0 </span><br>        <span class="hljs-keyword">return</span> e-&gt;env_id; <span class="hljs-comment">//将子进程的id返回，最后交给父进程的fork返回</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="父子进程的区分"><a href="#父子进程的区分" class="headerlink" title="父子进程的区分"></a>父子进程的区分</h4><p>​虽然我们说fork创建的父子进程共享上下文、程序等，但终究是需要区分的，如何区分呢？通过调用<code>sys_env_alloc</code>后的返回值开始我们实现了区分，一步一步完成后续设置。</p><h5 id="Ex4-9-fork函数1"><a href="#Ex4-9-fork函数1" class="headerlink" title="Ex4.9 fork函数1"></a>Ex4.9 fork函数1</h5><p>​当调用完<code>sys_env_alloc</code>后，如果是子进程，当前则要完成后续设置，若为父进程则直接返回子进程的进程块就好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">newenvid = syscall_env_alloc();<br>        <span class="hljs-keyword">if</span> (newenvid == <span class="hljs-number">0</span>) &#123;<br>                env = &amp;envs[ENVX(syscall_getenvid())];<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><h5 id="Ex4-10-duppage函数"><a href="#Ex4-10-duppage函数" class="headerlink" title="Ex4.10 duppage函数"></a>Ex4.10 duppage函数</h5><p>​该函数的作用是针对某个具体的页面，创建子进程后，通过该函数完成页面到子进程的映射，具体要求见代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">duppage</span><span class="hljs-params">(u_int envid, u_int pn)</span><br>&#123;<br>        u_int addr;<br>        u_int perm;<br>        addr = (pn &lt;&lt; PGSHIFT); <span class="hljs-comment">//通过页面编号pn获得该页面的地址</span><br>        perm = ((Pte *)(*vpt))[pn] &amp; <span class="hljs-number">0xfff</span>; <span class="hljs-comment">//通过父进程的页表获得该页表原有的perm</span><br>        <span class="hljs-keyword">if</span> ((perm &amp; PTE_R) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (syscall_mem_map(<span class="hljs-number">0</span>, addr, envid, addr, perm) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//只读页面直接映射</span><br>                        user_panic(<span class="hljs-string">&quot;panic at duppage : !PTE_R&quot;</span>);<br>                &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((perm &amp; PTE_COW) != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (syscall_mem_map(<span class="hljs-number">0</span>, addr, envid, addr, perm) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//若已经被COW保护，说明未被写过，直接映射即可</span><br>                        user_panic(<span class="hljs-string">&quot;panic at duppage : PTE_COW&quot;</span>);<br>                &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((perm &amp; PTE_LIBRARY) != <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//LIBARY权限说明该页面父子进程间共享，可实现数据的共享，直接映射即可</span><br>                <span class="hljs-keyword">if</span> (syscall_mem_map(<span class="hljs-number">0</span>, addr, envid, addr, perm) &lt; <span class="hljs-number">0</span>) &#123;<br>                        user_panic(<span class="hljs-string">&quot;panic at duppage : PTE_LIBRARY&quot;</span>);<br>                &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (syscall_mem_map(<span class="hljs-number">0</span>, addr, envid, addr, perm | PTE_COW) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//一般情况，需要给父子进程分别加上COW保护</span><br>                        user_panic(<span class="hljs-string">&quot;panic at duppage : normal for child&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (syscall_mem_map(<span class="hljs-number">0</span>, addr, <span class="hljs-number">0</span>, addr, perm | PTE_COW) &lt; <span class="hljs-number">0</span>) &#123;<br>                        user_panic(<span class="hljs-string">&quot;panic at duppage : normal for father&quot;</span>);<br>                &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="页写入异常处理"><a href="#页写入异常处理" class="headerlink" title="页写入异常处理"></a>页写入异常处理</h4><h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>页写入异常分为<strong>注册</strong>和<strong>异常处理</strong>两部分</p><ul><li><p>fork新建进程时，先是用<code>set_pgfault_handler</code>为父进程注册，后还为子进程调用<code>syscall_set_pgfault_handler</code>进行注册</p><ul><li><code>set_pgfault_handler</code>函数<ul><li>为异常栈分配物理页面</li><li>并调用<code>syscall_set_pgfault_handler</code></li><li>最后将**全局变量<code>__pgfault_handler</code>**设置为<code>pgfault</code>的入口，会在<code>__asm_pgfault_handler</code>被用于具体处理</li></ul></li><li><code>syscall_set_pgfault_handler</code>函数<ul><li>将给进程后文用到的<code>env_pgfault_handler</code>设置为<strong>处理函数<code>__asm_pgfault_handler</code>的入口</strong></li><li>设置<code>env_xstacktop</code>设置相应的异常栈地址</li></ul></li></ul></li><li><p>写COW页面触发页写入异常 </p><ul><li>（内核态）调用处理函数handle_mod </li><li>跳转到page_fault_handler函数<ul><li>将异常现场压入异常栈</li><li>设置epc值为<code>env_pgfault_handler</code>（进程块中记录<strong>处理函数入口</strong>的变量），使得回到用户态后跳转掉相应异常处理函数</li></ul></li><li>（用户态）退出异常后，根据前面设置好的PC值跳转到处理的<strong>核心函数<code>__asm_pgfault_handler</code></strong><ul><li>获取发生异常的地址</li><li>跳转到<code>__pgfault_handler</code>设置好的函数，即pgfault函数，完成相应页面拷贝、映射等操作</li><li>至此异常已解决，后续完成一系列的现场恢复即可<strong>完成整个页写入异常的处理</strong>了</li></ul></li></ul></li></ul><h5 id="Ex4-11-page-fault-handler"><a href="#Ex4-11-page-fault-handler" class="headerlink" title="Ex4.11 page_fault_handler"></a>Ex4.11 page_fault_handler</h5><p>​该函数负责将当前现场保存在异常处理栈中，并设置epc寄存器的值，使得从中断恢复后能够跳转到env_pgfault_handler域存储的异常处理函数的地址。</p><ul><li>注意：这里我们的函数支持了缺页异常冲入的功能，但目前来说未有发现能触发页写入异常重入的情况</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_fault_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Trapframe *tf)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> <span class="hljs-title">PgTrapFrame</span>;</span><br>    <span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">curenv</span>;</span><br><br>    bcopy(tf, &amp;PgTrapFrame, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe));<br><br>    <span class="hljs-keyword">if</span> (tf-&gt;regs[<span class="hljs-number">29</span>] &gt;= (curenv-&gt;env_xstacktop - BY2PG) &amp;&amp;<br>        tf-&gt;regs[<span class="hljs-number">29</span>] &lt;= (curenv-&gt;env_xstacktop - <span class="hljs-number">1</span>)) &#123;<br>            tf-&gt;regs[<span class="hljs-number">29</span>] = tf-&gt;regs[<span class="hljs-number">29</span>] - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span>  Trapframe); <span class="hljs-comment">//异常重入</span><br>            bcopy(&amp;PgTrapFrame, (<span class="hljs-type">void</span> *)tf-&gt;regs[<span class="hljs-number">29</span>], <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tf-&gt;regs[<span class="hljs-number">29</span>] = curenv-&gt;env_xstacktop - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span>  Trapframe); <span class="hljs-comment">//正常情况</span><br>            bcopy(&amp;PgTrapFrame,(<span class="hljs-type">void</span> *)curenv-&gt;env_xstacktop - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span>  Trapframe),<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe));<br>        &#125;<br>    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Set EPC to a proper value in the trapframe</span><br>        tf-&gt;cp0_epc = curenv-&gt;env_pgfault_handler;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Ex4-12-sys-set-pgfault-handler函数"><a href="#Ex4-12-sys-set-pgfault-handler函数" class="headerlink" title="Ex4.12 sys_set_pgfault_handler函数"></a>Ex4.12 sys_set_pgfault_handler函数</h5><p>​该函数是set_pgfault_handler函数在用户态发出系统调用后，在内核态的具体实现，用于注册<strong>异常处理函数</strong>，任务是给进程块<strong>设置处理函数入口</strong>和<strong>异常处理栈</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_set_pgfault_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, u_int envid, u_int func, u_int xstacktop)</span><br>&#123;<br>        <span class="hljs-type">int</span> ret;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br>        <span class="hljs-keyword">if</span> ((ret = envid2env(envid, &amp;env, <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// ?</span><br>                <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        env-&gt;env_pgfault_handler = func;<br>        env-&gt;env_xstacktop = xstacktop;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Ex4-13-pgfault函数"><a href="#Ex4-13-pgfault函数" class="headerlink" title="Ex4.13 pgfault函数"></a>Ex4.13 pgfault函数</h5><p>​pgfault函数是真正的最终处理COW的核心部分，且处于<strong>用户态</strong>中，实现了将COW页面复制并重新映射的功能。</p><ul><li>注意：USTACKTOP是一个虚拟地址，我们首先临时给这个地址分配了一个<strong>物理页</strong>，在完成复制之后，取消原来的<strong>临时页面</strong>的虚物映射，同时将这个物理页映射到<strong>当前进程</strong>的虚拟地址va处，这样保证了我们当前进程有一个全新的页面进行写操作，而另一个进程则仍是保留着原有的物理页面。（要注意物理页面和虚拟地址之间的映射原理）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">pgfault</span><span class="hljs-params">(u_int va)</span><br>&#123;<br>        u_int *tmp;<br>        u_int perm;<br>        tmp = USTACKTOP; <span class="hljs-comment">//在用户栈中临时申请页面用于复制</span><br>        va = ROUNDDOWN(va, BY2PG);<br>        perm = (((Pte *)(*vpt))[VPN(va)] &amp; <span class="hljs-number">0xfff</span>);<br>        <span class="hljs-keyword">if</span> ((perm &amp; PTE_COW) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//判断是否为COW页面，若不是需要报错</span><br>                user_panic(<span class="hljs-string">&quot;panic at pgfault : NOT COW&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (syscall_mem_alloc(<span class="hljs-number">0</span>, tmp, (PTE_V | PTE_R)) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//申请一个新的物理页用于复制内容</span><br>                user_panic(<span class="hljs-string">&quot;panic at pgfault : page alloc failed&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//map the new page at a temporary place</span><br>        <span class="hljs-comment">//copy the content</span><br>        user_bcopy(va, tmp, BY2PG); <span class="hljs-comment">//将COW页面的内容复制到临时页面中</span><br>        <span class="hljs-keyword">if</span> (syscall_mem_map(<span class="hljs-number">0</span>, tmp, <span class="hljs-number">0</span>, va, PTE_V | PTE_R) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//将临时页面顶替原来页面</span><br>                user_panic(<span class="hljs-string">&quot;panic at pgfault : map failed&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (syscall_mem_unmap(<span class="hljs-number">0</span>, tmp) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//解除临时页面在用户栈中的映射</span><br>                user_panic(<span class="hljs-string">&quot;panic at pgfault : unmap failed&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//map the page on the appropriate place</span><br>        <span class="hljs-comment">//unmap the temporary place</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="最后步骤"><a href="#最后步骤" class="headerlink" title="最后步骤"></a>最后步骤</h4><h5 id="Ex4-14-sys-set-env-status函数"><a href="#Ex4-14-sys-set-env-status函数" class="headerlink" title="Ex4.14 sys_set_env_status函数"></a>Ex4.14 sys_set_env_status函数</h5><p>​这个函数就是在用户态下实现对进程status的设置，并在恰当的情况下将该进程加入调入队列</p><ul><li>注意：通过询问助教，我们得知该函数只会在fork中被调用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sys_set_env_status</span><span class="hljs-params">(<span class="hljs-type">int</span> sysno, u_int envid, u_int status)</span><br>&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br>        <span class="hljs-type">int</span> ret;<br>        <span class="hljs-keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE &amp;&amp; status != ENV_FREE) &#123; <span class="hljs-comment">//状态必须是上面三种之一，才可在此进行状态设置</span><br>                <span class="hljs-keyword">return</span> -E_INVAL;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ((ret = envid2env(envid, &amp;env, <span class="hljs-number">1</span>)) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (status == ENV_FREE) &#123;<br>                env_destroy(env); <span class="hljs-comment">//释放该进程</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                env-&gt;env_status = status;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (status == ENV_RUNNABLE) &#123; <span class="hljs-comment">//判断是否要插入调度队列中</span><br>                <span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env_list</span> <span class="hljs-title">env_sched_list</span>[2];</span><br>                LIST_INSERT_HEAD(env_sched_list, env, env_sched_link);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Ex4-15-完成fork函数"><a href="#Ex4-15-完成fork函数" class="headerlink" title="Ex4.15 完成fork函数"></a>Ex4.15 完成fork函数</h5><p>​前面我们已经完成了实现fork所需要的所有函数，现在就是调用这些函数完整实现子进程创建。</p><ul><li>创建子进程</li><li>遍历父进程地址空间，对页面进行duppage进行保护处理<ul><li>根据MOS，高2G的内存由所有进程所共享，且异常栈无需被保护，因此我们只需要对[0,USTACKTOP]的内存进行保护</li></ul></li><li>给子进程分配异常处理栈分配物理页面，用于后续供给页写入异常使用</li><li>给子进程<strong>注册</strong>页写入异常函数</li><li>设置子进程状态即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        u_int newenvid;<br>        <span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">envs</span>;</span><br>        <span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span>;</span><br>        u_int i;<br>        <span class="hljs-comment">//The parent installs pgfault using set_pgfault_handler</span><br>        set_pgfault_handler(pgfault);<br>        <span class="hljs-comment">//alloc a new alloc</span><br>        newenvid = syscall_env_alloc();<br>        <span class="hljs-keyword">if</span> (newenvid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果返回后是父进程，这里就可以退出了</span><br>                env = &amp;envs[ENVX(syscall_getenvid())];<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; USTACKTOP;i += BY2PG) &#123;                <span class="hljs-keyword">if</span> (((((Pde *)(*vpd))[i &gt;&gt; PDSHIFT]) &amp; PTE_V) &amp;&amp; ((((Pte *)(*vpt))[i &gt;&gt; PGSHIFT]) &amp; PTE_V)) &#123;<br>                        <span class="hljs-comment">//writef(&quot;%x\n&quot;,(*vpt)[VPN(i)]);</span><br>                        duppage(newenvid, VPN(i));<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (syscall_mem_alloc(newenvid, UXSTACKTOP - BY2PG, PTE_V | PTE_R) &lt; <span class="hljs-number">0</span>) &#123;<br>                user_panic(<span class="hljs-string">&quot;panic at fork : alloc failed&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (syscall_set_pgfault_handler(newenvid, __asm_pgfault_handler, UXSTACKTOP) &lt; <span class="hljs-number">0</span>) &#123;<br>                user_panic(<span class="hljs-string">&quot;panic at fork : set pgfault handler failed&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (syscall_set_env_status(newenvid , ENV_RUNNABLE) &lt; <span class="hljs-number">0</span>) &#123;<br>                user_panic(<span class="hljs-string">&quot;panic at fork : status set failed&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> newenvid;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统实验笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSlab3实验报告</title>
    <link href="/20220515/OSlab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/20220515/OSlab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="lab3实验报告"><a href="#lab3实验报告" class="headerlink" title="lab3实验报告"></a>lab3实验报告</h2><h3 id="1-实验思考题"><a href="#1-实验思考题" class="headerlink" title="1.实验思考题"></a>1.实验思考题</h3><h5 id="Thinking3-1"><a href="#Thinking3-1" class="headerlink" title="Thinking3.1"></a>Thinking3.1</h5><blockquote><p><strong>为什么envid2env 中需要判断e-&gt;env_id !&#x3D; envid 的情况？如果没有这步判断会发生什么情况？</strong></p></blockquote><ul><li>由<code>(asid &lt;&lt; (1 + LOG2NENV)) | (1 &lt;&lt; LOG2NENV) | idx;</code>可知，一个envid由两部分组成，<strong>高位的ASID和低位的进程块偏移量</strong>。而当我们通过<code>envid2env</code>取进程块时只是通过<code>ENVX(envid)</code>即低位的进程块偏移量<code>idx</code>来获取进程块<code>i</code>，并不能保证高位的ASID相匹配，也即不能保证找到的是对应的目的进程块，因此需要判断<code>e-&gt;env_id != envid</code>的情况。若<code>e-&gt;env_id != envid</code>成立，说明该envid指向的进程根本不存在，需要报错。</li></ul><h5 id="Thinking3-2"><a href="#Thinking3-2" class="headerlink" title="Thinking3.2"></a>Thinking3.2</h5><blockquote><p><strong>结合include&#x2F;mmu.h 中的地址空间布局，思考env_setup_vm 函数：</strong></p><p><strong>• UTOP 和ULIM 的含义分别是什么，UTOP 和ULIM 之间的区域与UTOP以下的区域相比有什么区别？</strong></p><p><strong>• 请结合系统自映射机制解释代码中pgdir[PDX(UVPT)]&#x3D;env_cr3的含义。</strong></p><p><strong>• 谈谈自己对进程中物理地址和虚拟地址的理解。</strong></p></blockquote><ul><li><code>UTOP</code>是用户可读写的最高地址，<code>ULIM</code>是用户可访问但不可写的最高地址，<code>UTOP</code>和<code>ULIM</code>之间的区域相比于<code>UTOP</code>以下的区域缺少了可写性，是只读的，前者所存储的页表，进程块等内容可供于用户读取，但不能修改。</li><li>通过系统自映射机制,<code>UVPT</code>指的是虚拟地址的页目录地址，而<code>pgdir[PDX(UVPT)]</code>则是自映射机制中，页目录存储所在的页目录项，通过<code>pgdir[PDX(UVPT)]=env_cr3</code>我们将<strong>页目录的物理地址</strong>与虚拟地址中的页目录项相关联，方便页表信息的读取。</li><li>进程中的物理地址和虚拟地址<ul><li>每个进程都有自己的一套虚拟地址且各进程间相互独立，使得程序能够自由使用内存；而物理地址则是唯一且有限的，它担当了实际存储内容的角色。这两者间，虚拟内存通过映射到物理内存上实现存储。不同进程间的虚拟地址可映射到相同的物理地址，从实现进程间数据<strong>共享</strong>等功能。</li></ul></li></ul><h5 id="Thinking3-3"><a href="#Thinking3-3" class="headerlink" title="Thinking3.3"></a>Thinking3.3</h5><blockquote><p>找到 user_data 这一参数的来源，思考它的作用。没有这个参数可不可以？为什么？（可以尝试说明实际的应用场景，举一个实际的库中的例子）</p></blockquote><ul><li><code>user_data</code>在<code>load_icode</code>和<code>load_elf</code>中传入了进程e，在<code>load_icode_mapper</code>中被用于<code>struct Env *env = (struct Env *)user_data;</code>作为<strong>镜像载入的目的进程</strong>。可见<code>user_data</code>就是一个传入进程指针的角色，是必不可少的参数。许多场景都会传入指针用于引用某个东西，例如qsort里面就传入<code>compare</code>函数的指针用于重定义比较格式。</li></ul><h5 id="Thinking3-4"><a href="#Thinking3-4" class="headerlink" title="Thinking3.4"></a>Thinking3.4</h5><blockquote><p><strong>结合load_icode_mapper 的参数以及二进制镜像的大小，考虑该函数可能会面临哪几种复制的情况？你是否都考虑到了？</strong> </p></blockquote><p>最糟糕的情况如图所示</p><p><img src="/20220515/OSlab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/Load_icode_mapper.png" alt="每个segment的加载地址布局"></p><p>​其原因都是由于复制的内容与页面不对齐所导致，一是.text&amp;.data<code>或</code>.<code>bss</code>段的开头部分不与页面对齐，二是在结束部分不对齐多出一截，均需要找到或新建对应页面进行关联。</p><h5 id="Thinking3-5"><a href="#Thinking3-5" class="headerlink" title="Thinking3.5"></a>Thinking3.5</h5><blockquote><p><strong>•</strong> <strong>你认为这里的 env_tf.pc 存储的是物理地址还是虚拟地址?</strong></p><p><strong>• 你觉得entry_point其值对于每个进程是否一样？该如何理解这种统一或不同？</strong></p></blockquote><ul><li>应该是虚拟地址，因为程序所能看到的应该是虚拟地址，是连续的，通过程序预存储，系统将对应指令放在虚拟地址某一位置，通过PC指向该地址来运行。而物理地址是共享且不连续的，显然不会是物理地址。</li><li>entry_point其值对于每个进程<strong>一样</strong>，代码段在每个进程中应存在虚拟内存中的同一个位置，使得虚拟内存的分段管理有序。</li></ul><h5 id="Thinking3-6"><a href="#Thinking3-6" class="headerlink" title="Thinking3.6"></a>Thinking3.6</h5><blockquote><p><strong>请查阅相关资料解释，上面提到的epc是什么？为什么要将env_tf.pc设置为epc呢？</strong></p></blockquote><p>​epc即是我们进程处理切换回来时，所继续执行的指令所在的地址，env-tf是Env进程块中存储进程上下文的成员，将env_tf.pc设置为epc，使得进程<strong>切换回来</strong>的时候可以将pc设置为epc，继续完成未完成的程序。</p><h5 id="Thinking3-7"><a href="#Thinking3-7" class="headerlink" title="Thinking3.7"></a>Thinking3.7</h5><blockquote><p><strong>•</strong> <strong>操作系统在何时将什么内容存到了 TIMESTACK 区域</strong></p><p><strong>•</strong> <strong>TIMESTACK 和 env_asm.S 中所定义的 KERNEL_SP 的含义有何不同</strong></p></blockquote><ul><li><p>操作系统在<code>env_destroy</code>中，将一个<code>Trapframe</code>的的内容从<code>KERNEL_SP</code>复制到了<code>TIMESTACK</code>中。</p></li><li><pre><code class="hljs">.macro get_sp        mfc0    k1, CP0_CAUSE        andi    k1, 0x107C        xori    k1, 0x1000        bnez    k1, 1f        nop        li      sp, 0x82000000        j       2f        nop1:        bltz    sp, 2f        nop        lw      sp, KERNEL_SP        nop2:      nop<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  ​通过该段汇编代码我们可知，当发生的为时钟中断时，我们就选取`TIMESTACK`地址，而其余则是使用`KERNEL_SP`的地址。当我们处理异常时调用`SAVE_ALL`时就会根据是否为时钟中断来选取保存寄存器上下文的位置。<br><br>##### Thinking3.<span class="hljs-number">8</span><br><br>&gt; **试找出上述 <span class="hljs-number">5</span> 个异常处理函数的具体实现位置。**<br><br>- <span class="hljs-number">0</span>号异常：handle_int` 在`lib/genex.S`通过汇编语言编写了该处理函数<br>- <span class="hljs-number">1</span>号异常：`handle_mod` 在`lib/trap.c`中用C编写了`page_fault_handler`函数，然后在`lib/genex.S`中用`BUILD_HANDLER`宏创建了该函数<br>- <span class="hljs-number">2</span>、<span class="hljs-number">3</span>号异常：`handle_tlb` 在`lib/genex.S`中编写了`do_refill`函数，然后在`lib/genex.S`中用`BUILD_HANDLER`宏创建了该函数<br>- <span class="hljs-number">8</span>号异常：`handle_sys` 在`lib/syscall.S`中用汇编语言编写了该函数<br><br>##### Thinking3.<span class="hljs-number">9</span><br><br>&gt; **阅读 kclock_asm.S 和 genex.S 两个文件，并尝试说出 set_timer 和timer_irq 函数中每行汇编代码的作用**<br><br>- **kclock_asm.S**<br><br>  ```assembly<br>  LEAF(set_timer)<br>          li t0, <span class="hljs-number">0</span>xc8<br>          sb t0, <span class="hljs-number">0</span>xb5000100#向<span class="hljs-number">0</span>xb5000100写入<span class="hljs-number">0</span>xc8，控制时钟频率<br>          sw      sp, KERNEL_SP#将sp寄存器的值写入KERNEL_SP中，保存sp的值<br>  setup_c0_status STATUS_CU0|<span class="hljs-number">0</span>x1001 <span class="hljs-number">0</span>#设置CP0_STATUS的值<br>          jr ra#返回调用处<br>          nop<br>  END(set_timer)<br></code></pre></td></tr></table></figure></code></pre></li><li><p><strong>genex.S</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">timer_irq:<br>        sb zero, 0xb5000110#拒绝外设请求中断，保证时钟中断正常执行<br>1:      j       sched_yield#跳转到sched_yield函数进行进程调度<br>        nop<br>        j       ret_from_exception#跳转到ret_from_exception函数，从而退出异常<br>        nop<br></code></pre></td></tr></table></figure></li></ul><h5 id="Thinking3-10"><a href="#Thinking3-10" class="headerlink" title="Thinking3.10"></a>Thinking3.10</h5><blockquote><p>阅读相关代码，思考操作系统是怎么根据时钟周期切换进程的。</p></blockquote><p>​虽然我们在编写<code>sched_yield</code>函数的时候使用了两个队列，但本质上其实就是有一个进程的等待队列，所有可执行的进程在其中排队。我们把每一次时钟中断看作度过了一次时间片，每当时钟中断发生，检查一下当前的进程的还有无时间片，若有则让其继续执行，若无则将其放到等待队列队尾，取出队首的下一个进程，为其分配时间片数，然后让该进程运行，循环往复从而实现了进程的调度与切换。</p><h3 id="2-实验难点图示"><a href="#2-实验难点图示" class="headerlink" title="2.实验难点图示"></a>2.实验难点图示</h3><h5 id="1-进程的创建过程"><a href="#1-进程的创建过程" class="headerlink" title="1.进程的创建过程"></a>1.进程的创建过程</h5><p>​下图为用户创建进程的过程，我们假设<code>env_init</code>的进程块初始化已经完成。</p><p><img src="/20220515/OSlab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220515145132242.png" alt="image-20220515145132242"></p><h5 id="2-异常的分发"><a href="#2-异常的分发" class="headerlink" title="2.异常的分发"></a>2.异常的分发</h5><p><img src="/20220515/OSlab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220515151600256.png" alt="image-20220515151600256"></p><h5 id="3-时钟中断与进程调度"><a href="#3-时钟中断与进程调度" class="headerlink" title="3.时钟中断与进程调度"></a>3.时钟中断与进程调度</h5><p><img src="/20220515/OSlab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220515153916980.png" alt="image-20220515153916980"></p><h3 id="3-体会与感想"><a href="#3-体会与感想" class="headerlink" title="3.体会与感想"></a>3.体会与感想</h3><p>​这几周lab3的学习与上机，让我逐渐感到操作系统学习渐入佳境，特别是不同于前两个lab的有点搞不清楚自己在干什么，lab3的学习让我开始逐渐理解了操作系统背后的逻辑与运转模式。但同时这也与前两个lab学习所打下的基础密不可分，在lab3的学习中，经常有的一种感受就是，原本被略显繁杂的各个函数绕晕了，但细细整理后豁然开朗，理解了每个操作的目的所在。</p><p>​实践证明了做笔记与整理对于操作系统这门课是有巨大助益的，在lab3的两次上机前，我都对课下的内容进行了梳理和记录，这使得我在上机的过程中能清晰地把握原有的系统脉络，更好地去实现课上所需要实现的内容（虽然还是很惊险在最后1min才过），同时这样也使得我对其的理解加深，记忆的难度也下降了。因此在后续的lab中我要继续做好整理和记录，以及着手于理论课的整理，想必会对后续的学习起到很好的助益。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统实验报告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSlab3笔记</title>
    <link href="/20220511/OSlab3%E7%AC%94%E8%AE%B0/"/>
    <url>/20220511/OSlab3%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>​lab3主要是初步写进程，大体分为<strong>进程基础架构</strong>以及<strong>异常与进程调度</strong>两个部分。</p><h2 id="进程基础架构"><a href="#进程基础架构" class="headerlink" title="进程基础架构"></a>进程基础架构</h2><h3 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h3><ul><li>进程即是基本的<strong>分配</strong>单元，也是基本的<strong>执行</strong>单元，每个进程有自己的地址空间。<strong>执行中的程序就是进程</strong></li></ul><h4 id="进程控制块（PBC）"><a href="#进程控制块（PBC）" class="headerlink" title="进程控制块（PBC）"></a>进程控制块（PBC）</h4><p>​进程控制块的具体实现是<strong>Env结构体</strong>，记录了对应进程的特征，用于调度线程时提供进程信息。</p><ul><li>Env组成<ul><li><code>struct Trapframe env_tf</code> Trapframe是一个<strong>记录进程上下文环境</strong>的结构体，如寄存器、epc等，当发生进程调度，或异常进入陷入内核时，就将上下文bcopy到该成员中，以供下一次使用</li><li><code>LIST_ENTRY(Env) env_link</code> 链表的索引，即field</li><li><code>env_id</code> 独一无二的进程id，通常可通过<code>envid2env()</code>获得相应的env进程块</li><li><code>env_parent_id</code> 父进程的id</li><li><code>env_status</code> 表示该进程的状态，一般有<code>ENV_FREE ENV_NOT_RUNNABLE NEV_RUNNABLE</code>三种状态</li><li><code>env_pgdir</code> 保存该进程页目录的内核虚拟地址（每一个内存都有自己的一套虚拟空间）</li><li><code>env_cr3</code> 保存该进程页目录的物理地址</li><li><code>env_sched_link</code> 同样也是调度队列<code>env_sched_list</code>索引，见后面调度部分</li><li><code>env_pri</code> 保存了该进程的优先级，后面我们把pri用来当作该进程所获得的<strong>时间片数</strong></li><li>……  其他的组成部分将会在lab4-6中用到，暂不说明</li></ul></li></ul><h4 id="Ex3-1-阅读mips-vm-init中为envs数组分配空间的代码"><a href="#Ex3-1-阅读mips-vm-init中为envs数组分配空间的代码" class="headerlink" title="Ex3.1 阅读mips_vm_init中为envs数组分配空间的代码"></a>Ex3.1 阅读<code>mips_vm_init</code>中为envs数组分配空间的代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">envs = (<span class="hljs-keyword">struct</span> Env *)alloc(NENV * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env), BY2PG, <span class="hljs-number">1</span>);<span class="hljs-comment">//为进程块申请内存，共1024个</span><br>n = ROUND(NENV * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env), BY2PG); <span class="hljs-comment">//NENV个Env的大小n</span><br>boot_map_segment(pgdir, UENVS, n, PADDR(envs), PTE_R); <span class="hljs-comment">//从虚拟内存映射到物理内存，大小为n</span><br></code></pre></td></tr></table></figure><ul><li><code>NENV = (1 &lt;&lt; LOG2NENV) = 1024</code></li><li><code>UENVS</code> 见内存图，与<code>UTOP、UXSTACKTOP</code>位于同一位置，内核态存储进程块的位置</li></ul><h4 id="Ex3-2-填写env-init"><a href="#Ex3-2-填写env-init" class="headerlink" title="Ex3.2 填写env_init"></a>Ex3.2 填写<code>env_init</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>        LIST_INIT(&amp;env_free_list); <span class="hljs-comment">//初始化进程空闲链表</span><br>        LIST_INIT(&amp;env_sched_list[<span class="hljs-number">0</span>]); <span class="hljs-comment">//初始化调度链表，在后续会涉及</span><br>        LIST_INIT(&amp;env_sched_list[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (i = NENV<span class="hljs-number">-1</span>; i &gt;=  <span class="hljs-number">0</span>; i--) &#123;<br>                envs[i].env_status = ENV_FREE; <span class="hljs-comment">//修改状态为ENV_FREE</span><br>                LIST_INSERT_HEAD(&amp;env_free_list, &amp;(envs[i]), env_link); <span class="hljs-comment">//插入空闲链表中，要求为倒序</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>该函数是进程的统一<strong>初始化</strong>，初始化空闲链表（这是双向链表的基本方法），将所有env块<strong>倒序</strong>插入该链表中</li></ul><h3 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h3><p>​每个进程有一个独一无二的<strong>ASID</strong>，是envid的一部分。因为不同进程可以有相同的虚拟地址，因此在TLB的Key Fields的6-11位会存储其对应的ASID，以保证该页面映射是该进程的，否则就要进行页面替换。</p><p>​进程创建时调用<code>mkenvid</code>来获取独一无二的envid，其中又调用了<code>asid_alloc</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u_int <span class="hljs-title function_">asid_alloc</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//ASID最多有64个，分别通过两个32位asid_bitmap来标注其是否被申请</span><br>    <span class="hljs-type">int</span> i, index, inner;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i) &#123;<br>        index = i &gt;&gt; <span class="hljs-number">5</span>; <span class="hljs-comment">//0即0-31 1即32-63</span><br>        inner = i &amp; <span class="hljs-number">31</span>; <span class="hljs-comment">//取低32位，即在给asid_bitmap中是哪一位</span><br>        <span class="hljs-keyword">if</span> ((asid_bitmap[index] &amp; (<span class="hljs-number">1</span> &lt;&lt; inner)) == <span class="hljs-number">0</span>) &#123;<br>            asid_bitmap[index] |= <span class="hljs-number">1</span> &lt;&lt; inner;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    panic(<span class="hljs-string">&quot;too many processes!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">u_int <span class="hljs-title function_">mkenvid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span> &#123;<br>    u_int idx = e - envs; <span class="hljs-comment">//获取是第几个进程</span><br>    u_int asid = asid_alloc(); <span class="hljs-comment">//获取ASID</span><br>    <span class="hljs-keyword">return</span> (asid &lt;&lt; (<span class="hljs-number">1</span> + LOG2NENV)) | (<span class="hljs-number">1</span> &lt;&lt; LOG2NENV) | idx; <br>&#125;<br></code></pre></td></tr></table></figure><p>​可见<code>env_id</code>由<strong>ASID</strong>和<strong>进程块编号i</strong>组成</p><h4 id="Exe3-3-envid2env函数"><a href="#Exe3-3-envid2env函数" class="headerlink" title="Exe3.3 envid2env函数"></a>Exe3.3 envid2env函数</h4><p>​该函数主要是通过envid获取相应的env进程块，十分常用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">envid2env</span><span class="hljs-params">(u_int envid, <span class="hljs-keyword">struct</span> Env **penv, <span class="hljs-type">int</span> checkperm)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br>        <span class="hljs-keyword">if</span> (!envid) &#123; <span class="hljs-comment">//若传入的envid为0，我们默认然会当前的进程块————curenv</span><br>                *penv = curenv;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                e = &amp;envs[ENVX(envid)]; <span class="hljs-comment">//ENVX即是取出envid中的进程块编号i</span><br>        &#125;<br><br>    <span class="hljs-keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;<br>        *penv = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> -E_BAD_ENV; <span class="hljs-comment">//如果该进程并非被创建使用，那么我们报错</span><br>    &#125;<br>    <br>        <span class="hljs-keyword">if</span> (checkperm) &#123; <span class="hljs-comment">//若checkperm，要保证该进程是curenv或其子进程，若不是则报错</span><br>                <span class="hljs-keyword">if</span> (e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id) &#123;<br>                        *penv = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">return</span> -E_BAD_ENV;<br>                &#125;<br>        &#125;<br><br>    *penv = e; <span class="hljs-comment">//最后将查询到的进程返回到penv中</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​在调用envid2env函数时，要注意<code>checkperm</code>的值，看清楚是否需要该限制，否则很容易出错。</p><h3 id="进程块设置"><a href="#进程块设置" class="headerlink" title="进程块设置"></a>进程块设置</h3><p>​有了空闲进程块，接下来就是为创建进程时申请并设置其控制块，首先需要调用<code>env_setup_vm</code>为该进程初始化其虚拟空间，然后由env_alloc完成进程快的其余设置</p><h4 id="Ex3-4-env-setup-vm"><a href="#Ex3-4-env-setup-vm" class="headerlink" title="Ex3.4 env _setup_vm"></a>Ex3.4 env _setup_vm</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">env_setup_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br><br>    <span class="hljs-type">int</span> i, r;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br>    Pde *pgdir;<br><br>    <span class="hljs-keyword">if</span> (r = page_alloc(&amp;p) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//为该进程的页目录申请一个Page</span><br>        panic(<span class="hljs-string">&quot;env_setup_vm - page alloc error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>        p-&gt;pp_ref++; <span class="hljs-comment">//增加该页面的引用数</span><br>        pgdir = (Pde*) page2kva(p); <br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; PDX(UTOP);i++) &#123;<br>                pgdir[i] = <span class="hljs-number">0</span>; <span class="hljs-comment">//将UTOP前的页表清零</span><br>        &#125;<br>    <br>        <span class="hljs-keyword">for</span> (i = PDX(UTOP);i &lt; PTE2PT;i++) &#123; <span class="hljs-comment">//UTOP后的内容是系统内容，所有页表应保持一致</span><br>                <span class="hljs-keyword">if</span> (i != PDX(UVPT)) &#123;<br>                        pgdir[i] = boot_pgdir[i]; <br>                &#125;<br>        &#125;<br>        e-&gt;env_pgdir = pgdir; <span class="hljs-comment">//别忘了前面都是临时变量，我们最后要将其记录到进程块中</span><br>        e-&gt;env_cr3 = PADDR(pgdir);<br><span class="hljs-comment">/* UVPT maps the env&#x27;s own page table, with read-only permission.*/</span><br>    e-&gt;env_pgdir[PDX(UVPT)]  = e-&gt;env_cr3 | PTE_V; <span class="hljs-comment">//VPT是页目录的地址，进行权限设置</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​操作系统将一些内核的数据暴露到用户空间，使得进程不需要切换到内核态就能访问，这也是MOS的微内核设计。而这里我们要暴露的空间是UTOP以上ULIM以下的部分，也就是把这部分内存对应的内核页表拷贝到进程页表中。</p><h4 id="Ex3-5-env-alloc"><a href="#Ex3-5-env-alloc" class="headerlink" title="Ex3.5 env_alloc"></a>Ex3.5 env_alloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">env_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env **new, u_int parent_id)</span><br>&#123;<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br><br>        <span class="hljs-keyword">if</span> (LIST_EMPTY(&amp;env_free_list)) &#123; <span class="hljs-comment">//获取一个空闲进程块</span><br>                <span class="hljs-keyword">return</span> -E_NO_FREE_ENV;<br>        &#125;<br>        e = LIST_FIRST(&amp;env_free_list);<br><br>        <span class="hljs-keyword">if</span> (r = env_setup_vm(e) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//为该进程块初始化其虚拟空间</span><br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>    <br>        e-&gt;env_id = mkenvid(e);<span class="hljs-comment">//设置envid</span><br>        e-&gt;env_parent_id = parent_id; <span class="hljs-comment">//设置父子关系</span><br>        e-&gt;env_status = ENV_RUNNABLE; <span class="hljs-comment">//该函数是直接由运行程序后调用，因此直接设置状态为ENV_RUNNABLE,</span><br><br>    <span class="hljs-comment">/* Step 4: Focus on initializing the sp register and cp0_status of env_tf field, located at this new Env. */</span><br>    e-&gt;env_tf.cp0_status = <span class="hljs-number">0x10001004</span>; <span class="hljs-comment">//按要求设置相关变量</span><br>        e-&gt;env_tf.regs[<span class="hljs-number">29</span>] = USTACKTOP; <span class="hljs-comment">//设置栈指针指向用户栈，因为进程应处于用户态</span><br><br>        LIST_REMOVE(e, env_link); <br>        *new = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>e-&gt;env_tf.cp0_status = 0x10001004;</code>设置了一下几个功能<ul><li>允许用户模式下使用CP0寄存器</li><li>表示4号中断可以响应</li><li>其余设置涉及中断时的KUc，IEc拷贝后的状态（有点复杂，见指导书）</li></ul></li></ul><h3 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h3><p>​首先要明确一个概念，<strong>进程是为了执行程序创建出来的</strong>，而不是莫名其妙创建了放在那里不用。因此这一步的加载二进制镜像，就是为程序分配空间来存程序代码，让该进程凭此来执行程序。</p><h4 id="Ex3-6-load-icode-mapper"><a href="#Ex3-6-load-icode-mapper" class="headerlink" title="Ex3.6 load_icode_mapper"></a>Ex3.6 load_icode_mapper</h4><p>load_elf函数已经帮我们完成了ELF文件的解析，而我们需要将ELF文件的各个segment加载到内存中</p><p>需要考虑到<del>最恶心人</del>的的情况，个人认为这是lab3最复杂的任务之一</p><p><img src="/20220511/OSlab3%E7%AC%94%E8%AE%B0/Load_icode_mapper.png" alt="每个segment的加载地址布局"></p><ul><li>bin_size段需要用bcopy复制，而后面内容因为alloc时已经做了清零，无须再清零，完成映射即可</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">load_icode_mapper</span><span class="hljs-params">(u_long va, <span class="hljs-type">u_int32_t</span> sgsize,</span><br><span class="hljs-params">                             u_char *bin, <span class="hljs-type">u_int32_t</span> bin_size, <span class="hljs-type">void</span> *user_data)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span> =</span> (<span class="hljs-keyword">struct</span> Env *)user_data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br>u_long i;<br>    <span class="hljs-type">int</span> r, size<br>    <span class="hljs-comment">//这里是为了处理最开头处在页面一半的位置</span><br>    u_long offset = va - ROUNDDOWN(va, BY2PG);<br>        i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (offset) &#123;<br>                p = page_lookup(env-&gt;env_pgdir, va, <span class="hljs-literal">NULL</span>);<br>                <span class="hljs-keyword">if</span>(!p) &#123;<br>                        <span class="hljs-keyword">if</span> (r = page_alloc(&amp;p) &lt; <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-keyword">return</span> r;<br>                        &#125;<br>                        page_insert(env-&gt;env_pgdir, p, va, PTE_V | PTE_R);<br>                &#125;<br>                size = (BY2PG - offset &lt; bin_size)? (BY2PG - offset) : bin_size;<br>                bcopy((<span class="hljs-type">void</span>*) bin, (<span class="hljs-type">void</span>*) page2kva(p) + offset, size);<br>                i += size;<br>        &#125;<br>    <span class="hljs-comment">//复制binsize内有内容的页面</span><br>    <span class="hljs-keyword">for</span> (; i &lt; bin_size;i += BY2PG) &#123;<br>        <span class="hljs-keyword">if</span> (r = page_alloc(&amp;p) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        size = (BY2PG &lt; bin_size - i)? BY2PG : (bin_size - i); <span class="hljs-comment">//处理最后一个不完整的页面</span><br>        bcopy((<span class="hljs-type">void</span>*) (bin + i), (<span class="hljs-type">void</span>*) page2kva(p), size);<br>        <span class="hljs-keyword">if</span> (r = page_insert(env-&gt;env_pgdir, p, va + i, PTE_V | PTE_R) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//.bss段没有内容，完成页面映射以供后续使用即可</span><br>    <span class="hljs-keyword">while</span> (i &lt; sgsize) &#123;<br>        <span class="hljs-keyword">if</span> (r = page_alloc(&amp;p) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        size = (BY2PG &lt; sgsize - i)? BY2PG : (sgsize - i);<br>        <span class="hljs-keyword">if</span> (r = page_insert(env-&gt;env_pgdir, p, va + i, PTE_V | PTE_R) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        i += BY2PG;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Ex3-7-load-icode"><a href="#Ex3-7-load-icode" class="headerlink" title="Ex3.7 load_icode"></a>Ex3.7 load_icode</h4><p>​该函数主要任务是为进程创建用户栈，调用<code>load_elf</code>完成程序的复制（其中将<code>load_icode_mapper</code>传入其中，实现了其调用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, u_char *binary, u_int size)</span><br>&#123;<br>    <span class="hljs-comment">/* Hint:</span><br><span class="hljs-comment">     *  You must figure out which permissions you&#x27;ll need</span><br><span class="hljs-comment">     *  for the different mappings you create.</span><br><span class="hljs-comment">     *  Remember that the binary image is an a.out format image,</span><br><span class="hljs-comment">     *  which contains both text and data.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br>    u_long entry_point;<br>    u_long r;<br>    u_long perm;<br><br>    <span class="hljs-comment">/* Step 1: alloc a page. */</span><br>        <span class="hljs-keyword">if</span> (r = page_alloc(&amp;p) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>    <span class="hljs-comment">/* Step 2: Use appropriate perm to set initial stack for new Env. */</span><br>    <span class="hljs-comment">/* Hint: Should the user-stack be writable? */</span><br>        perm = PTE_R;<br>        <span class="hljs-keyword">if</span> (r = page_insert(e-&gt;env_pgdir, p, USTACKTOP - BY2PG, perm) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>    <span class="hljs-comment">/* Step 3: load the binary using elf loader. */</span><br>        load_elf(binary, size, &amp;entry_point, (<span class="hljs-type">void</span>*) e, load_icode_mapper);<br><br>    <span class="hljs-comment">/* Step 4: Set CPU&#x27;s PC register as appropriate value. */</span><br>    e-&gt;env_tf.pc = entry_point;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先要申请一个页面作为该进程的用户栈，用于给elf解析</li><li><code>e-&gt;env_tf.pc = entry_point;</code> <ul><li><code>e-&gt;env_tf.pc</code>这个字段指示了进程要恢复运行时 pc 应恢复到的位置</li><li>运行的进程的代码段预先被载入到了 <code>entry_ point</code> 为起点的内存中</li></ul></li></ul><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>​完成了进程块的初始化与设置和程序的载入，我们终于可以开始创建进程了！</p><p>​创建过程：分配Env进程块 + 设置进程块 + 程序载入</p><h4 id="Ex3-8-env-create-priority-amp-env-create"><a href="#Ex3-8-env-create-priority-amp-env-create" class="headerlink" title="Ex3.8 env_create_priority &amp; env_create"></a>Ex3.8 env_create_priority &amp; env_create</h4><p>​顾名思义，创建一个进程，并为其设置相应的priority</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">env_create_priority(u_char *binary, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> priority)<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br>        <span class="hljs-keyword">if</span> (env_alloc(&amp;e, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//获取一个进程块并设置好</span><br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        e-&gt;env_pri = priority; <span class="hljs-comment">//设置priority</span><br>        load_icode(e, binary, size); <span class="hljs-comment">//载入程序</span><br>        LIST_INSERT_HEAD(env_sched_list, e, env_sched_link); <span class="hljs-comment">//在创建进程后我们将其加入调度队列，等待后续的资源分配与调用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​按要求调用<code>env_create_priority</code>即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_create</span><span class="hljs-params">(u_char *binary, <span class="hljs-type">int</span> size)</span><br>&#123;<br>     <span class="hljs-comment">/* Step 1: Use env_create_priority to alloc a new env with priority 1 */</span><br>        env_create_priority(binary, size, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//printf(&quot;create end!\n&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Ex3-9-CREATE宏"><a href="#Ex3-9-CREATE宏" class="headerlink" title="Ex3.9 CREATE宏"></a>Ex3.9 CREATE宏</h4><p>​代码中已经给出了创建进程的封装好的宏命令</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENV_CREATE_PRIORITY(x, y) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">    extern u_char binary_##x##_start[];\</span><br><span class="hljs-meta">    extern u_int binary_##x##_size; \</span><br><span class="hljs-meta">    env_create_priority(binary_##x##_start, \</span><br><span class="hljs-meta">    (u_int)binary_##x##_size, y); \</span><br><span class="hljs-meta">&#125;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENV_CREATE(x) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">    extern u_char binary_##x##_start[];\</span><br><span class="hljs-meta">    extern u_int binary_##x##_size; \</span><br><span class="hljs-meta">    env_create(binary_##x##_start, \</span><br><span class="hljs-meta">    (u_int)binary_##x##_size); \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><p>​当需要创建进程来运行程序时，使用上述宏即可，如<code>ENV_CREATE_PRIORITY(user_A, 2); ENV_CREATE(user_pingpong);</code>等</p><h3 id="进程运行与切换"><a href="#进程运行与切换" class="headerlink" title="进程运行与切换"></a>进程运行与切换</h3><p>​进程能够<strong>切换</strong>是进程使操作系统效率提升的关键，使得系统资源能够合理调度。</p><p>​进程切换 &#x3D; 保存切走进程的上下文 + 恢复切入进程的上下文</p><ul><li>进程上下文说来就是一个环境，相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、内存信息等。这些内容集合成一个Trapframe，存在进程块的<code>env_tf</code>成员中。</li></ul><h4 id="Ex3-10-env-run"><a href="#Ex3-10-env-run" class="headerlink" title="Ex3.10 env_run"></a>Ex3.10 env_run</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<span class="hljs-comment">//保存切走进程的上下文，但如果不是当前运行的进程，那就没必要，因为本来就不是它</span><br>    <span class="hljs-comment">//并设置pc值为epc，因为进程切换是触发了中断的，我们完成切换要跳转到中断后的指令去</span><br>        <span class="hljs-keyword">if</span> (curenv) &#123;<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> *<span class="hljs-title">old</span>;</span><br>                old = (<span class="hljs-keyword">struct</span> Trapframe *)(TIMESTACK - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe));                bcopy((<span class="hljs-type">void</span>*) old, (<span class="hljs-type">void</span>*) &amp;(curenv-&gt;env_tf), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe));<br>                curenv-&gt;env_tf.pc = curenv-&gt;env_tf.cp0_epc;<br>        &#125;<br><span class="hljs-comment">//进行切换，将现在运行的进程切换为e</span><br>        curenv = e;<br><span class="hljs-comment">//设置全局变量mCONTEXT为当前进程的页目录地址，与TLB重填相关</span><br>        lcontext(e-&gt;env_pgdir);<br><span class="hljs-comment">//恢复切入进程的上下文，即一堆寄存器、值等的复制</span><br>        env_pop_tf(&amp;(e-&gt;env_tf), GET_ENV_ASID(e-&gt;env_id));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Ex3-11-page-init修改"><a href="#Ex3-11-page-init修改" class="headerlink" title="Ex3.11 page_init修改"></a>Ex3.11 page_init修改</h4><p>​由于我们寄存器的值保存在TIMESTACK对应的页面，如不特殊处理其可能也会被进程占用，因此要保证其安全，在page_init中进行修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = g; i &lt; npage; i++) &#123;<br>                <span class="hljs-keyword">if</span> (page2kva(&amp;pages[i]) != TIMESTACK) &#123; <span class="hljs-comment">//保证TIMESTACK对应页面不空闲，不会被占用</span><br>                        pages[i].pp_ref = <span class="hljs-number">0</span>;<br>                        LIST_INSERT_HEAD(&amp;page_free_list, &amp;(pages[i]), pp_link);<br>                &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="控制寄存器CP0"><a href="#控制寄存器CP0" class="headerlink" title="控制寄存器CP0"></a>控制寄存器CP0</h4><table><thead><tr><th>寄存器助记符</th><th>CP0寄存器编号</th><th>描述</th></tr></thead><tbody><tr><td>SR</td><td>12</td><td>状态寄存器，包括中断引脚使能，其他 CPU 模式等位域</td></tr><tr><td>Cause</td><td>13</td><td>记录导致异常的原因</td></tr><tr><td>EPC</td><td>14</td><td>异常结束后程序恢复执行的位置</td></tr></tbody></table><ul><li>SR 寄存器：15-8 位为中断屏蔽位，每一位代表一个不同的中断活动，其中 15-10 位使能外部中断源，9-8 位是 Cause 寄存器软件可写的中断位。</li><li>Cause 寄存器：其中保存着 CPU 中哪一些中断或者异常已经发生。15-8 位保存着哪一些中断发生了，其中 15-10 位来自硬件，9-8 位可以由软件写入，当 SR 寄存器中相同位允许中断（为 1）时，Cause 寄存器这一位活动就会导致中断。6-2 位（ExcCode），记录发生了什么异常。</li></ul><h4 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h4><ol><li>设置 EPC 指向异常结束时重新返回的地址。</li><li>设置 SR 位，强制 CPU 进入内核态（行驶更高级的特权）并禁止中断。</li><li>设置 Cause 寄存器，用于记录异常发生的原因。</li><li>CPU 开始从异常入口位置取指，此后一切交给软件处理。</li></ol><p><img src="/20220511/OSlab3%E7%AC%94%E8%AE%B0/3-exception.png" alt="异常处理图示"></p><p>软件处理就是我们接下来要完成的东西：）</p><h3 id="异常分发"><a href="#异常分发" class="headerlink" title="异常分发"></a>异常分发</h3><p>​异常分发代码流程如下：</p><ol><li>将 CP0_CAUSE 寄存器的内容拷贝到 k1 寄存器中。</li><li>将 execption_handlers 基地址拷贝到 k0。</li><li>取得 CP0_CAUSE 中的 2~6 位，也就是对应的异常码，这是区别不同异常的重要标志。</li><li>以得到的异常码作为索引去 exception_handlers 数组中找到对应的中断处理函数，后文中会有涉及。</li><li>跳转到对应的中断处理函数中，从而响应了异常，并将异常交给了对应的异常处理函数去处理。</li></ol><h4 id="Ex3-12-异常分发代码"><a href="#Ex3-12-异常分发代码" class="headerlink" title="Ex3.12 异常分发代码"></a>Ex3.12 异常分发代码</h4><p>​操作如上（添加至boot&#x2F;start.S中）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.section .text.exc_vec3<br>NESTED(except_vec3, 0, sp)<br>    .set noat <br>    .set noreorder<br>1:<br>    mfc0 k1,CP0_CAUSE<br>    la k0,exception_handlers<br>    andi k1,0x7c<br>    addu k0,k1<br>    lw k0,(k0)<br>    nop<br>    jr k0<br>    nop<br>END(except_vec3)<br>.set at<br></code></pre></td></tr></table></figure><h4 id="Ex3-13-异常代码分发跳转"><a href="#Ex3-13-异常代码分发跳转" class="headerlink" title="Ex3.13 异常代码分发跳转"></a>Ex3.13 异常代码分发跳转</h4><p>​<code>.text.exc_vec3</code> 段需要被链接器放到特定的位置，在 R3000 中这一段是要求放到地址 0x80000080 处，这个地址处存放的是异常处理程序的入口地址。一旦 CPU 发生异常，就会自动跳转到地址 0x80000080 处，开始执行。(添加至tools&#x2F;scse0_3.lds中)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">. = 0x80000080;<br>.except_vec3 : &#123;<br>    *(.text.exc_vec3)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常向量组"><a href="#异常向量组" class="headerlink" title="异常向量组"></a>异常向量组</h3><p>​<code>exception_handlers</code>称作异常向量组，用于跳转到不同异常的处理程序中</p><p>​lib&#x2F;traps.c中的trap_init函数实现了对全局变量 exception_handlers[32] 数组初始化的工作，即通过把相应处理函数的地址填到对应数组项中，初始化了如下异常：</p><ul><li><strong>0 号异常</strong>的处理函数为<code>handle_int</code>，表示中断，由时钟中断、控制台中断等中断造成</li><li><strong>1 号异常</strong>的处理函数为<code>handle_mod</code>，表示存储异常，进行存储操作时该页被标记为只读</li><li><strong>2 号异常</strong>的处理函数为<code>handle_tlb</code>，TLB 异常，TLB 中没有和程序地址匹配的有效入口</li><li><strong>3 号异常</strong>的处理函数为<code>handle_tlb</code>，TLB 异常，TLB 失效，且未处于异常模式（用于提高处理效率）</li><li><strong>8 号异常</strong>的处理函数为<code>handle_sys</code>，系统调用，陷入内核，执行了 syscall 指令</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handle_int</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handle_reserved</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handle_tlb</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handle_sys</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handle_mod</span><span class="hljs-params">()</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> exception_handlers[<span class="hljs-number">32</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trap_init</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>        set_except_vector(i, handle_reserved);<br>    &#125;<br><br>    set_except_vector(<span class="hljs-number">0</span>, handle_int);<br>    set_except_vector(<span class="hljs-number">1</span>, handle_mod);<br>    set_except_vector(<span class="hljs-number">2</span>, handle_tlb);<br>    set_except_vector(<span class="hljs-number">3</span>, handle_tlb);<br>    set_except_vector(<span class="hljs-number">8</span>, handle_sys);<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">set_except_vector</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">void</span> *addr)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> handler = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)addr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> old_handler = exception_handlers[n];<br>    exception_handlers[n] = handler;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)old_handler;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h3><p>​前面只是初步涉及到了异常的处理，但我们核心的任务在于中断的处理，因为操作系统的<strong>时间片</strong>运行、进程切换都是依托于时钟中断来实现的，因此十分重要。</p><h4 id="中断的处理流程"><a href="#中断的处理流程" class="headerlink" title="中断的处理流程"></a>中断的处理流程</h4><ol><li>将当前 PC 地址存入 CP0 中的 EPC 寄存器。</li><li>将 IEc,KUc 拷贝至 KUp 和IEp 中，同时将 IEc 置为 0，表示关闭全局中断使能，将 KUc 置 1，表示处于内核态。</li><li>在 Cause 寄存器中，保存 ExcCode 段。由于此处是中断异常，对应的异常码即为 0。</li><li>PC 转入异常分发程序入口。</li><li>通过异常分发，判断出当前异常为中断异常，随后进入相应的中断处理程序。在MOS 中即对应 handle_int 函数。</li><li>在中断处理程序中进一步判断 CP0_CAUSE 寄存器中是由几号中断位引发的中断，然后进入不同中断对应的中断服务函数。</li><li>中断处理完成，将 EPC 的值取出到 PC 中，恢复 SR 中相应的中断使能，继续执行。</li></ol><p>其中1-4以及第7步已由CPU完成，5-6步则需要我们来实现完成时钟中断（其实也就一点点需要我们来做</p><h4 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h4><p>​时钟中断和操作系统的时间片轮转算法是紧密相关的。时间片轮转调度是一种很公平的算法。每个进程被分配一个时间段，称作它的<strong>时间片</strong>，即该进程允许运行的时间。<strong>如果在时间片结束时进程还在运行，则该进程将挂起，切换到另一个进程运行。</strong>那么 CPU是如何知晓一个进程的时间片结束的呢？就是<strong>通过定时器产生的时钟中断。当时钟中断产生时，当前运行的进程被挂起，我们需要在调度队列中选取一个合适的进程运行。</strong>如何“选取”，就要涉及到进程的调度了。</p><h4 id="时钟中断的模拟"><a href="#时钟中断的模拟" class="headerlink" title="时钟中断的模拟"></a>时钟中断的模拟</h4><p>kclock_init 函数完成了时钟的初始化，该函数主要调用 set_timer 函数，完成如下操作：</p><ul><li>首先向0xb5000100 位置写入0xc8，其中0xb5000000 是模拟器(gxemul) 映射实时钟的位置。偏移量为0x100 表示来设置实时钟中断的频率，0xc8 则表示1 秒钟中断200次，如果写入0，表示关闭实时钟。实时钟对于R3000 来说绑定到了4 号中断上，故这段代码其实主要用来触发了<strong>4 号中断</strong>。</li><li>一旦实时钟中断产生，就会触发MIPS 中断，从而MIPS 将PC 指向0x80000080，从而跳转到.text.exc_vec3代码段执行。对于实时钟引起的中断，通过.text.exc_vec3代码段的分发，最终会调用handle_ int 函数来处理实时钟中断。</li><li>在handle_ int 判断CP0_CAUSE寄存器是不是对应的4 号中断位引发的中断，如果是，则执行中断服务函数timer_ irq(在genex.S)。</li><li>在timer_ irq 里直接跳转到sched_ yield 中执行。而这个函数就是我们将要补充的调度函数，后面会完成。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">timer_irq:<br><br>        sb zero, 0xb5000110<br>1:      j       sched_yield<br>        nop<br>        /*li t1, 0xff<br>        lw    t0, delay<br>        addu  t0, 1<br>        sw      t0, delay<br>        beq     t0,t1,1f        <br>        nop*/<br>        j       ret_from_exception<br>        nop<br></code></pre></td></tr></table></figure><h4 id="Ex3-14-kclock-init"><a href="#Ex3-14-kclock-init" class="headerlink" title="Ex3.14 kclock_init"></a>Ex3.14 kclock_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">kclock_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-comment">// hint: use set_timer()</span><br>        set_timer();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>​handle_int 函数的最后跳转到了 sched_ yield 函数执行调度，调度的算法很简单，就是时间片轮转的算法。</p><h4 id="Ex3-15-sched-c"><a href="#Ex3-15-sched-c" class="headerlink" title="Ex3.15 sched.c"></a>Ex3.15 sched.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env_list</span> <span class="hljs-title">env_sched_list</span>[];</span><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span>* <span class="hljs-title">curenv</span>;</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sched_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// remaining time slices of current env</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> point = <span class="hljs-number">0</span>; <span class="hljs-comment">// current env_sched_list index</span><br>        <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span> =</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span> (count &lt;= <span class="hljs-number">0</span> || env == <span class="hljs-literal">NULL</span> || (env != <span class="hljs-literal">NULL</span> &amp;&amp; env-&gt;env_status != ENV_RUNNABLE)) &#123;<br>                count = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (env != <span class="hljs-literal">NULL</span>) &#123;<br>                        LIST_REMOVE(env, env_sched_link);<br>                        <span class="hljs-keyword">if</span> (env-&gt;env_status != ENV_FREE) &#123;<br>                                LIST_INSERT_TAIL(&amp;env_sched_list[<span class="hljs-number">1</span>-point], env, env_sched_link);<br>                        &#125; <br>                &#125;<br>                <span class="hljs-keyword">if</span> (LIST_EMPTY(&amp;env_sched_list[point])) &#123;<br>                        point = <span class="hljs-number">1</span> - point;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (LIST_EMPTY(&amp;env_sched_list[point])) &#123;<br>                        <span class="hljs-comment">//panic(&quot;^^^^^^^there is no runnable env^^^^^^^by sched_yield&quot;);</span><br>                        <span class="hljs-keyword">continue</span>; <br>                &#125;<br>                env = LIST_FIRST(&amp;env_sched_list[point]);<br>                <span class="hljs-keyword">if</span> (env != <span class="hljs-literal">NULL</span>) &#123;<br>                        count = env-&gt;env_pri;<br>                &#125;<br>        &#125;<br>        count--;<br>        env_run(env);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我们规定其数值表示进程每次运行的时间片数量</li><li>用两个链表存储所有参与调度进程。当进程被创建时，我们要将其插入第一个进程调度链表的头部。调用 sched_yield函数时，先判断当前时间片是否用完。如果用完，将其插入另一个进程调度链表的尾部。之后判断当前进程调度链表是否为空。如果为空，切换到另一个进程调度链表。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统实验笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OO第二单元总结</title>
    <link href="/20220503/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/20220503/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="OO第二单元总结"><a href="#OO第二单元总结" class="headerlink" title="OO第二单元总结"></a>OO第二单元总结</h1><h2 id="一、作业介绍"><a href="#一、作业介绍" class="headerlink" title="一、作业介绍"></a>一、作业介绍</h2><h3 id="（一）作业背景及迭代"><a href="#（一）作业背景及迭代" class="headerlink" title="（一）作业背景及迭代"></a>（一）作业背景及迭代</h3><p>​本单元的核心是模拟<strong>多线程实时电梯系统</strong>，总共有A~E五栋楼，各拥有10层。要求设计一个电梯调度系统，采用<strong>一定的调度策略</strong>，用以<strong>实时</strong>响应可以在任意时间发出的电梯搭乘请求，具体需要模拟实现电梯的上下行、开关门以及进出人。</p><ul><li>三次作业介绍<ul><li>第一次作业：五座楼各有一个属性确定的纵向电梯，初始时停在一层。题目要求系统能响应仅为同一座楼的搭乘请求。</li><li>第二次作业：新增了横向电梯的概念，能在A~E座间以环形顺&#x2F;逆时针方向运动。同时新增了可添加纵向&#x2F;横向电梯的ADD指令，要求系统能响应仅为同一座楼或同一层楼的搭乘请求，需注意横向搭乘请求只会出现于有横向电梯的楼层。</li><li>第三次作业： 电梯可通过ADD指令定制运行时间和载客数量，同时横向电梯增加了可达性的设置，即横向电梯仅在规定的楼座可以开门。要求系统能够响应任意的搭乘请求，即要求实现<strong>转乘</strong>功能，乘客可能乘坐不止一部电梯来达到目的地。</li></ul></li></ul><h3 id="（二）训练目的"><a href="#（二）训练目的" class="headerlink" title="（二）训练目的"></a>（二）训练目的</h3><p>​通过这一单元的学习，初步掌握<strong>多线程</strong>概念及其设计方式，了解常见的多线程设计模式、不同线程间的交互方式，并同时学习线程安全知识和锻炼解决线程安全问题的能力。</p><h2 id="二、作业分析"><a href="#二、作业分析" class="headerlink" title="二、作业分析"></a>二、作业分析</h2><h3 id="（一）同步块与锁"><a href="#（一）同步块与锁" class="headerlink" title="（一）同步块与锁"></a>（一）同步块与锁</h3><p>​为什么需要同步块与锁？在多线程程序中，如若不同线程<strong>无限制</strong>地访问同一共享资源，便可能会由于操作被打断等情况导致<strong>线程安全问题</strong>，因此我们需要用到锁来设置同步块，以保证在某一线程访问该同步块时获取到锁，避免被其他线程干扰，访问先后有序，从而保证线程的安全。要保证线程安全，我们要认识到<strong>原子操作</strong>这一概念，类似于量子的概念，即该块的操作应被看作为一个整体，不应在执行过程中被其他线程而中断，这样保证了功能的正确实现，而<strong>锁与同步块的作用就是将块中的处理语句包装成原子操作</strong>，形成一个整体。</p><p>​在笔者的架构种中，仿造了实验代码设计了一个**请求队列共享类<code>RequestQueue</code>**，用<code>synchronized</code>锁对该队列的<code>addRequest、getRequest</code>方法加锁设置了同步块，保证了请求投喂线程和请求处理线程对该共享队列访问的线程安全。该类在架构中实现了输入线程<code>InputThread</code>和调度器<code>Schedule</code>间的待分配队列<code>waitQueue</code>，以及调度器<code>Schedule</code>和电梯<code>Elevator</code>间的任务队列<code>requestQueue</code>。</p><p>​除此之外，在hw6和hw7中，出现了添加电梯的ADD指令，使得任务队列<code>requestQueue</code>会动态增加，因此笔者设计了共享类<code>QueueList</code>，根据读取队列操作远多于添加新队列操作，笔者尝试采用了读写锁<code>ReentrantReadWriteLock</code>，为添加新队列操作加上了写锁<code>writeLock</code>，为读取队列操作加上了读锁<code>readLock</code>，既保证了多个队列管理的线程安全，又在定程度上提升了不同线程的访问效率。</p><h3 id="（二）调度器设计"><a href="#（二）调度器设计" class="headerlink" title="（二）调度器设计"></a>（二）调度器设计</h3><ul><li><p>笔者的作业主要采用了<strong>生产者-消费者模式</strong>，大体上线程分为三种：**<code>InputThread输入线程-Schedule调度线程-Elevator处理线程</code><strong>，三种线程依托于前文说到的</strong>请求队列共享类<code>RequestQueue</code>**实现线程交互。</p><ul><li><p><code>InputThread输入线程</code>：从输入中读取指令，一方面实现电梯添加的ADD指令，另一方面将所以搭乘指令添加到与<code>Schedule线程</code>共享的等待分配的请求队列<code>waitQueue</code>中。</p></li><li><p><code>Schedule调度线程</code>：笔者采用了<strong>单调度器的架构</strong>，即有且仅有的一个<strong>全局调度器<code>Schedule</code><strong>不断从<code>waitQueue</code>获取待分配的请求，通过调度器策略，将这些请求发放到各个电梯自己的请求队列<code>requestQueue</code>中去，从而实现调度。除此之外，在hw7中，Schedule线程还承担了为需</strong>换乘指令</strong>分解乘坐步骤，为其分段分配电梯的角色。</p></li><li><p><code>Elevator处理线程</code>：该线程功能纯粹，即不断从自己的requestQueue获取发配给自己的请求，对请求做出响应，模拟实现上下楼、开关门和进出人。</p></li></ul></li><li><p>调度器策略分析与设计</p><ul><li><strong>hw5</strong>中各座楼仅且仅有自己的一部电梯，因此调度器Schedule只需判断各请求所在的楼，将其加入各座楼相应的请求队列即可。</li><li><strong>hw6</strong>中出现了横纵电梯以及多电梯竞争的情况，在实现了区分横向请求与纵向请求后，笔者采用了平均分配方式，即基准策略中第一个乘客给第一部电梯，第二个乘客给第二部电梯……如此类推下去的方式。</li><li><strong>hw7</strong>的主要重难点在于请求可能需要换乘，需要有调度器来实现该乘客的搭乘策略，从而成功到达目的地。<ul><li>换乘策略：题目背景中规定了初始在一层中有一部可达所有座的横向电梯，因此保证了任何请求一定可以在不大于三次的乘坐电梯后到达目的地。基于此，笔者设计了一种<strong>依托于请求本身信息、最多乘坐一次横向电梯</strong>的转乘调度策略。在官方包原有PersonRequest拥有的域基础上，笔者为每个Request添加了五个域curBuilding、curFloor、dirBuilding、dirFloor、M，表示该请求的乘客当前所在位置、下一步搭乘一次电梯所能到达的<strong>短期目的地</strong>以及调度器为他找寻的中转楼层M。<ul><li>调度逻辑如图<img src="/20220503/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/%E8%BD%AC%E4%B9%98%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png"></li></ul></li><li>除此之外，在了解到hw6中许多同学使用自由竞争获得了高分后，笔者在hw7中也抛弃了平均策略而采用了自由竞争，即同一层楼或同一座楼的电梯共享同一个请求队列，而非一部电梯一个队列，使得电梯可以自己去<strong>“抢请求”</strong>，但没想到这一改动与横向电梯可达性结合后出现了意料之外的bug，这一点会在后面bug分析中详细解释。</li></ul></li></ul></li></ul><h3 id="（三）架构分析与总结"><a href="#（三）架构分析与总结" class="headerlink" title="（三）架构分析与总结"></a>（三）架构分析与总结</h3><ul><li><p>三次作业类图及其迭代</p><ul><li>hw5：基础架构，仿照了实验代码，核心为输入、调度、处理三大线程<ul><li><img src="/20220503/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/5-16515503866761.png"></li></ul></li><li>hw6：相较于hw5，新增了QueueList类用于同一管理多个电梯的请求队列，调度器<strong>给电梯发放任务</strong>的过程由原来的直接投放到对应电梯变为：先由QueueList获取相应电梯的请求队列，再将请求插入该请求队列中。另外，按照作业要求，给InputThread新增了<strong>创建新电梯线程</strong>的能力。<ul><li><img src="/20220503/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/6-16515503965242.png"></li></ul></li><li>hw7：为实现前文所说的hw7调度器设计，自己新增了原官方包中PersonRequest类的升级版Req类，另外给ELevator开放了将<strong>未</strong>到达目的地的请求重新加入waitQueue的权利。除以上两点，其余设计均大体相同。<ul><li><img src="/20220503/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/7.png"></li></ul></li></ul></li><li><p>未来拓展能力：在上述架构中，各部分结构的功能划分鲜明，生产者与消费者角色有着明显区分，程序的可拓展性强。例如若给纵向电梯加入可达性限定，只需给电梯加上纵向可达性Info即可；在比如一个乘客可能需要依次到达多个地方，只需修改Req的存储结构以及升级调度器Schedule的调度模式即可。</p></li><li><p>UML协作图：具体介绍见前文调度器设计</p><ul><li><img src="/20220503/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/SequenceDiagram1-16515514540643.png"></li></ul></li></ul><h2 id="三、bug分析"><a href="#三、bug分析" class="headerlink" title="三、bug分析"></a>三、bug分析</h2><h3 id="（一）自己的bug"><a href="#（一）自己的bug" class="headerlink" title="（一）自己的bug"></a>（一）自己的bug</h3><p>笔者的bug全出现在第七次作业中，都是由于<strong>横向电梯可达性</strong>这一设定导致。</p><ul><li>①只用了一个int变量<code>switchInfo</code>来记录该层的可达性，有新电梯加入时通过或运算来更新该层的<code>switchInfo</code>，这样导致或运算合并后，本应需要搭乘两次横向电梯才可到达的情况显现成了只需搭乘一次，又由于笔者采用的架构是<strong>最多乘坐一次横向电梯</strong>，因此可能会导致给某一请求设置了不合理的中转楼层，导致该请求在进入中转楼层的等待队列后，无法被处理，最终导致任务未完成，程序亦无法正常结束。修复方法是新建一个容器用于存放不同的switchInfo，在查询时遍历该容器即可。</li><li>②在原本的程序中，如若<strong>请求队列为空</strong>且<strong>电梯载客为空</strong>则调用wait释放CPU资源，但在横向电梯有可达性的设定下，加之hw7中笔者改用了多个电梯共享一个请求队列的自由竞争，出现了请求队列不为空，但横向电梯却无法获取到可响应的请求的情况。笔者没有考虑到这一点，这导致了该横向电梯会<strong>连续不断</strong>地向请求队列中尝试获取一个可响应的请求，但总是无功而返，从而使得CPU不断被占用，最终导致了CTLE的错误出现。对此的修正方法是，若该电梯未能获取到可响应的请求且目前电梯未载人，则wait释放资源，避免占用。</li></ul><h3 id="（二）互测"><a href="#（二）互测" class="headerlink" title="（二）互测"></a>（二）互测</h3><p>第二单元中笔者仍旧使用了手搓数据的互测方式，针对某一可能出现bug的特点进行数据构造。</p><ul><li>hw5整体来说较为基础，可能产生的bug不对，笔者主要针对的同学们未能留意到的<strong>输出时间戳需保证时间顺序</strong>这一要求，在同一时间点给入大量请求，以此检验是否会出现时间戳不递增的bug。</li><li>hw6出错的可能性亦不大，主要是检验横向电梯的功能正确性， 给如大量的横向搭乘请求，从而检验其能否正确完成任务。</li><li>hw7较为复杂，笔者大体针对两个方面。一是就横向电梯的可达性限制进行测试，检查是否有不可达导致的上下人错误以及陷入无法结束的错误；二是就转乘进行测试，构造一般三段式转乘以及可能优化后使用更多次转乘的数据，检验其正确性。</li></ul><p>相较于第一单元的碰运气测试，第二单元的数据构造更具有针对性，从结果来看，这样的策略算是较为成功。</p><h2 id="四、心得体会"><a href="#四、心得体会" class="headerlink" title="四、心得体会"></a>四、心得体会</h2><p>​通过这个单元对多线程的学习，我深刻体会到了多线程间交互、合理分配系统资源的巧妙与优美，了解到许多的设计思路与模式，同时也遇到了本单元最核心的线程安全问题，为此没有少掉头发，但在成功保证了自身程序的线程安全性后的成就感也是无以伦比的。除此之外，我还深刻认识到了正确性检验的重要性，一开始拥有优美简洁的设计固然重要，但在程序完成后的测试环节亦必不可少，编程中的手误、思维上的漏洞，这些bug往往难以直接观察代码发现，通过测试发现bug后逆向寻因，才效率最高，也更大程度上保证了程序的正确性。</p><p>​总体来说，这个单元的学习令我大开眼界，受益良多，学习到了以往许多未曾接触到的新知识，OO越学越发现其意义之非凡，接下来的OO学习我亦要继续努力。感谢老师和助教们的辛勤付出！</p>]]></content>
    
    
    <categories>
      
      <category>面向对象单元总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSlab2实验报告</title>
    <link href="/20220428/OSlab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/20220428/OSlab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="lab2实验报告"><a href="#lab2实验报告" class="headerlink" title="lab2实验报告"></a>lab2实验报告</h2><h4 id="1-实验思考题"><a href="#1-实验思考题" class="headerlink" title="1.实验思考题"></a>1.实验思考题</h4><h5 id="Thinking2-1"><a href="#Thinking2-1" class="headerlink" title="Thinking2.1"></a>Thinking2.1</h5><blockquote><ul><li><strong>在我们编写的程序中，指针变量中存储的地址是虚拟地址还是物理地址？</strong></li><li><strong>MIPS 汇编程序中lw, sw使用的是虚拟地址还是物理地址？</strong></li></ul></blockquote><ul><li>在我们编写的程序中，指针变量存储的地址是<strong>虚拟地址</strong>，因为R3000 CPU只会发出虚拟地址。</li><li>MIPS汇编程序中lw，sw使用的是<strong>物理地址</strong>，因为汇编直接作用于实际的物理部件。</li></ul><h5 id="Thinking2-2"><a href="#Thinking2-2" class="headerlink" title="Thinking2.2"></a>Thinking2.2</h5><blockquote><ul><li><strong>请从可重用性的角度，阐述用宏来实现链表的好处。</strong></li><li>请你查看实验环境中的 &#x2F;usr&#x2F;include&#x2F;sys&#x2F;queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</li></ul></blockquote><ul><li>用宏实现链表的好处：可重用性高，在编写过程中，我们通过head和field这两个参数来确定这个链表的读取，这样使得我们在需要创建同样类型的链表时，只需确定好head和field就可以很方便得建好一个新的链表，而无需再专门为一个新变量写一大堆删除、新增等操作，即减少了代码耦合度，又减轻了程序员的编程压力。</li><li>链表总结<ul><li>种类<ul><li><p>List</p><ul><li>头指针指向第一个元素</li><li>指向下一元素的指针*le_next、指向上一元素le_next指针的指针**le_prev</li></ul></li><li><p>Singly-linked List </p><ul><li>头指针指向第一个元素</li><li>指向下一元素的指针*sle_next</li></ul></li><li><p>Singly-linked Tail queue </p><ul><li>头指针指向第一个元素、指向最后一个元素的next指针的指针</li><li>指向下一元素的指针*stqe_next</li></ul></li><li><p>Simple queue（好像和Singly-linked Tail queue相同？）</p><ul><li>头指针指向第一个元素、指向最后一个元素的next指针的指针</li><li>指向下一元素的指针*sqe_next</li></ul></li><li><p>Tail queue</p><ul><li>头指针指向第一个元素、指向最后一个元素的next指针的指针</li><li>指向下一元素的指针*tqe_next、指向上一元素的指针<code>*tqe_prev</code></li></ul></li><li><p>Circular queue</p><ul><li>头指针指向第一个元素、指向最后一个元素</li><li>指向下一元素的指针*cqe_next、指向上一元素的指针<code>*cqe_prev</code></li></ul></li></ul></li><li>对比：本实验双向链表、单向链表、循环链表<ul><li>结构：本实验中的双向链表的元素可以访问后一元素以及前一元素的next指针，单向链表只能访问后一元素，而循环链表则能访问前后两元素，而且首位元素通过head指针相接</li><li>插入操作：单向链表由于不能访问前一元素，因此只能在一元素后进行插入操作，而双向链表和循环链表则都可以实现在元素前、后进行插入操作，但本实验的双向链表在于记录的是<strong>前一元素的next指针的指针</strong>，因此在插入操作时<strong>相比于循环链表和普通双向链表</strong>，将<strong>访问前一元素-&gt;访问next指针</strong>，优化为了<strong>直接访问前一元素的next指针</strong>进行修改，实现了效率上的优化。但代价是该种双向链表<strong>丢失了访问前一元素本身内容的功能</strong>，而循环链表则能正常访问。</li><li>删除操作：单向链表的删除过程是<strong>在链表中找到待删元素的上一个元素的位置-&gt;删除待删元素</strong>，时间在循环<strong>找到待删元素位置时</strong>有大量<strong>损耗</strong>；而双向链表和循环链表则可以通过修改前后的指针来实现元素删除，其中效率的差异则<strong>与插入操作的相同</strong>。</li></ul></li></ul></li></ul><h5 id="Thinking2-3"><a href="#Thinking2-3" class="headerlink" title="Thinking2.3"></a>Thinking2.3</h5><blockquote><p><strong>请阅读 <code>include/queue.h</code> 以及 <code>include/pmap.h</code>, 将 <code>Page_list</code> 的结构梳理清楚，选择正确的展开结构。</strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page_list</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">le_next</span>;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> **<span class="hljs-title">le_prev</span>;</span><br>        &#125; pp_link;<br>        u_short pp_ref;<br>    &#125;* lh_first;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>pp_link</code>是Page_list元素的一个域，包含了指向list下一元素的指针<code>le_next</code>以及指向list上一元素的<code>*le_next</code> 的指针<code>**le_prev</code>，<code>pp_ref</code>是一个记录被引用次数的域，<code>*lh_first</code>是一个链表的头指针</li></ul><h5 id="Thinking2-4"><a href="#Thinking2-4" class="headerlink" title="Thinking2.4"></a>Thinking2.4</h5><blockquote><p><strong>请你寻找上述两个 boot_* 函数在何处被调用。</strong></p></blockquote><ul><li><code>boot_pgdir_walk</code> 在<code>boot_map_segment</code>中被调用，<code>boot_map_segment</code>在<code>mips_vm_init</code>中被调用。</li><li><code>boot_pgdir_walk</code>用于获取虚拟地址va对应的二级页表项，<code>boot_map_segment</code>用于将va对应的size大小的虚拟地址区间映射到pa对应的size大小的物理地址区间。</li></ul><h5 id="Thinking2-5"><a href="#Thinking2-5" class="headerlink" title="Thinking2.5"></a>Thinking2.5</h5><blockquote><ul><li>请阅读上面有关 R3000-TLB 的叙述，从虚拟内存的实现角度，阐述 ASID 的必要性</li><li>请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID 段的位数，说明 R3000 中可容纳不同的地址空间的最大数量</li></ul></blockquote><ul><li>因为不同进程的虚拟空间相互独立，即<strong>不同进程间</strong>的同一虚拟会映射到不同的物理地址，此时<strong>必须</strong>通过ASID来区分不同进程间各自的地址空间，保证虚拟空间与物理空间的正确映射.</li><li><code>the OS assigns a 6-bit unique code to each task’s distinct address space.</code>操作系统提供了6位的ASID独特编码，即最大可容纳<strong>64个</strong>不同的地址空间</li></ul><h5 id="Thinking2-6"><a href="#Thinking2-6" class="headerlink" title="Thinking2.6"></a>Thinking2.6</h5><blockquote><p>请你完成如下三个任务</p><ul><li>tlb_invalidate 和 tlb_out 的调用关系是怎样的？</li><li>请用一句话概括 tlb_invalidate 的作用</li><li>逐行解释 tlb_out 中的汇编代码</li></ul></blockquote><ul><li><p><code>tlb_invalidate</code>调用<code>tlb_out</code></p></li><li><p><code>tlb_invalidate</code>的作用是令原本的虚拟地址与对应的tlb表项映射失效，从而使下次访问该虚拟地址时触发tlb充填。</p></li><li><pre><code class="c">LEAF(tlb_out)//1: j 1bnop        mfc0    k1,CP0_ENTRYHI  //将CP0_ENTRYHI寄存器的值存入k1寄存器        mtc0    a0,CP0_ENTRYHI  //给CP0_ENTRYHI寄存器写入当前虚拟地址        nop        tlbp  //根据EntryHi中的Key查找TLB中对应的项，并将表项的索引存入Index寄存器        nop        nop        nop        nop        mfc0    k0,CP0_INDEX   //将Index寄存器中存的表项存入k0寄存器中        bltz    k0,NOFOUND   //若没找到匹配的表项，则跳转至NOFOUND标签处        nop        mtc0    zero,CP0_ENTRYHI  //若找到，清零CP0_ENTRYHI寄存器        mtc0    zero,CP0_ENTRYLO0 //若找到，清零CP0_ENTRYLO寄存器        nop        tlbwi  //以Index寄存器值为索引，将ENTRYHI和ENTRYLO写入对应TLB表项，使得以后访问会诱发TLB填充NOFOUND:        mtc0    k1,CP0_ENTRYHI  //没找到对应表项，恢复ENTRYHI寄存器原本的值        j       ra        nopEND(tlb_out)</code></pre></li></ul><h5 id="Thinking2-7"><a href="#Thinking2-7" class="headerlink" title="Thinking2.7"></a>Thinking2.7</h5><blockquote><p>**在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为 8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 &#x3D; 39 位就可以实现三级页表机制，并不需要 64 位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若记三级页表的基地址为 PTbase ，请你计算：</p><ul><li><strong>三级页表页目录的基地址</strong></li><li><strong>映射到页目录自身的页目录项(自映射)</strong></li></ul></blockquote><ul><li>三级页表页目录的基地址<ul><li>页目录偏移量<code>PTbase &gt;&gt; 12 &lt;&lt; 3 = PTbase &gt;&gt; 9</code>，因此页目录基地址为 <code>PTbase + (PTbase &gt;&gt; 9)</code></li></ul></li><li>映射到页目录自身的页目录项<ul><li><code>PTbase + (PTbase &gt;&gt; 9) + (PTbase &gt;&gt; 18) + (PTbase &gt;&gt; 27)</code></li></ul></li></ul><h5 id="Thinking2-8"><a href="#Thinking2-8" class="headerlink" title="Thinking2.8"></a>Thinking2.8</h5><blockquote><p>简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。</p></blockquote><ul><li>x86体系结构的内存管理机制<ul><li>x86主要使用<strong>分段</strong>和<strong>分页</strong>对内存进行管理，地址有三个，分别为<strong>逻辑地址</strong>、<strong>线性地址</strong>和<strong>物理地址</strong>，其中逻辑地址通过分段转换为线性地址，然后线性地址通过分页转换为物理地址</li></ul></li><li>MIPS则是只有虚拟地址和物理地址，通过<strong>分页</strong>在两种地址间建立映射。</li></ul><h4 id="2-实验难点图示"><a href="#2-实验难点图示" class="headerlink" title="2.实验难点图示"></a>2.实验难点图示</h4><p>①<strong>双向链表</strong>结构</p><ul><li><img src="/20220428/OSlab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/lab2-macro-list.svg+xml" alt="lab2-macro-list.svg"></li><li>与普通的双向链表不同，le_prev指向的是前一个元素的le_next指针的指针，这样的目的是可以在删除一个元素时<strong>节省一次offset的计算</strong></li><li>同时，双重指针可以解决头指针指向类型与元素类型不同的问题</li></ul><p>②页表自映射</p><p><img src="/20220428/OSlab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/%E9%A1%B5%E8%A1%A8%E8%87%AA%E6%98%A0%E5%B0%84.jpg"></p><p>③部分函数解释</p><ul><li><p>使用 <code>tlb_invalidate</code> 函数可以实现删除特定虚拟地址的映射，每当页表被修改，就需要调用该函数以保证下次访问该虚拟地址时诱发 TLB 重填以保证访存的正确性。</p></li><li><p>static Pte *boot_pgdir_walk(Pde *pgdir, u_long va, int create)，它返回一级页表基地址 pgdir 对应的两级页表结构中，va 这个虚拟地址所在的二级页表项，如果 create 不为 0 且对应的二级页表不存在则会使用 alloc 函数分配一页物理内存用于存放。</p></li><li><p><code>page2pa</code>和<code>pa2page</code>：page是一种存储页面的结构体，如若要访问具体页面，需要先求得该页面的物理地址，通过<code>page2pa</code>和<code>pa2page</code>实现</p></li><li><p><code>page2kva</code>是把<code>struct PageInfo</code>转成虚拟地址，内部调用<code>page2pa</code>和<code>KADDR</code></p></li><li><p>bzero(page2kva(ppage_temp), BY2PG)——将该段虚拟内存清零</p></li></ul><h4 id="3-体会与感想"><a href="#3-体会与感想" class="headerlink" title="3.体会与感想"></a>3.体会与感想</h4><p>​通过lab2的学习，我得以进一步窥见操作系统的框架。在我看来，操作系统是宏观与微观的结合，不同与以往的算法题，实现OS的任务，并不如表面那样直接明晰，而是需要经过递归嵌套将其划分成诸多细微的步骤，不断拼凑才得以初步构建出操作系统的模型。因此，在学习的过程往往需要面对繁杂而琐碎的知识，必须在搞清楚每一细节的实现手法的同时，能够抽离出来从宏观去进行整合和理解，不然就会陷入记忆混乱亦或是不明所以的窘境之中。</p><p>​lab2的上机遭遇了大失败，一共就只做出了一个exam，我想这或许就是由于我没能从宏观上对知识进行整理和归纳，导致了在上机时总是着重与某一函数的使用与修改，而不能从操作系统实现功能的角度出发去设计程序。对此，我要对各个lab的知识进行记录和总结归纳，时常去复习，如此才能总整体上熟练运用所学知识，同时也避免再陷入学完后一部分，前一部分早已记不清的窘境之中。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统实验报告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSlab1实验报告</title>
    <link href="/20220405/OSlab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/20220405/OSlab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="lab1实验报告"><a href="#lab1实验报告" class="headerlink" title="lab1实验报告"></a>lab1实验报告</h2><h4 id="1-实验思考题"><a href="#1-实验思考题" class="headerlink" title="1.实验思考题"></a>1.实验思考题</h4><h5 id="Thinking1-1"><a href="#Thinking1-1" class="headerlink" title="Thinking1.1"></a>Thinking1.1</h5><blockquote><p><strong>请查阅并给出前述objdump 中使用的参数的含义。使用其它体系*<em>结构的编译器（如课程平台的MIPS交叉编译器）重复上述各步编译过程，观察并在实验报告中提交相应结果。*</em></strong></p></blockquote><ul><li><p>objdump</p><ul><li>-D 反汇编所有的section</li><li>-S 将代码段反汇编的同时，将反汇编代码和源代码交替显示</li></ul></li><li><p>复现</p><ul><li>Makefile</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile">CROSS_COMPILE :=  /OSLAB/compiler/usr/bin/mips_4KC-<br>CC            := <span class="hljs-variable">$(CROSS_COMPILE)</span>gcc<br>OBJ           := <span class="hljs-variable">$(CROSS_COMPILE)</span>objdump<br>LD            := <span class="hljs-variable">$(CROSS_COMPILE)</span>ld<br><br><span class="hljs-section">all:</span><br>        <span class="hljs-variable">$(CC)</span> -c store/ku.c -o store/ku.o       <br>        <span class="hljs-variable">$(CC)</span> -E f.c &gt; E.txt<br>        <span class="hljs-variable">$(CC)</span> -c f.c -o f.o<br>        <span class="hljs-variable">$(OBJ)</span> -DS f.o &gt; O.txt<br>        <span class="hljs-variable">$(LD)</span> -o f -N f.o store/ku.o<br>        <span class="hljs-variable">$(OBJ)</span> -DS f &gt; out.txt<br><span class="hljs-section">clean:</span><br>        rm -rf *.txt <br>        rm -rf *.o<br></code></pre></td></tr></table></figure><ul><li><p>只编译不链接反汇编结果</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-symbol">f.o:</span>     file format elf32-tradbigmips<br><br><span class="hljs-keyword">Disassembly </span>of section <span class="hljs-meta">.text</span>:<br><br><span class="hljs-number">00000000</span> &lt;main&gt;:<br><span class="hljs-symbol">   0:</span>   <span class="hljs-number">3</span>c1c0000        <span class="hljs-keyword">lui </span>    <span class="hljs-built_in">gp</span>,<span class="hljs-number">0x0</span><br><span class="hljs-symbol">   4:</span>   <span class="hljs-number">279</span>c0000        <span class="hljs-keyword">addiu </span>  <span class="hljs-built_in">gp</span>,<span class="hljs-built_in">gp</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol">   8:</span>   <span class="hljs-number">0399</span>e021        <span class="hljs-keyword">addu </span>   <span class="hljs-built_in">gp</span>,<span class="hljs-built_in">gp</span>,<span class="hljs-built_in">t9</span><br>   c:   <span class="hljs-number">27</span>bdffe0        <span class="hljs-keyword">addiu </span>  <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,-<span class="hljs-number">32</span><br><span class="hljs-symbol">  10:</span>   afbf001c        <span class="hljs-keyword">sw </span>     <span class="hljs-built_in">ra</span>,<span class="hljs-number">28</span>(<span class="hljs-built_in">sp</span>)<br><span class="hljs-symbol">  14:</span>   afbe0018        <span class="hljs-keyword">sw </span>     <span class="hljs-built_in">s8</span>,<span class="hljs-number">24</span>(<span class="hljs-built_in">sp</span>)<br><span class="hljs-symbol">  18:</span>   <span class="hljs-number">03</span>a<span class="hljs-symbol">0f</span>021        <span class="hljs-keyword">move </span>   <span class="hljs-built_in">s8</span>,<span class="hljs-built_in">sp</span><br>  <span class="hljs-number">1</span>c:   afbc0010        <span class="hljs-keyword">sw </span>     <span class="hljs-built_in">gp</span>,<span class="hljs-number">16</span>(<span class="hljs-built_in">sp</span>)<br><span class="hljs-symbol">  20:</span>   <span class="hljs-number">8</span>f990000        <span class="hljs-keyword">lw </span>     <span class="hljs-built_in">t9</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">gp</span>)<br><span class="hljs-symbol">  24:</span>   <span class="hljs-number">0320</span>f809        <span class="hljs-keyword">jalr </span>   <span class="hljs-built_in">t9</span><br><span class="hljs-symbol">  28:</span>   <span class="hljs-number">00000000</span>        <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>  <span class="hljs-number">2</span>c:   <span class="hljs-number">8</span>fdc0010        <span class="hljs-keyword">lw </span>     <span class="hljs-built_in">gp</span>,<span class="hljs-number">16</span>(<span class="hljs-built_in">s8</span>)<br><span class="hljs-symbol">  30:</span>   <span class="hljs-number">00001021</span>        <span class="hljs-keyword">move </span>   <span class="hljs-built_in">v0</span>,<span class="hljs-built_in">zero</span><br><span class="hljs-symbol">  34:</span>   <span class="hljs-number">03</span>c0e821        <span class="hljs-keyword">move </span>   <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">s8</span><br><span class="hljs-symbol">  38:</span>   <span class="hljs-number">8</span>fbf001c        <span class="hljs-keyword">lw </span>     <span class="hljs-built_in">ra</span>,<span class="hljs-number">28</span>(<span class="hljs-built_in">sp</span>)<br>  <span class="hljs-number">3</span>c:   <span class="hljs-number">8</span>fbe0018        <span class="hljs-keyword">lw </span>     <span class="hljs-built_in">s8</span>,<span class="hljs-number">24</span>(<span class="hljs-built_in">sp</span>)<br><span class="hljs-symbol">  40:</span>   <span class="hljs-number">27</span>bd0020        <span class="hljs-keyword">addiu </span>  <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,<span class="hljs-number">32</span><br><span class="hljs-symbol">  44:</span>   <span class="hljs-number">03</span>e00008        <span class="hljs-keyword">jr </span>     <span class="hljs-built_in">ra</span><br><span class="hljs-symbol">  48:</span>   <span class="hljs-number">00000000</span>        <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>  <span class="hljs-number">4</span>c:   <span class="hljs-number">00000000</span>        <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Disassembly </span>of section .reginfo:<br><br><span class="hljs-number">00000000</span> &lt;.reginfo&gt;:<br><span class="hljs-symbol">   0:</span>   f2000004        <span class="hljs-number">0xf2000004</span><br>        ...<br><span class="hljs-keyword">Disassembly </span>of section .pdr:<br><br><span class="hljs-number">00000000</span> &lt;.pdr&gt;:<br><span class="hljs-symbol">   0:</span>   <span class="hljs-number">00000000</span>        <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">   4:</span>   c0000000        <span class="hljs-keyword">ll </span>     <span class="hljs-built_in">zero</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">zero</span>)<br><span class="hljs-symbol">   8:</span>   fffffffc        sdc3    $<span class="hljs-number">31</span>,-<span class="hljs-number">4</span>(<span class="hljs-built_in">ra</span>)<br>        ...<br><span class="hljs-symbol">  14:</span>   <span class="hljs-number">00000020</span>        <span class="hljs-keyword">add </span>    <span class="hljs-built_in">zero</span>,<span class="hljs-built_in">zero</span>,<span class="hljs-built_in">zero</span><br><span class="hljs-symbol">  18:</span>   <span class="hljs-number">0000001</span>e        <span class="hljs-number">0x1e</span><br>  <span class="hljs-number">1</span>c:   <span class="hljs-number">0000001</span>f        <span class="hljs-number">0x1f</span><br><span class="hljs-keyword">Disassembly </span>of section .comment:<br><br><span class="hljs-number">00000000</span> &lt;.comment&gt;:<br><span class="hljs-symbol">   0:</span>   <span class="hljs-number">00474343</span>        <span class="hljs-number">0x474343</span><br><span class="hljs-symbol">   4:</span>   <span class="hljs-number">3</span>a202847        <span class="hljs-keyword">xori </span>   <span class="hljs-built_in">zero</span>,<span class="hljs-built_in">s1</span>,<span class="hljs-number">0x2847</span><br><span class="hljs-symbol">   8:</span>   <span class="hljs-number">4</span>e552920        c3      <span class="hljs-number">0x552920</span><br>   c:   <span class="hljs-number">342</span>e302e        <span class="hljs-keyword">ori </span>    <span class="hljs-built_in">t6</span>,<span class="hljs-built_in">at</span>,<span class="hljs-number">0x302e</span><br><span class="hljs-symbol">  10:</span>   <span class="hljs-number">30202844</span>        <span class="hljs-keyword">andi </span>   <span class="hljs-built_in">zero</span>,<span class="hljs-built_in">at</span>,<span class="hljs-number">0x2844</span><br><span class="hljs-symbol">  14:</span>   <span class="hljs-number">454</span>e5820        <span class="hljs-number">0x454e5820</span><br><span class="hljs-symbol">  18:</span>   <span class="hljs-number">454</span>c<span class="hljs-symbol">444b</span>        <span class="hljs-number">0x454c444b</span><br>  <span class="hljs-number">1</span>c:   <span class="hljs-number">20342</span>e31        <span class="hljs-keyword">addi </span>   <span class="hljs-built_in">s4</span>,<span class="hljs-built_in">at</span>,<span class="hljs-number">11825</span><br><span class="hljs-symbol">  20:</span>   <span class="hljs-number">20342</span>e30        <span class="hljs-keyword">addi </span>   <span class="hljs-built_in">s4</span>,<span class="hljs-built_in">at</span>,<span class="hljs-number">11824</span><br><span class="hljs-symbol">  24:</span>   <span class="hljs-number">2</span>e302900        <span class="hljs-keyword">sltiu </span>  <span class="hljs-built_in">s0</span>,<span class="hljs-built_in">s1</span>,<span class="hljs-number">10496</span><br></code></pre></td></tr></table></figure></li><li><p>链接后反汇编结果</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">f:     file format elf32-tradbigmips<br><br><span class="hljs-keyword">Disassembly </span>of section .reginfo:<br><br><span class="hljs-number">00400094</span> &lt;.reginfo&gt;:<br><span class="hljs-symbol">  400094:</span>       f2000004        <span class="hljs-number">0xf2000004</span><br>        ...<br>  <span class="hljs-number">4000</span>a8:       <span class="hljs-number">00408110</span>        <span class="hljs-number">0x408110</span><br><span class="hljs-keyword">Disassembly </span>of section <span class="hljs-meta">.text</span>:<br><br><span class="hljs-number">004000</span>b0 &lt;main&gt;:<br>  <span class="hljs-number">4000</span>b0:       <span class="hljs-number">3</span>c1c0001        <span class="hljs-keyword">lui </span>    <span class="hljs-built_in">gp</span>,<span class="hljs-number">0x1</span><br>  <span class="hljs-number">4000</span>b4:       <span class="hljs-number">279</span>c8060        <span class="hljs-keyword">addiu </span>  <span class="hljs-built_in">gp</span>,<span class="hljs-built_in">gp</span>,-<span class="hljs-number">32672</span><br>  <span class="hljs-number">4000</span>b8:       <span class="hljs-number">0399</span>e021        <span class="hljs-keyword">addu </span>   <span class="hljs-built_in">gp</span>,<span class="hljs-built_in">gp</span>,<span class="hljs-built_in">t9</span><br>  <span class="hljs-number">4000</span>bc:       <span class="hljs-number">27</span>bdffe0        <span class="hljs-keyword">addiu </span>  <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,-<span class="hljs-number">32</span><br>  <span class="hljs-number">4000</span>c0:       afbf001c        <span class="hljs-keyword">sw </span>     <span class="hljs-built_in">ra</span>,<span class="hljs-number">28</span>(<span class="hljs-built_in">sp</span>)<br>  <span class="hljs-number">4000</span>c4:       afbe0018        <span class="hljs-keyword">sw </span>     <span class="hljs-built_in">s8</span>,<span class="hljs-number">24</span>(<span class="hljs-built_in">sp</span>)<br>  <span class="hljs-number">4000</span>c8:       <span class="hljs-number">03</span>a<span class="hljs-symbol">0f</span>021        <span class="hljs-keyword">move </span>   <span class="hljs-built_in">s8</span>,<span class="hljs-built_in">sp</span><br>  <span class="hljs-number">4000</span>cc:       afbc0010        <span class="hljs-keyword">sw </span>     <span class="hljs-built_in">gp</span>,<span class="hljs-number">16</span>(<span class="hljs-built_in">sp</span>)<br>  <span class="hljs-number">4000</span>d0:       <span class="hljs-number">8</span>f99802c        <span class="hljs-keyword">lw </span>     <span class="hljs-built_in">t9</span>,-<span class="hljs-number">32724</span>(<span class="hljs-built_in">gp</span>)<br>  <span class="hljs-number">4000</span>d4:       <span class="hljs-number">0320</span>f809        <span class="hljs-keyword">jalr </span>   <span class="hljs-built_in">t9</span><br>  <span class="hljs-number">4000</span>d8:       <span class="hljs-number">00000000</span>        <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>  <span class="hljs-number">4000</span>dc:       <span class="hljs-number">8</span>fdc0010        <span class="hljs-keyword">lw </span>     <span class="hljs-built_in">gp</span>,<span class="hljs-number">16</span>(<span class="hljs-built_in">s8</span>)<br>  <span class="hljs-number">4000</span>e0:       <span class="hljs-number">00001021</span>        <span class="hljs-keyword">move </span>   <span class="hljs-built_in">v0</span>,<span class="hljs-built_in">zero</span><br>  <span class="hljs-number">4000</span>e4:       <span class="hljs-number">03</span>c0e821        <span class="hljs-keyword">move </span>   <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">s8</span><br>  <span class="hljs-number">4000</span>e8:       <span class="hljs-number">8</span>fbf001c        <span class="hljs-keyword">lw </span>     <span class="hljs-built_in">ra</span>,<span class="hljs-number">28</span>(<span class="hljs-built_in">sp</span>)<br>  <span class="hljs-number">4000</span>ec:       <span class="hljs-number">8</span>fbe0018        <span class="hljs-keyword">lw </span>     <span class="hljs-built_in">s8</span>,<span class="hljs-number">24</span>(<span class="hljs-built_in">sp</span>)<br>  <span class="hljs-number">4000</span>f0:       <span class="hljs-number">27</span>bd0020        <span class="hljs-keyword">addiu </span>  <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,<span class="hljs-number">32</span><br>  <span class="hljs-number">4000</span>f4:       <span class="hljs-number">03</span>e00008        <span class="hljs-keyword">jr </span>     <span class="hljs-built_in">ra</span><br>  <span class="hljs-number">4000</span>f8:       <span class="hljs-number">00000000</span>        <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span>  <span class="hljs-number">4000</span>fc:       <span class="hljs-number">00000000</span>        <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><br><span class="hljs-number">00400100</span> &lt;fun&gt;:<br><span class="hljs-symbol">  400100:</span>       <span class="hljs-number">27</span>bdfff8        <span class="hljs-keyword">addiu </span>  <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,-<span class="hljs-number">8</span><br><span class="hljs-symbol">  400104:</span>       afbe0000        <span class="hljs-keyword">sw </span>     <span class="hljs-built_in">s8</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">sp</span>)<br><span class="hljs-symbol">  400108:</span>       <span class="hljs-number">03</span>a<span class="hljs-symbol">0f</span>021        <span class="hljs-keyword">move </span>   <span class="hljs-built_in">s8</span>,<span class="hljs-built_in">sp</span><br>  <span class="hljs-number">40010</span>c:       <span class="hljs-number">03</span>c0e821        <span class="hljs-keyword">move </span>   <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">s8</span><br><span class="hljs-symbol">  400110:</span>       <span class="hljs-number">8</span>fbe0000        <span class="hljs-keyword">lw </span>     <span class="hljs-built_in">s8</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">sp</span>)<br><span class="hljs-symbol">  400114:</span>       <span class="hljs-number">27</span>bd0008        <span class="hljs-keyword">addiu </span>  <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,<span class="hljs-number">8</span><br><span class="hljs-symbol">  400118:</span>       <span class="hljs-number">03</span>e00008        <span class="hljs-keyword">jr </span>     <span class="hljs-built_in">ra</span><br>  <span class="hljs-number">40011</span>c:       <span class="hljs-number">00000000</span>        <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">Disassembly </span>of section .got:<br><span class="hljs-number">00400120</span> &lt;_GLOBAL_OFFSET_TABLE_&gt;:<br><span class="hljs-symbol">  400120:</span>       <span class="hljs-number">00000000</span>        <span class="hljs-keyword">nop</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">  400124:</span>       <span class="hljs-number">80000000</span>        <span class="hljs-keyword">lb </span>     <span class="hljs-built_in">zero</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">zero</span>)<br>        ...<br>  <span class="hljs-number">40013</span>c:       <span class="hljs-number">00400100</span>        <span class="hljs-number">0x400100</span><br><span class="hljs-keyword">Disassembly </span>of section .comment:<br><br><span class="hljs-number">00000000</span> &lt;.comment&gt;:<br><span class="hljs-symbol">   0:</span>   <span class="hljs-number">00474343</span>        <span class="hljs-number">0x474343</span><br><span class="hljs-symbol">   4:</span>   <span class="hljs-number">3</span>a202847        <span class="hljs-keyword">xori </span>   <span class="hljs-built_in">zero</span>,<span class="hljs-built_in">s1</span>,<span class="hljs-number">0x2847</span><br><span class="hljs-symbol">   8:</span>   <span class="hljs-number">4</span>e552920        c3      <span class="hljs-number">0x552920</span><br>   c:   <span class="hljs-number">342</span>e302e        <span class="hljs-keyword">ori </span>    <span class="hljs-built_in">t6</span>,<span class="hljs-built_in">at</span>,<span class="hljs-number">0x302e</span><br><span class="hljs-symbol">  10:</span>   <span class="hljs-number">30202844</span>        <span class="hljs-keyword">andi </span>   <span class="hljs-built_in">zero</span>,<span class="hljs-built_in">at</span>,<span class="hljs-number">0x2844</span><br><span class="hljs-symbol">  14:</span>   <span class="hljs-number">454</span>e5820        <span class="hljs-number">0x454e5820</span><br><span class="hljs-symbol">  18:</span>   <span class="hljs-number">454</span>c<span class="hljs-symbol">444b</span>        <span class="hljs-number">0x454c444b</span><br>  <span class="hljs-number">1</span>c:   <span class="hljs-number">20342</span>e31        <span class="hljs-keyword">addi </span>   <span class="hljs-built_in">s4</span>,<span class="hljs-built_in">at</span>,<span class="hljs-number">11825</span><br><span class="hljs-symbol">  20:</span>   <span class="hljs-number">20342</span>e30        <span class="hljs-keyword">addi </span>   <span class="hljs-built_in">s4</span>,<span class="hljs-built_in">at</span>,<span class="hljs-number">11824</span><br><span class="hljs-symbol">  24:</span>   <span class="hljs-number">2</span>e302900        <span class="hljs-keyword">sltiu </span>  <span class="hljs-built_in">s0</span>,<span class="hljs-built_in">s1</span>,<span class="hljs-number">10496</span><br><span class="hljs-symbol">  28:</span>   <span class="hljs-number">00474343</span>        <span class="hljs-number">0x474343</span><br>  <span class="hljs-number">2</span>c:   <span class="hljs-number">3</span>a202847        <span class="hljs-keyword">xori </span>   <span class="hljs-built_in">zero</span>,<span class="hljs-built_in">s1</span>,<span class="hljs-number">0x2847</span><br><span class="hljs-symbol">  30:</span>   <span class="hljs-number">4</span>e552920        c3      <span class="hljs-number">0x552920</span><br><span class="hljs-symbol">  34:</span>   <span class="hljs-number">342</span>e302e        <span class="hljs-keyword">ori </span>    <span class="hljs-built_in">t6</span>,<span class="hljs-built_in">at</span>,<span class="hljs-number">0x302e</span><br><span class="hljs-symbol">  38:</span>   <span class="hljs-number">30202844</span>        <span class="hljs-keyword">andi </span>   <span class="hljs-built_in">zero</span>,<span class="hljs-built_in">at</span>,<span class="hljs-number">0x2844</span><br>  <span class="hljs-number">3</span>c:   <span class="hljs-number">454</span>e5820        <span class="hljs-number">0x454e5820</span><br><span class="hljs-symbol">  40:</span>   <span class="hljs-number">454</span>c<span class="hljs-symbol">444b</span>        <span class="hljs-number">0x454c444b</span><br><span class="hljs-symbol">  44:</span>   <span class="hljs-number">20342</span>e31        <span class="hljs-keyword">addi </span>   <span class="hljs-built_in">s4</span>,<span class="hljs-built_in">at</span>,<span class="hljs-number">11825</span><br><span class="hljs-symbol">  48:</span>   <span class="hljs-number">20342</span>e30        <span class="hljs-keyword">addi </span>   <span class="hljs-built_in">s4</span>,<span class="hljs-built_in">at</span>,<span class="hljs-number">11824</span><br>  <span class="hljs-number">4</span>c:   <span class="hljs-number">2</span>e302900        <span class="hljs-keyword">sltiu </span>  <span class="hljs-built_in">s0</span>,<span class="hljs-built_in">s1</span>,<span class="hljs-number">10496</span><br><span class="hljs-keyword">Disassembly </span>of section .pdr:<br><br><span class="hljs-number">00000000</span> &lt;.pdr&gt;:<br><span class="hljs-symbol">   0:</span>   <span class="hljs-number">004000</span>b0        <span class="hljs-keyword">tge </span>    <span class="hljs-built_in">v0</span>,<span class="hljs-built_in">zero</span>,<span class="hljs-number">0x2</span><br><span class="hljs-symbol">   4:</span>   c0000000        <span class="hljs-keyword">ll </span>     <span class="hljs-built_in">zero</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">zero</span>)<br><span class="hljs-symbol">   8:</span>   fffffffc        sdc3    $<span class="hljs-number">31</span>,-<span class="hljs-number">4</span>(<span class="hljs-built_in">ra</span>)<br>        ...<br><span class="hljs-symbol">  14:</span>   <span class="hljs-number">00000020</span>        <span class="hljs-keyword">add </span>    <span class="hljs-built_in">zero</span>,<span class="hljs-built_in">zero</span>,<span class="hljs-built_in">zero</span><br><span class="hljs-symbol">  18:</span>   <span class="hljs-number">0000001</span>e        <span class="hljs-number">0x1e</span><br>  <span class="hljs-number">1</span>c:   <span class="hljs-number">0000001</span>f        <span class="hljs-number">0x1f</span><br><span class="hljs-symbol">  20:</span>   <span class="hljs-number">00400100</span>        <span class="hljs-number">0x400100</span><br><span class="hljs-symbol">  24:</span>   <span class="hljs-number">40000000</span>        <span class="hljs-keyword">mfc0 </span>   <span class="hljs-built_in">zero</span>,c0_index<br><span class="hljs-symbol">  28:</span>   fffffff8        sdc3    $<span class="hljs-number">31</span>,-<span class="hljs-number">8</span>(<span class="hljs-built_in">ra</span>)<br>        ...<br><span class="hljs-symbol">  34:</span>   <span class="hljs-number">00000008</span>        <span class="hljs-keyword">jr </span>     <span class="hljs-built_in">zero</span><br><span class="hljs-symbol">  38:</span>   <span class="hljs-number">0000001</span>e        <span class="hljs-number">0x1e</span><br>  <span class="hljs-number">3</span>c:   <span class="hljs-number">0000001</span>f        <span class="hljs-number">0x1f</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h5 id="Thinking1-2"><a href="#Thinking1-2" class="headerlink" title="Thinking1.2"></a>Thinking1.2</h5><blockquote><p><strong>也许你会发现我们的readelf程序是不能解析之前生成的内核文件(内核文件是可执行文件)的，而我们之后将要介绍的工具readelf则可以解析，这是为什么呢？(提示：尝试使用readelf -h，观察不同)</strong></p></blockquote><ul><li>两readelf -h 结果</li></ul><p><img src="/20220405/OSlab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220326195642335.png" alt="image-20220326195642335"></p><p><img src="/20220405/OSlab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220326195545611.png"></p><ul><li>分析：testELF是小端模式而内核文件vmlinux是大端模式，因为我们写的readelf.c<strong>只能从读取小端模式</strong>的数据，不能正确读取大端模式文件，因此不能解析生产的内核文件vmlinux</li></ul><h5 id="Thinking1-3"><a href="#Thinking1-3" class="headerlink" title="Thinking1.3"></a>Thinking1.3</h5><blockquote><p><strong>在理论课上我们了解到，MIPS 体系结构上电时，启动入口地址为0xBFC00000（其实启动入口地址是根据具体型号而定的，由硬件逻辑确定，也有可能不是这个地址，但一定是一个确定的地址），但实验操作系统的内核入口并没有放在上电启动地址，而是按照内存布局图放置。思考为什么这样放置内核还能保证内核入口被正确跳转到？</strong></p></blockquote><ul><li>MIPS上电入口设在0xBFC00000是因为其需要先完成stage1，从而实现内存RAM初始化以及部分硬件初始化。而我们使用的是GXemul仿真器，GXemul支持加载ELF格式内核，所以启动流程被简化为加载内核到内存，之后跳转到内核的入口。</li></ul><h5 id="Thinking1-4"><a href="#Thinking1-4" class="headerlink" title="Thinking1.4"></a>Thinking1.4</h5><blockquote><p><strong>与内核相比，普通进程的sg_size 和bin_size 的区别在于它的开始加载位置并非页对齐，同时bin_size的结束位置（va+i，其中i为计算出的该段在ELF文件中的大小）也并非页对齐，最终整个段加载完毕的sg_size 末尾的位置也并非页对齐。请思考，为了保证页面不冲突（不重复为同一地址申请多个页，以及页上数据尽可能减少冲突），这样一个程序段应该怎样加载内存空间中。</strong></p></blockquote><ul><li>用空间换安全性，当某个页面已经有一部分被其他程序段占用后就不允许其再被申请给其他程序段使用。</li></ul><h5 id="Thinking1-5"><a href="#Thinking1-5" class="headerlink" title="Thinking1.5"></a>Thinking1.5</h5><blockquote><p><strong>内核入口在什么地方？main 函数在什么地方？我们是怎么让内核进入到想要的 main 函数的呢？又是怎么进行跨文件调用函数的呢？</strong> </p></blockquote><p><img src="/20220405/OSlab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220405194853712.png" alt="image-20220405194853712"></p><p><img src="/20220405/OSlab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220405195044939.png" alt="image-20220405195044939"></p><ul><li><strong>内核入口</strong>在0x80000000；<strong>main函数</strong>在0x80010000；如图在start.S的最后，通过<strong>jal main</strong>进入了main函数；跨文件调用函数只需要知道各函数对应的地址，就可以用<strong>跳转指令</strong>跳转实现函数调用了</li></ul><h5 id="Thinking1-6"><a href="#Thinking1-6" class="headerlink" title="Thinking1.6"></a>Thinking1.6</h5><blockquote><p><strong>查阅《See MIPS Run Linux》一书相关章节，解释boot&#x2F;start.S 中下面几行对CP0 协处理器寄存器进行读写的意义。具体而言，它们分别读&#x2F;写了哪些寄存器的哪些特定位，从而达到什么目的？</strong></p></blockquote><ul><li>&#96;&#96;&#96;<br>mtc0 zero, CP0_STATUS &#x2F;&#x2F;将SR状态寄存器置0<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>- ```<br>  mfc0 t0, CP0_CONFIG <span class="hljs-regexp">//</span>访问Config寄存器<br>  and t0, ~<span class="hljs-number">0</span>x7 <span class="hljs-regexp">//</span>将后三位置<span class="hljs-number">0</span><br>  ori t0, <span class="hljs-number">0</span>x2 <span class="hljs-regexp">//</span>将倒数第二位置<span class="hljs-number">1</span>，表示允许kseg0区经过高速缓存<br>  mtc0 t0, CP0_CONFIG <span class="hljs-regexp">//</span>修改Config寄存器的值<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-实验难点图示"><a href="#2-实验难点图示" class="headerlink" title="2.实验难点图示"></a>2.实验难点图示</h4><ul><li>程序编译链接过程<ul><li><img src="/20220405/OSlab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/%E7%BC%96%E8%AF%91%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B.png"></li></ul></li><li>ELF文件内容<ul><li><img src="/20220405/OSlab1%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="ELF文件结构"></li><li>Segment 记录了每一段数据（包括代码等内容） 需要被载入到哪里，记录了用于指导应用程序加载的各类信息。</li><li>Section 记录了程序的代码段、数据段等各个段的内容，主要是链接器在链接的过程中需要使用。</li></ul></li></ul><h4 id="3-体会与感想"><a href="#3-体会与感想" class="headerlink" title="3.体会与感想"></a>3.体会与感想</h4><ul><li>lab1卸去了lab0的伪装，让我真切感受到了OS的难度，但也带来了学习OS的乐趣。OS学习的特点我认为主要是大量的基础理论知识以及与实践操作的结合，一方面平时老师上课信息量大，一时不太容易吸收，另一方面我们在实践中必须要对理论知识有很好的理解，才能完成实验所给的任务，不然就是瞎整白忙活。就我个人而言，lab1的难度还算可以，就是第二次上机的Extra完全不知从何下手，这与我没能很好掌握基础知识以及编程能力有关，但也让我找到了改进的方向，要将更多的时间和精力放在OS的基础理论上，才能在实验中做到得心应手。</li></ul><h4 id="4-残留难点"><a href="#4-残留难点" class="headerlink" title="4.残留难点"></a>4.残留难点</h4><ul><li>对于lab1-2-Extra中考到的编写汇编函数以及在C语言程序中调用，我仍旧是感到云里雾里，不知从何下手。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统实验报告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OO第一单元总结</title>
    <link href="/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/"/>
    <url>/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="OO第一单元作业总结"><a href="#OO第一单元作业总结" class="headerlink" title="OO第一单元作业总结"></a>OO第一单元作业总结</h2><h4 id="一、作业梗概"><a href="#一、作业梗概" class="headerlink" title="一、作业梗概"></a>一、作业梗概</h4><p>​OO第一单元作业的核心是表达式的处理及化简，三次作业不断迭代增添功能：</p><ul><li>实现简单的(x的幂函数以及常数)的多项式括号展开</li><li>增添了对三角函数、sum求和函数以及自定义函数的需求，但有三角函数中只有常数因子或幂函数的限定</li><li>取消了第二次作业中的限定，要求可实现多项式与因子的互相嵌套</li></ul><h4 id="二、程序思路及结构分析"><a href="#二、程序思路及结构分析" class="headerlink" title="二、程序思路及结构分析"></a>二、程序思路及结构分析</h4><h5 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h5><ul><li><strong>递归下降</strong>：得益于第一次上机和训练助教给出的代码，让我学习到了递归下降这一关键理念，通过对多项式（Expr）、项（Term）、因子（Factor）的分层处理，实现了作业的主要任务“去括号”，这一点体现在代码中的<strong>Parse类</strong>。</li><li><strong>表达式实时处理</strong>：此思路亦来自于实验代码，通过建立表达式处理类（<strong>Analysis&#x2F;Lexer</strong>），模拟<strong>读一项理解一项</strong>的过程，对每一次读取数或者符号进行实时反馈，其中包括**getOperation()、getSymbol()、getFactor()、getTri()**等方法对可能读入的各种元素进行读取。</li><li><strong>类型统一化</strong>：尽管递归下降的思路将处理分成了三个层次，但为了便于处理，笔者将三个层次返回值都设定为<strong>多项式</strong>，这样的好处是在进行加减乘以及指数运算时，可以保证两运算数间的类型保持一致，<strong>避免不同层级之间相互运算而导致程序混乱</strong>。笔者在本文中将这个体现基础的多项式的类称为<strong>基元</strong>。</li></ul><h5 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h5><ul><li><p>分析：由于第一次作业明确声明指数始终不会超过8，因此笔者在设置存储<strong>基元</strong>的<strong>Factor类</strong>时，定义了一个长度为0-8的数组，即表示一个<strong>指数最高为8的x的多项式</strong>。</p></li><li><p>UML类图：</p><p><img src="/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/1.jpg"></p></li><li><p>度量分析</p><ul><li>类</li></ul><p><img src="/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/1class.png" alt="1class"></p><ul><li>方法</li></ul><p><img src="/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/1method.png" alt="1method"></p><ul><li><p>程序优缺点分析及总结</p><p>第一次作业整体来说较为简单，个人感觉是为了让同学们初步开始接触面向对象的第一次练手。由于可能出现的表达形式比较简单，因此我在学习了实验中助教给的示例代码后，仅用四个类就完成了第一次作业的编写。</p><ul><li>从程序来看，第一次作业优在简单明了，结构明晰，可读性高易理解，但劣在可拓展性较弱，例如在存储x幂函数的部分，直接简单粗暴地用了静态数组来存储，不利于之后指数无上限等的拓展。</li><li>从结果来看，第一次作业由于比较简单，最后的正确性和性能的实现结果都令人满意，未曾有发现bug。</li></ul></li></ul></li></ul><h5 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h5><ul><li>分析：第二次作业的难点为三角函数的存储以及sum函数、自定义函数的处理，为此笔者新增了<strong>Num、Pretreat、Func三个类</strong><ul><li>三角函数的存储：由于三角函数内可能为常数或是x的幂函数，已不是第一次作业用一个数组所能支撑了，为此笔者写了一个<strong>Num类</strong>来作为<strong>基元</strong>存储，其可以理解为项的层级，存储了项的常数、x的指数以及用<strong>Hashmap</strong>分别存了三角函数内常数和幂函数的内容及其指数。</li><li>sum函数、自定义函数的处理：通过分析这两种函数可知，其皆可以通过一定规则的代换，将输入的<strong>expression</strong>处理成没有sum函数、自定义函数的形式，为此笔者设置了<strong>Func类</strong>来存自定义函数的<strong>函数名、自变量和表达式</strong>，再设置了<strong>Pretreat类</strong>对输入的初始expression进行处理，最终返回一个<strong>没有sum函数和自定义函数的expression_dealed</strong>供以后续的运算。</li></ul></li><li>UML类图</li></ul><p><img src="/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/2.jpg"></p><ul><li><p>度量分析</p><ul><li>类</li></ul><p><img src="/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/2class.png" alt="2class"></p><ul><li>方法</li></ul><p><img src="/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/2method.png" alt="2method"></p><ul><li><p>程序优缺点分析及总结</p><p>笔者认为第一次到第二次之间的跨度是最大的，三角函数的加入对原本的存储结构是一次巨大的冲击。在纠结了良久之后，笔者最终学习了讨论区同学暴力地将常数、x幂函数、三角函数全存在一个基元中的“暴力写法”，个人认为写得不尽人意，思路十分凌乱，为后续出bug埋下了伏笔。</p><ul><li>从程序来看，第二次作业存在诸多缺点，例如此种“暴力写法”过于生硬，只能说是为了解决第二次作业的任务刻意去实现，极大得缺乏可读性和可拓展性，这也是导致笔者在第三次作业中大量重构的原因，后面会讲到。除此之外，在第二次作业的迭代过程中，没有很好得兼顾到原有内容，这导致了在增添新功能时造成了代码的大量冗余，最后呈现出的就是代码乱七八糟的情况。</li><li>从结果来看，本次作业出现了重大bug，虽然在修改bug后发现其实就是三角函数的处理中情况没有考虑完善，但我认为归根结底，是因为<strong>程序的复杂度过高而导致的思路不清晰</strong>所产生的bug。</li></ul></li></ul></li></ul><h5 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h5><ul><li><p>分析：第三次作业的核心在于嵌套，一是三角函数内可以为多项式，二是自定义函数可以互相嵌套</p><ul><li><p>三角函数内的多项式：多项式的复杂性使得第二次作业的“暴力存储”做法不再有效，深思熟虑后我们可以发现，答案其实早就藏在原本的思路中，在前两次作业里，我们对于expression的处理有着Factor➡Term➡Expr➡Factor的递归嵌套层次结构，这不就可以用来作为我们存储多项式的结构么，因此笔者痛下决心对代码进行了大规模重构，<strong>删去了原有的Factor类和Num类</strong>，替换为以下三个新类：</p><ul><li><strong>Mi类</strong>：其仅为<strong>单个因子</strong>，可为常数、x^exp、sin()^exp、cos()^exp，通过<strong>kind属性</strong>来表示当前Mi对象是什么种类，其中sin()、cos()有<strong>名为expr的Expr类对象</strong>体现了<strong>递归嵌套的结构特性</strong></li><li><strong>Term类</strong>：表示多个因子相乘的<strong>项</strong>层级，使用ArrayList存储多个Mi对象</li><li><strong>Expr类</strong>：表示多个项相加的<strong>多项式</strong>层级，使用ArrayList存储多个Term对象</li></ul><p>如此这般构造，再实现同层级之间的运算以及每一层级对于下层元素的添加方法，最后将Expr类作为<strong>基元</strong>，即可完美地<strong>支持多项式嵌套的需求</strong>了。</p></li><li><p>自定义函数互相嵌套：这一点其实较为简单，在第二次作业能实现对expression预处理的基础上，只需要对本次作业的expression<strong>重复进行多次预处理</strong>，直到新的expression中不再出现sum函数和自定义函数即可。</p></li></ul></li><li><p>UML类图</p></li></ul><p><img src="/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/3.jpg"></p><ul><li><p>度量分析</p><ul><li>类</li></ul><p><img src="/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/3class.png" alt="3class"></p><ul><li>方法</li></ul><p><img src="/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/3method-1.png" alt="3method-1"></p><p><img src="/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/3method-2.png" alt="3method-2"></p><p><img src="/20220326/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/3method-3.png" alt="3method-3"></p><ul><li><p>程序优缺点分析及总结</p><p>第三次作业的跨度较小，以至于许多同学在完成第二次作业时就已经实现了第三次的需求，变得十分轻松，但由于笔者的第二次作业完成得太烂，以至于在第三次作业中进行了大量重构，虽然花费了许多精力，但最后的结果是令人满意的。</p><ul><li>从程序来看，第三次采用了<strong>递归嵌套</strong>的结构来实现存储<strong>基元</strong>，笔者认为这是较为完美的一种写法，一是较优地实现了第三次的任务，二是程序结构明晰，以至于笔者在重构时一气呵成，未曾出现过因思路混乱而卡壳的情况，带来了一次令人身心愉悦的编程经历。</li><li>从结果来看，第三次作业最后在互测过程中出现了一个小小的bug，是由于在优化三角函数中幂函数可去括号时，判断条件出错导致，总体来说差强人意。</li></ul></li></ul></li></ul><h5 id="三次作业对比分析"><a href="#三次作业对比分析" class="headerlink" title="三次作业对比分析"></a>三次作业对比分析</h5><p>​三次作业的逐步迭代成型已在<strong>每次作业的分析</strong>中阐述，就不在此赘述了，让我们把目光放在<strong>程序复杂度</strong>和<strong>程序出bug</strong>的方面上。纵观三次作业，笔者在第二次作业中出现了重大bug，得到了极低的分数，<strong>抛开复杂度本身较高的expression预处理不谈</strong>，通过对比前文给出的度量分析可以发现，第二次作业在<strong>存储基元Num类</strong>上相较于另外两次有着较高的复杂度，直观来理解，笔者在第二次作业中将对多项式的计算全部丢入了Num类中，致使该类承载了过多混乱的功能，一方面导致了程序实现功能易出错，另一方面使得笔者在编写程序时思路混乱，最终导致了bug的出现。</p><p>​为此，笔者总结出一个往后写代码的经验：<strong>“物以类聚”</strong>——在我们构造程序结构时，一个类应当仅实现<strong>其紧密相关的功能</strong>，一但其功能开始繁杂，我们就应开始考虑将类继续细化，亦或是继承拓展，如此便能使得程序与程序员始终保持清晰。</p><h4 id="三、互测"><a href="#三、互测" class="headerlink" title="三、互测"></a>三、互测</h4><p>​<em>互测是一次全新的体验，成功hack到人时着实给笔者带来了极大的成就感。</em></p><p>​笔者每周所花在写程序本身所耗费的时间过多，未曾有精力去模仿各位大牛写数据生成器以及自动评测机，所以没有加入“自动党”，最终只是略微通过读代码和一些简单策略来“找茬”，采用的策略核心是“盯紧优化部分”：</p><p>​这几次作业同学们在功能性其实都完成得很好，在hack了几次之后我渐渐发现大部人被hack问题主要都出在<strong>优化多项式长度时考虑不周</strong>，导致本因正确的结果出现奇奇怪怪的错误，例如符号不见了，0优化导致出现空项等现象，因此笔者在后来的互测阶段基本都是在尝试一些可能导致优化出错的数据，也取得了一定的hack成果。</p><h4 id="四、心得体会"><a href="#四、心得体会" class="headerlink" title="四、心得体会"></a>四、心得体会</h4><p>​OO的第一单元就此落下帷幕，不知不觉竟已收获如此之多。笔者在过去这个月里，逐渐熟悉了java语言，初步掌握了面向对象的编程思想与形式，在作业中学习了递归下降的构造思路，体会到了大代码量的工程建立与迭代，同时还接触了互测和写博客这些以往未曾尝试的东西，可谓是度过了极其丰富的一个月。在此笔者要大力感谢<strong>OO课程的老师和助教们</strong>，为我们提供了如此完备的理论教育和作业安排，让我们<strong>在学习和实践中快速成长</strong>。</p><p>​当然，在过去的这个月里我有很多的不足，其中最大的问题就是没能克服面对大工作量的任务时的<strong>心理障碍</strong>，总是要拖到最后才开始着手任务，导致了OO这门课程乃至这一个月的学习节奏都变得拖沓。所谓“<em><strong>过而不能知，是不智也；知而不能改，是不勇也。</strong></em>”在接下来的OO单元中，我要努力做出改变，克服心理障碍，只要思路成型就<strong>动手去写</strong>，相信会这对我自身的学习节奏会有很大的助益。</p><h4 id="五、写在最后"><a href="#五、写在最后" class="headerlink" title="五、写在最后"></a>五、写在最后</h4><p>​<em><strong>“是晚风，是余晖，是一道曙光，是未来可期”</strong></em></p><p>​OO的学习才刚刚开始，就让我们一同努力，一同进步吧！</p>]]></content>
    
    
    <categories>
      
      <category>面向对象单元总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OSlab0实验报告</title>
    <link href="/20220320/OSlab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/20220320/OSlab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="lab0实验报告"><a href="#lab0实验报告" class="headerlink" title="lab0实验报告"></a>lab0实验报告</h2><h4 id="1-实验思考题"><a href="#1-实验思考题" class="headerlink" title="1.实验思考题"></a>1.实验思考题</h4><ul><li><p><strong>Thinking 0.1</strong></p><p><strong>使用 cat Modified.txt ，观察它和第一次 add 之前的 status 一样吗，思考一 下为什么？</strong></p><ul><li>不一样，在第一次add之前，文件只存在于工作区，是本地的实际文件，与版本库无关，其本身为<strong>未跟踪</strong>状态（Untracked）；而在第一次add后，文件被添加到暂存区中，其状态由未跟踪转为<strong>未修改</strong>（Unmodified）</li></ul></li><li><p><strong>Thinking 0.2</strong></p><p><strong>仔细看看这张图，思考一下箭头中的 add the file、stage the file 和 commit 分别对应的是 Git 里的哪些命令呢？</strong></p><p><img src="/20220320/OSlab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/git-change.jpg" alt="Git中的四种状态转换关系"></p><p><em>（引自BUAA_OS教程网站）</em></p><ul><li>add the file ：<strong>add</strong></li><li>stage the file ：<strong>add</strong></li><li>commit ：<strong>commit</strong></li></ul></li><li><p><strong>Thinking 0.3</strong></p><ul><li><p>恢复<strong>工作区</strong>删除的printf.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout -- printf.c<br></code></pre></td></tr></table></figure></li><li><p>删除<strong>暂存区</strong>的Tucao.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git rm --cached Tucao.txt<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>Thinking 0.4</strong></p><p><strong>关于版本恢复的理解</strong></p><ul><li>在每一次<strong>commit</strong>后，git将新文件和新修改的内容提交到<strong>对象库</strong>中，并计算当前文件内容的SHA1哈希值作为本次提交的对象的文件名，将变化记录在<strong>目录树</strong>中。换句话说，git对每一次commit的文件都做了备份，因此各版本建的切换。</li></ul></li><li><p><strong>Thinking 0.5</strong></p><ul><li><strong>1.克隆时所有分支均被克隆，但只有HEAD指向的分支被检出。</strong><ul><li>正确，证据同4</li></ul></li><li><strong>2.克隆出的工作区中执行 git log、git status、git checkout、git commit等操作不会去访问远程版本库。</strong><ul><li>错误，“git checkout会访问<strong>远程版本库</strong>在本地检出一个同名分支自动跟踪远程分支”（来源于BUAA_OS教程网站）</li></ul></li><li><strong>3.克隆时只有远程版本库HEAD指向的分支被克隆。</strong><ul><li>错误，克隆时所有分支均被克隆,使用 <strong>–single-branch</strong>才可实现只克隆一个分支</li></ul></li><li><strong>4.克隆后工作区的默认分支处于master分支。</strong><ul><li>错误，经实验如下，clone后默认分支并非master分支而是<strong>HEAD指向的分支main</strong></li><li><img src="/20220320/OSlab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220320111819622.png" alt="image-20220320111819622"></li></ul></li></ul></li><li><p><strong>Thinking 0.6</strong></p><ul><li><img src="/20220320/OSlab0%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20220320112520766.png" alt="image-20220320112520766"></li></ul></li><li><p><strong>Thinking 0.7</strong></p><ul><li><pre><code class="shell">#commandecho &quot;echo Shell Start...&quot; &gt;testecho &quot;echo set a = 1&quot; &gt;&gt;testecho &quot;a=1&quot; &gt;&gt;testecho &quot;echo set b = 2&quot; &gt;&gt;testecho &quot;b=2&quot; &gt;&gt;testecho &quot;echo set c = a+b&quot; &gt;&gt;testecho &#39;c=$[$a+$b]&#39; &gt;&gt;testecho &#39;echo c = $c&#39; &gt;&gt;testecho &quot;echo save c to ./file1&quot; &gt;&gt;testecho &#39;echo $c&gt;file1&#39; &gt;&gt;testecho &quot;echo save b to ./file2&quot; &gt;&gt;testecho &#39;echo $b&gt;file2&#39; &gt;&gt;testecho &quot;echo save a to ./file3&quot; &gt;&gt;testecho &#39;echo $a&gt;file3&#39; &gt;&gt;testecho &quot;echo save file1 file2 file3 to file 4&quot; &gt;&gt;testecho &quot;cat file1&gt;file4&quot; &gt;&gt;testecho &quot;cat file2&gt;&gt;file4&quot; &gt;&gt;testecho &quot;cat file3&gt;&gt;file4&quot; &gt;&gt;testecho &quot;echo save file4 to ./result&quot; &gt;&gt;testecho &quot;cat file4&gt;&gt;result&quot; &gt;&gt;test<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- ```shell<br><span class="hljs-meta">  #result</span><br>  <span class="hljs-number">3</span><br>  <span class="hljs-number">2</span><br>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>result结果说明</p><ul><li>test文件中，首先给a,b,c分别赋值1,2,3，然后将其倒序分别输入到file1,file2,file3中，然后再将file1,file2,file3正序输入到 result中，从而实现了a,b,c的倒叙输出，即result的结果</li></ul></li><li><p>思考</p><ul><li>echo echo Shell Start 与 echo ‘echo Shell Start’<strong>没有区别</strong>，因为都是字符串</li><li>echo echo $c&gt;file1 与 echo ‘echo $c&gt;file1’<strong>有区别</strong>，因为不加‘’或者使用“”时，会将$c识别成变量，因此在command运行时，因没有定义$c导致输出为空，只有用‘echo $c&gt;file1’，才能将其中内容当作字符串输出。</li></ul></li></ul></li></ul><h4 id="2-实验难点图示"><a href="#2-实验难点图示" class="headerlink" title="2.实验难点图示"></a><strong>2.实验难点图示</strong></h4><ul><li>本次lab0实验暂无</li></ul><h4 id="3-体验与感想"><a href="#3-体验与感想" class="headerlink" title="3.体验与感想"></a>3.体验与感想</h4><ul><li>本次实验，个人认为难度中规中矩，确实达到了lab0指引我们同学初步进入OS学习的目的。在我看来，我通过这一次实验体会到了学习OS的作用与乐趣，在操作中，我逐渐习惯了从图形化到命令行的转变，也初步了解了gcc的编译过程，收获良多。但在简单看了lab1的课下后，我感觉lab0到lab1的跨度好像有亿点点大，所以OS的学习仍是任重而道远。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统实验报告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
