

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/null">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ZhaoYanguang">
  <meta name="keywords" content="">
  
    <meta name="description" content="lab3摘要​	lab3主要是初步写进程，大体分为进程基础架构以及异常与进程调度两个部分。 进程基础架构什么是进程？ 进程即是基本的分配单元，也是基本的执行单元，每个进程有自己的地址空间。执行中的程序就是进程  进程控制块（PBC）​	进程控制块的具体实现是Env结构体，记录了对应进程的特征，用于调度线程时提供进程信息。  Env组成 struct Trapframe env_tf Trapfra">
<meta property="og:type" content="article">
<meta property="og:title" content="OSlab3笔记">
<meta property="og:url" content="https://guangstrip.github.io/20220511/OSlab3%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="光">
<meta property="og:description" content="lab3摘要​	lab3主要是初步写进程，大体分为进程基础架构以及异常与进程调度两个部分。 进程基础架构什么是进程？ 进程即是基本的分配单元，也是基本的执行单元，每个进程有自己的地址空间。执行中的程序就是进程  进程控制块（PBC）​	进程控制块的具体实现是Env结构体，记录了对应进程的特征，用于调度线程时提供进程信息。  Env组成 struct Trapframe env_tf Trapfra">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://guangstrip.github.io/20220511/OSlab3%E7%AC%94%E8%AE%B0/Load_icode_mapper.png">
<meta property="og:image" content="https://guangstrip.github.io/20220511/OSlab3%E7%AC%94%E8%AE%B0/3-exception.png">
<meta property="article:published_time" content="2022-05-11T10:40:40.000Z">
<meta property="article:modified_time" content="2022-07-06T10:48:18.085Z">
<meta property="article:author" content="ZhaoYanguang">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://guangstrip.github.io/20220511/OSlab3%E7%AC%94%E8%AE%B0/Load_icode_mapper.png">
  
  
  
  <title>OSlab3笔记 - 光</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"guangstrip.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>光</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/rock.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="OSlab3笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-11 18:40" pubdate>
          2022年5月11日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          13k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          112 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">OSlab3笔记</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="lab3"><a href="#lab3" class="headerlink" title="lab3"></a>lab3</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>​	lab3主要是初步写进程，大体分为<strong>进程基础架构</strong>以及<strong>异常与进程调度</strong>两个部分。</p>
<h2 id="进程基础架构"><a href="#进程基础架构" class="headerlink" title="进程基础架构"></a>进程基础架构</h2><h3 id="什么是进程？"><a href="#什么是进程？" class="headerlink" title="什么是进程？"></a>什么是进程？</h3><ul>
<li>进程即是基本的<strong>分配</strong>单元，也是基本的<strong>执行</strong>单元，每个进程有自己的地址空间。<strong>执行中的程序就是进程</strong></li>
</ul>
<h4 id="进程控制块（PBC）"><a href="#进程控制块（PBC）" class="headerlink" title="进程控制块（PBC）"></a>进程控制块（PBC）</h4><p>​	进程控制块的具体实现是<strong>Env结构体</strong>，记录了对应进程的特征，用于调度线程时提供进程信息。</p>
<ul>
<li>Env组成<ul>
<li><code>struct Trapframe env_tf</code> Trapframe是一个<strong>记录进程上下文环境</strong>的结构体，如寄存器、epc等，当发生进程调度，或异常进入陷入内核时，就将上下文bcopy到该成员中，以供下一次使用</li>
<li><code>LIST_ENTRY(Env) env_link</code> 链表的索引，即field</li>
<li><code>env_id</code> 独一无二的进程id，通常可通过<code>envid2env()</code>获得相应的env进程块</li>
<li><code>env_parent_id</code> 父进程的id</li>
<li><code>env_status</code> 表示该进程的状态，一般有<code>ENV_FREE ENV_NOT_RUNNABLE NEV_RUNNABLE</code>三种状态</li>
<li><code>env_pgdir</code> 保存该进程页目录的内核虚拟地址（每一个内存都有自己的一套虚拟空间）</li>
<li><code>env_cr3</code> 保存该进程页目录的物理地址</li>
<li><code>env_sched_link</code> 同样也是调度队列<code>env_sched_list</code>索引，见后面调度部分</li>
<li><code>env_pri</code> 保存了该进程的优先级，后面我们把pri用来当作该进程所获得的<strong>时间片数</strong></li>
<li>……  其他的组成部分将会在lab4-6中用到，暂不说明</li>
</ul>
</li>
</ul>
<h4 id="Ex3-1-阅读mips-vm-init中为envs数组分配空间的代码"><a href="#Ex3-1-阅读mips-vm-init中为envs数组分配空间的代码" class="headerlink" title="Ex3.1 阅读mips_vm_init中为envs数组分配空间的代码"></a>Ex3.1 阅读<code>mips_vm_init</code>中为envs数组分配空间的代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">envs = (<span class="hljs-keyword">struct</span> Env *)alloc(NENV * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env), BY2PG, <span class="hljs-number">1</span>);<span class="hljs-comment">//为进程块申请内存，共1024个</span><br>n = ROUND(NENV * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Env), BY2PG); <span class="hljs-comment">//NENV个Env的大小n</span><br>boot_map_segment(pgdir, UENVS, n, PADDR(envs), PTE_R); <span class="hljs-comment">//从虚拟内存映射到物理内存，大小为n</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>NENV = (1 &lt;&lt; LOG2NENV) = 1024</code></li>
<li><code>UENVS</code> 见内存图，与<code>UTOP、UXSTACKTOP</code>位于同一位置，内核态存储进程块的位置</li>
</ul>
<h4 id="Ex3-2-填写env-init"><a href="#Ex3-2-填写env-init" class="headerlink" title="Ex3.2 填写env_init"></a>Ex3.2 填写<code>env_init</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>        LIST_INIT(&amp;env_free_list); <span class="hljs-comment">//初始化进程空闲链表</span><br>        LIST_INIT(&amp;env_sched_list[<span class="hljs-number">0</span>]); <span class="hljs-comment">//初始化调度链表，在后续会涉及</span><br>        LIST_INIT(&amp;env_sched_list[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">for</span> (i = NENV<span class="hljs-number">-1</span>; i &gt;=  <span class="hljs-number">0</span>; i--) &#123;<br>                envs[i].env_status = ENV_FREE; <span class="hljs-comment">//修改状态为ENV_FREE</span><br>                LIST_INSERT_HEAD(&amp;env_free_list, &amp;(envs[i]), env_link); <span class="hljs-comment">//插入空闲链表中，要求为倒序</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>该函数是进程的统一<strong>初始化</strong>，初始化空闲链表（这是双向链表的基本方法），将所有env块<strong>倒序</strong>插入该链表中</li>
</ul>
<h3 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h3><p>​	每个进程有一个独一无二的<strong>ASID</strong>，是envid的一部分。因为不同进程可以有相同的虚拟地址，因此在TLB的Key Fields的6-11位会存储其对应的ASID，以保证该页面映射是该进程的，否则就要进行页面替换。</p>
<p>​	进程创建时调用<code>mkenvid</code>来获取独一无二的envid，其中又调用了<code>asid_alloc</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> u_int <span class="hljs-title function_">asid_alloc</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//ASID最多有64个，分别通过两个32位asid_bitmap来标注其是否被申请</span><br>    <span class="hljs-type">int</span> i, index, inner;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i) &#123;<br>        index = i &gt;&gt; <span class="hljs-number">5</span>; <span class="hljs-comment">//0即0-31 1即32-63</span><br>        inner = i &amp; <span class="hljs-number">31</span>; <span class="hljs-comment">//取低32位，即在给asid_bitmap中是哪一位</span><br>        <span class="hljs-keyword">if</span> ((asid_bitmap[index] &amp; (<span class="hljs-number">1</span> &lt;&lt; inner)) == <span class="hljs-number">0</span>) &#123;<br>            asid_bitmap[index] |= <span class="hljs-number">1</span> &lt;&lt; inner;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    panic(<span class="hljs-string">&quot;too many processes!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">u_int <span class="hljs-title function_">mkenvid</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span> &#123;<br>    u_int idx = e - envs; <span class="hljs-comment">//获取是第几个进程</span><br>    u_int asid = asid_alloc(); <span class="hljs-comment">//获取ASID</span><br>    <span class="hljs-keyword">return</span> (asid &lt;&lt; (<span class="hljs-number">1</span> + LOG2NENV)) | (<span class="hljs-number">1</span> &lt;&lt; LOG2NENV) | idx; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	可见<code>env_id</code>由<strong>ASID</strong>和<strong>进程块编号i</strong>组成</p>
<h4 id="Exe3-3-envid2env函数"><a href="#Exe3-3-envid2env函数" class="headerlink" title="Exe3.3 envid2env函数"></a>Exe3.3 envid2env函数</h4><p>​	该函数主要是通过envid获取相应的env进程块，十分常用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">envid2env</span><span class="hljs-params">(u_int envid, <span class="hljs-keyword">struct</span> Env **penv, <span class="hljs-type">int</span> checkperm)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br>        <span class="hljs-keyword">if</span> (!envid) &#123; <span class="hljs-comment">//若传入的envid为0，我们默认然会当前的进程块————curenv</span><br>                *penv = curenv;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                e = &amp;envs[ENVX(envid)]; <span class="hljs-comment">//ENVX即是取出envid中的进程块编号i</span><br>        &#125;<br><br>    <span class="hljs-keyword">if</span> (e-&gt;env_status == ENV_FREE || e-&gt;env_id != envid) &#123;<br>        *penv = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> -E_BAD_ENV; <span class="hljs-comment">//如果该进程并非被创建使用，那么我们报错</span><br>    &#125;<br>    <br>        <span class="hljs-keyword">if</span> (checkperm) &#123; <span class="hljs-comment">//若checkperm，要保证该进程是curenv或其子进程，若不是则报错</span><br>                <span class="hljs-keyword">if</span> (e != curenv &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id) &#123;<br>                        *penv = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">return</span> -E_BAD_ENV;<br>                &#125;<br>        &#125;<br><br>    *penv = e; <span class="hljs-comment">//最后将查询到的进程返回到penv中</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	在调用envid2env函数时，要注意<code>checkperm</code>的值，看清楚是否需要该限制，否则很容易出错。</p>
<h3 id="进程块设置"><a href="#进程块设置" class="headerlink" title="进程块设置"></a>进程块设置</h3><p>​	有了空闲进程块，接下来就是为创建进程时申请并设置其控制块，首先需要调用<code>env_setup_vm</code>为该进程初始化其虚拟空间，然后由env_alloc完成进程快的其余设置</p>
<h4 id="Ex3-4-env-setup-vm"><a href="#Ex3-4-env-setup-vm" class="headerlink" title="Ex3.4 env _setup_vm"></a>Ex3.4 env _setup_vm</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span><br><span class="hljs-title function_">env_setup_vm</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;<br><br>    <span class="hljs-type">int</span> i, r;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br>    Pde *pgdir;<br><br>    <span class="hljs-keyword">if</span> (r = page_alloc(&amp;p) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//为该进程的页目录申请一个Page</span><br>        panic(<span class="hljs-string">&quot;env_setup_vm - page alloc error\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>        p-&gt;pp_ref++; <span class="hljs-comment">//增加该页面的引用数</span><br>        pgdir = (Pde*) page2kva(p); <br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>;i &lt; PDX(UTOP);i++) &#123;<br>                pgdir[i] = <span class="hljs-number">0</span>; <span class="hljs-comment">//将UTOP前的页表清零</span><br>        &#125;<br>    <br>        <span class="hljs-keyword">for</span> (i = PDX(UTOP);i &lt; PTE2PT;i++) &#123; <span class="hljs-comment">//UTOP后的内容是系统内容，所有页表应保持一致</span><br>                <span class="hljs-keyword">if</span> (i != PDX(UVPT)) &#123;<br>                        pgdir[i] = boot_pgdir[i]; <br>                &#125;<br>        &#125;<br>        e-&gt;env_pgdir = pgdir; <span class="hljs-comment">//别忘了前面都是临时变量，我们最后要将其记录到进程块中</span><br>        e-&gt;env_cr3 = PADDR(pgdir);<br><span class="hljs-comment">/* UVPT maps the env&#x27;s own page table, with read-only permission.*/</span><br>    e-&gt;env_pgdir[PDX(UVPT)]  = e-&gt;env_cr3 | PTE_V; <span class="hljs-comment">//VPT是页目录的地址，进行权限设置</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​	操作系统将一些内核的数据暴露到用户空间，使得进程不需要切换到内核态就能访问，这也是MOS的微内核设计。而这里我们要暴露的空间是UTOP以上ULIM以下的部分，也就是把这部分内存对应的内核页表拷贝到进程页表中。</p>
<h4 id="Ex3-5-env-alloc"><a href="#Ex3-5-env-alloc" class="headerlink" title="Ex3.5 env_alloc"></a>Ex3.5 env_alloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">env_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env **new, u_int parent_id)</span><br>&#123;<br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br><br>        <span class="hljs-keyword">if</span> (LIST_EMPTY(&amp;env_free_list)) &#123; <span class="hljs-comment">//获取一个空闲进程块</span><br>                <span class="hljs-keyword">return</span> -E_NO_FREE_ENV;<br>        &#125;<br>        e = LIST_FIRST(&amp;env_free_list);<br><br>        <span class="hljs-keyword">if</span> (r = env_setup_vm(e) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//为该进程块初始化其虚拟空间</span><br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>    <br>        e-&gt;env_id = mkenvid(e);<span class="hljs-comment">//设置envid</span><br>        e-&gt;env_parent_id = parent_id; <span class="hljs-comment">//设置父子关系</span><br>        e-&gt;env_status = ENV_RUNNABLE; <span class="hljs-comment">//该函数是直接由运行程序后调用，因此直接设置状态为ENV_RUNNABLE,</span><br><br>    <span class="hljs-comment">/* Step 4: Focus on initializing the sp register and cp0_status of env_tf field, located at this new Env. */</span><br>    e-&gt;env_tf.cp0_status = <span class="hljs-number">0x10001004</span>; <span class="hljs-comment">//按要求设置相关变量</span><br>        e-&gt;env_tf.regs[<span class="hljs-number">29</span>] = USTACKTOP; <span class="hljs-comment">//设置栈指针指向用户栈，因为进程应处于用户态</span><br><br>        LIST_REMOVE(e, env_link); <br>        *new = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>e-&gt;env_tf.cp0_status = 0x10001004;</code>设置了一下几个功能<ul>
<li>允许用户模式下使用CP0寄存器</li>
<li>表示4号中断可以响应</li>
<li>其余设置涉及中断时的KUc，IEc拷贝后的状态（有点复杂，见指导书）</li>
</ul>
</li>
</ul>
<h3 id="加载程序"><a href="#加载程序" class="headerlink" title="加载程序"></a>加载程序</h3><p>​	首先要明确一个概念，<strong>进程是为了执行程序创建出来的</strong>，而不是莫名其妙创建了放在那里不用。因此这一步的加载二进制镜像，就是为程序分配空间来存程序代码，让该进程凭此来执行程序。</p>
<h4 id="Ex3-6-load-icode-mapper"><a href="#Ex3-6-load-icode-mapper" class="headerlink" title="Ex3.6 load_icode_mapper"></a>Ex3.6 load_icode_mapper</h4><p>load_elf函数已经帮我们完成了ELF文件的解析，而我们需要将ELF文件的各个segment加载到内存中</p>
<p>需要考虑到<del>最恶心人</del>的的情况，个人认为这是lab3最复杂的任务之一</p>
<p><img src="/20220511/OSlab3%E7%AC%94%E8%AE%B0/Load_icode_mapper.png" srcset="/img/loading.gif" lazyload alt="每个segment的加载地址布局"></p>
<ul>
<li>bin_size段需要用bcopy复制，而后面内容因为alloc时已经做了清零，无须再清零，完成映射即可</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">load_icode_mapper</span><span class="hljs-params">(u_long va, <span class="hljs-type">u_int32_t</span> sgsize,</span><br><span class="hljs-params">                             u_char *bin, <span class="hljs-type">u_int32_t</span> bin_size, <span class="hljs-type">void</span> *user_data)</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span> =</span> (<span class="hljs-keyword">struct</span> Env *)user_data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br>	u_long i;<br>    <span class="hljs-type">int</span> r, size<br>    <span class="hljs-comment">//这里是为了处理最开头处在页面一半的位置</span><br>    u_long offset = va - ROUNDDOWN(va, BY2PG);<br>        i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (offset) &#123;<br>                p = page_lookup(env-&gt;env_pgdir, va, <span class="hljs-literal">NULL</span>);<br>                <span class="hljs-keyword">if</span>(!p) &#123;<br>                        <span class="hljs-keyword">if</span> (r = page_alloc(&amp;p) &lt; <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-keyword">return</span> r;<br>                        &#125;<br>                        page_insert(env-&gt;env_pgdir, p, va, PTE_V | PTE_R);<br>                &#125;<br>                size = (BY2PG - offset &lt; bin_size)? (BY2PG - offset) : bin_size;<br>                bcopy((<span class="hljs-type">void</span>*) bin, (<span class="hljs-type">void</span>*) page2kva(p) + offset, size);<br>                i += size;<br>        &#125;<br>    <span class="hljs-comment">//复制binsize内有内容的页面</span><br>    <span class="hljs-keyword">for</span> (; i &lt; bin_size;i += BY2PG) &#123;<br>        <span class="hljs-keyword">if</span> (r = page_alloc(&amp;p) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        size = (BY2PG &lt; bin_size - i)? BY2PG : (bin_size - i); <span class="hljs-comment">//处理最后一个不完整的页面</span><br>        bcopy((<span class="hljs-type">void</span>*) (bin + i), (<span class="hljs-type">void</span>*) page2kva(p), size);<br>        <span class="hljs-keyword">if</span> (r = page_insert(env-&gt;env_pgdir, p, va + i, PTE_V | PTE_R) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//.bss段没有内容，完成页面映射以供后续使用即可</span><br>    <span class="hljs-keyword">while</span> (i &lt; sgsize) &#123;<br>        <span class="hljs-keyword">if</span> (r = page_alloc(&amp;p) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        size = (BY2PG &lt; sgsize - i)? BY2PG : (sgsize - i);<br>        <span class="hljs-keyword">if</span> (r = page_insert(env-&gt;env_pgdir, p, va + i, PTE_V | PTE_R) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        i += BY2PG;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Ex3-7-load-icode"><a href="#Ex3-7-load-icode" class="headerlink" title="Ex3.7 load_icode"></a>Ex3.7 load_icode</h4><p>​	该函数主要任务是为进程创建用户栈，调用<code>load_elf</code>完成程序的复制（其中将<code>load_icode_mapper</code>传入其中，实现了其调用）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">load_icode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e, u_char *binary, u_int size)</span><br>&#123;<br>    <span class="hljs-comment">/* Hint:</span><br><span class="hljs-comment">     *  You must figure out which permissions you&#x27;ll need</span><br><span class="hljs-comment">     *  for the different mappings you create.</span><br><span class="hljs-comment">     *  Remember that the binary image is an a.out format image,</span><br><span class="hljs-comment">     *  which contains both text and data.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Page</span> *<span class="hljs-title">p</span> =</span> <span class="hljs-literal">NULL</span>;<br>    u_long entry_point;<br>    u_long r;<br>    u_long perm;<br><br>    <span class="hljs-comment">/* Step 1: alloc a page. */</span><br>        <span class="hljs-keyword">if</span> (r = page_alloc(&amp;p) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>    <span class="hljs-comment">/* Step 2: Use appropriate perm to set initial stack for new Env. */</span><br>    <span class="hljs-comment">/* Hint: Should the user-stack be writable? */</span><br>        perm = PTE_R;<br>        <span class="hljs-keyword">if</span> (r = page_insert(e-&gt;env_pgdir, p, USTACKTOP - BY2PG, perm) &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>    <span class="hljs-comment">/* Step 3: load the binary using elf loader. */</span><br>        load_elf(binary, size, &amp;entry_point, (<span class="hljs-type">void</span>*) e, load_icode_mapper);<br><br>    <span class="hljs-comment">/* Step 4: Set CPU&#x27;s PC register as appropriate value. */</span><br>    e-&gt;env_tf.pc = entry_point;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>首先要申请一个页面作为该进程的用户栈，用于给elf解析</li>
<li><code>e-&gt;env_tf.pc = entry_point;</code> <ul>
<li><code>e-&gt;env_tf.pc</code>这个字段指示了进程要恢复运行时 pc 应恢复到的位置</li>
<li>运行的进程的代码段预先被载入到了 <code>entry_ point</code> 为起点的内存中</li>
</ul>
</li>
</ul>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>​	完成了进程块的初始化与设置和程序的载入，我们终于可以开始创建进程了！</p>
<p>​	创建过程：分配Env进程块 + 设置进程块 + 程序载入</p>
<h4 id="Ex3-8-env-create-priority-amp-env-create"><a href="#Ex3-8-env-create-priority-amp-env-create" class="headerlink" title="Ex3.8 env_create_priority &amp; env_create"></a>Ex3.8 env_create_priority &amp; env_create</h4><p>​	顾名思义，创建一个进程，并为其设置相应的priority</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">env_create_priority(u_char *binary, <span class="hljs-type">int</span> size, <span class="hljs-type">int</span> priority)<br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">e</span>;</span><br>        <span class="hljs-keyword">if</span> (env_alloc(&amp;e, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//获取一个进程块并设置好</span><br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br>        e-&gt;env_pri = priority; <span class="hljs-comment">//设置priority</span><br>        load_icode(e, binary, size); <span class="hljs-comment">//载入程序</span><br>        LIST_INSERT_HEAD(env_sched_list, e, env_sched_link); <span class="hljs-comment">//在创建进程后我们将其加入调度队列，等待后续的资源分配与调用</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>​	按要求调用<code>env_create_priority</code>即可</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_create</span><span class="hljs-params">(u_char *binary, <span class="hljs-type">int</span> size)</span><br>&#123;<br>     <span class="hljs-comment">/* Step 1: Use env_create_priority to alloc a new env with priority 1 */</span><br>        env_create_priority(binary, size, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//printf(&quot;create end!\n&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Ex3-9-CREATE宏"><a href="#Ex3-9-CREATE宏" class="headerlink" title="Ex3.9 CREATE宏"></a>Ex3.9 CREATE宏</h4><p>​	代码中已经给出了创建进程的封装好的宏命令</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENV_CREATE_PRIORITY(x, y) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">    extern u_char binary_##x##_start[];\</span><br><span class="hljs-meta">    extern u_int binary_##x##_size; \</span><br><span class="hljs-meta">    env_create_priority(binary_##x##_start, \</span><br><span class="hljs-meta">    (u_int)binary_##x##_size, y); \</span><br><span class="hljs-meta">&#125;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENV_CREATE(x) \</span><br><span class="hljs-meta">&#123; \</span><br><span class="hljs-meta">    extern u_char binary_##x##_start[];\</span><br><span class="hljs-meta">    extern u_int binary_##x##_size; \</span><br><span class="hljs-meta">    env_create(binary_##x##_start, \</span><br><span class="hljs-meta">    (u_int)binary_##x##_size); \</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure>

<p>​	当需要创建进程来运行程序时，使用上述宏即可，如<code>ENV_CREATE_PRIORITY(user_A, 2); ENV_CREATE(user_pingpong);</code>等</p>
<h3 id="进程运行与切换"><a href="#进程运行与切换" class="headerlink" title="进程运行与切换"></a>进程运行与切换</h3><p>​	进程能够<strong>切换</strong>是进程使操作系统效率提升的关键，使得系统资源能够合理调度。</p>
<p>​	进程切换 &#x3D; 保存切走进程的上下文 + 恢复切入进程的上下文</p>
<ul>
<li>进程上下文说来就是一个环境，相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、内存信息等。这些内容集合成一个Trapframe，存在进程块的<code>env_tf</code>成员中。</li>
</ul>
<h4 id="Ex3-10-env-run"><a href="#Ex3-10-env-run" class="headerlink" title="Ex3.10 env_run"></a>Ex3.10 env_run</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">env_run</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Env *e)</span><br>&#123;		<span class="hljs-comment">//保存切走进程的上下文，但如果不是当前运行的进程，那就没必要，因为本来就不是它</span><br>    	<span class="hljs-comment">//并设置pc值为epc，因为进程切换是触发了中断的，我们完成切换要跳转到中断后的指令去</span><br>        <span class="hljs-keyword">if</span> (curenv) &#123;<br>                <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trapframe</span> *<span class="hljs-title">old</span>;</span><br>                old = (<span class="hljs-keyword">struct</span> Trapframe *)(TIMESTACK - <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe));                bcopy((<span class="hljs-type">void</span>*) old, (<span class="hljs-type">void</span>*) &amp;(curenv-&gt;env_tf), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Trapframe));<br>                curenv-&gt;env_tf.pc = curenv-&gt;env_tf.cp0_epc;<br>        &#125;<br>		<span class="hljs-comment">//进行切换，将现在运行的进程切换为e</span><br>        curenv = e;<br>		<span class="hljs-comment">//设置全局变量mCONTEXT为当前进程的页目录地址，与TLB重填相关</span><br>        lcontext(e-&gt;env_pgdir);<br>		<span class="hljs-comment">//恢复切入进程的上下文，即一堆寄存器、值等的复制</span><br>        env_pop_tf(&amp;(e-&gt;env_tf), GET_ENV_ASID(e-&gt;env_id));<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Ex3-11-page-init修改"><a href="#Ex3-11-page-init修改" class="headerlink" title="Ex3.11 page_init修改"></a>Ex3.11 page_init修改</h4><p>​	由于我们寄存器的值保存在TIMESTACK对应的页面，如不特殊处理其可能也会被进程占用，因此要保证其安全，在page_init中进行修改</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (i = g; i &lt; npage; i++) &#123;<br>                <span class="hljs-keyword">if</span> (page2kva(&amp;pages[i]) != TIMESTACK) &#123; <span class="hljs-comment">//保证TIMESTACK对应页面不空闲，不会被占用</span><br>                        pages[i].pp_ref = <span class="hljs-number">0</span>;<br>                        LIST_INSERT_HEAD(&amp;page_free_list, &amp;(pages[i]), pp_link);<br>                &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>

<h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="控制寄存器CP0"><a href="#控制寄存器CP0" class="headerlink" title="控制寄存器CP0"></a>控制寄存器CP0</h4><table>
<thead>
<tr>
<th>寄存器助记符</th>
<th>CP0寄存器编号</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SR</td>
<td>12</td>
<td>状态寄存器，包括中断引脚使能，其他 CPU 模式等位域</td>
</tr>
<tr>
<td>Cause</td>
<td>13</td>
<td>记录导致异常的原因</td>
</tr>
<tr>
<td>EPC</td>
<td>14</td>
<td>异常结束后程序恢复执行的位置</td>
</tr>
</tbody></table>
<ul>
<li>SR 寄存器：15-8 位为中断屏蔽位，每一位代表一个不同的中断活动，其中 15-10 位使能外部中断源，9-8 位是 Cause 寄存器软件可写的中断位。</li>
<li>Cause 寄存器：其中保存着 CPU 中哪一些中断或者异常已经发生。15-8 位保存着哪一些中断发生了，其中 15-10 位来自硬件，9-8 位可以由软件写入，当 SR 寄存器中相同位允许中断（为 1）时，Cause 寄存器这一位活动就会导致中断。6-2 位（ExcCode），记录发生了什么异常。</li>
</ul>
<h4 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h4><ol>
<li>设置 EPC 指向异常结束时重新返回的地址。</li>
<li>设置 SR 位，强制 CPU 进入内核态（行驶更高级的特权）并禁止中断。</li>
<li>设置 Cause 寄存器，用于记录异常发生的原因。</li>
<li>CPU 开始从异常入口位置取指，此后一切交给软件处理。</li>
</ol>
<p><img src="/20220511/OSlab3%E7%AC%94%E8%AE%B0/3-exception.png" srcset="/img/loading.gif" lazyload alt="异常处理图示"></p>
<p>软件处理就是我们接下来要完成的东西：）</p>
<h3 id="异常分发"><a href="#异常分发" class="headerlink" title="异常分发"></a>异常分发</h3><p>​	异常分发代码流程如下：</p>
<ol>
<li>将 CP0_CAUSE 寄存器的内容拷贝到 k1 寄存器中。</li>
<li>将 execption_handlers 基地址拷贝到 k0。</li>
<li>取得 CP0_CAUSE 中的 2~6 位，也就是对应的异常码，这是区别不同异常的重要标志。</li>
<li>以得到的异常码作为索引去 exception_handlers 数组中找到对应的中断处理函数，后文中会有涉及。</li>
<li>跳转到对应的中断处理函数中，从而响应了异常，并将异常交给了对应的异常处理函数去处理。</li>
</ol>
<h4 id="Ex3-12-异常分发代码"><a href="#Ex3-12-异常分发代码" class="headerlink" title="Ex3.12 异常分发代码"></a>Ex3.12 异常分发代码</h4><p>​	操作如上（添加至boot&#x2F;start.S中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.section .text.exc_vec3<br>NESTED(except_vec3, 0, sp)<br>    .set noat <br>    .set noreorder<br>1:<br>    mfc0 k1,CP0_CAUSE<br>    la k0,exception_handlers<br>    andi k1,0x7c<br>    addu k0,k1<br>    lw k0,(k0)<br>    nop<br>    jr k0<br>    nop<br>END(except_vec3)<br>.set at<br></code></pre></td></tr></table></figure>

<h4 id="Ex3-13-异常代码分发跳转"><a href="#Ex3-13-异常代码分发跳转" class="headerlink" title="Ex3.13 异常代码分发跳转"></a>Ex3.13 异常代码分发跳转</h4><p>​	<code>.text.exc_vec3</code> 段需要被链接器放到特定的位置，在 R3000 中这一段是要求放到地址 0x80000080 处，这个地址处存放的是异常处理程序的入口地址。一旦 CPU 发生异常，就会自动跳转到地址 0x80000080 处，开始执行。(添加至tools&#x2F;scse0_3.lds中)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">. = 0x80000080;<br>.except_vec3 : &#123;<br>    *(.text.exc_vec3)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="异常向量组"><a href="#异常向量组" class="headerlink" title="异常向量组"></a>异常向量组</h3><p>​	<code>exception_handlers</code>称作异常向量组，用于跳转到不同异常的处理程序中</p>
<p>​	lib&#x2F;traps.c中的trap_init函数实现了对全局变量 exception_handlers[32] 数组初始化的工作，即通过把相应处理函数的地址填到对应数组项中，初始化了如下异常：</p>
<ul>
<li><strong>0 号异常</strong>的处理函数为<code>handle_int</code>，表示中断，由时钟中断、控制台中断等中断造成</li>
<li><strong>1 号异常</strong>的处理函数为<code>handle_mod</code>，表示存储异常，进行存储操作时该页被标记为只读</li>
<li><strong>2 号异常</strong>的处理函数为<code>handle_tlb</code>，TLB 异常，TLB 中没有和程序地址匹配的有效入口</li>
<li><strong>3 号异常</strong>的处理函数为<code>handle_tlb</code>，TLB 异常，TLB 失效，且未处于异常模式（用于提高处理效率）</li>
<li><strong>8 号异常</strong>的处理函数为<code>handle_sys</code>，系统调用，陷入内核，执行了 syscall 指令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handle_int</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handle_reserved</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handle_tlb</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handle_sys</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">handle_mod</span><span class="hljs-params">()</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> exception_handlers[<span class="hljs-number">32</span>];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trap_init</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>        set_except_vector(i, handle_reserved);<br>    &#125;<br><br>    set_except_vector(<span class="hljs-number">0</span>, handle_int);<br>    set_except_vector(<span class="hljs-number">1</span>, handle_mod);<br>    set_except_vector(<span class="hljs-number">2</span>, handle_tlb);<br>    set_except_vector(<span class="hljs-number">3</span>, handle_tlb);<br>    set_except_vector(<span class="hljs-number">8</span>, handle_sys);<br>&#125;<br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">set_except_vector</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">void</span> *addr)</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> handler = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)addr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> old_handler = exception_handlers[n];<br>    exception_handlers[n] = handler;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *)old_handler;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h3><p>​	前面只是初步涉及到了异常的处理，但我们核心的任务在于中断的处理，因为操作系统的<strong>时间片</strong>运行、进程切换都是依托于时钟中断来实现的，因此十分重要。</p>
<h4 id="中断的处理流程"><a href="#中断的处理流程" class="headerlink" title="中断的处理流程"></a>中断的处理流程</h4><ol>
<li>将当前 PC 地址存入 CP0 中的 EPC 寄存器。</li>
<li>将 IEc,KUc 拷贝至 KUp 和IEp 中，同时将 IEc 置为 0，表示关闭全局中断使能，将 KUc 置 1，表示处于内核态。</li>
<li>在 Cause 寄存器中，保存 ExcCode 段。由于此处是中断异常，对应的异常码即为 0。</li>
<li>PC 转入异常分发程序入口。</li>
<li>通过异常分发，判断出当前异常为中断异常，随后进入相应的中断处理程序。在MOS 中即对应 handle_int 函数。</li>
<li>在中断处理程序中进一步判断 CP0_CAUSE 寄存器中是由几号中断位引发的中断，然后进入不同中断对应的中断服务函数。</li>
<li>中断处理完成，将 EPC 的值取出到 PC 中，恢复 SR 中相应的中断使能，继续执行。</li>
</ol>
<p>其中1-4以及第7步已由CPU完成，5-6步则需要我们来实现完成时钟中断（其实也就一点点需要我们来做</p>
<h4 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h4><p>​	时钟中断和操作系统的时间片轮转算法是紧密相关的。时间片轮转调度是一种很公平的算法。每个进程被分配一个时间段，称作它的<strong>时间片</strong>，即该进程允许运行的时间。<strong>如果在时间片结束时进程还在运行，则该进程将挂起，切换到另一个进程运行。</strong>那么 CPU是如何知晓一个进程的时间片结束的呢？就是<strong>通过定时器产生的时钟中断。当时钟中断产生时，当前运行的进程被挂起，我们需要在调度队列中选取一个合适的进程运行。</strong>如何“选取”，就要涉及到进程的调度了。</p>
<h4 id="时钟中断的模拟"><a href="#时钟中断的模拟" class="headerlink" title="时钟中断的模拟"></a>时钟中断的模拟</h4><p>kclock_init 函数完成了时钟的初始化，该函数主要调用 set_timer 函数，完成如下操作：</p>
<ul>
<li>首先向0xb5000100 位置写入0xc8，其中0xb5000000 是模拟器(gxemul) 映射实时钟的位置。偏移量为0x100 表示来设置实时钟中断的频率，0xc8 则表示1 秒钟中断200次，如果写入0，表示关闭实时钟。实时钟对于R3000 来说绑定到了4 号中断上，故这段代码其实主要用来触发了<strong>4 号中断</strong>。</li>
<li>一旦实时钟中断产生，就会触发MIPS 中断，从而MIPS 将PC 指向0x80000080，从而跳转到.text.exc_vec3代码段执行。对于实时钟引起的中断，通过.text.exc_vec3代码段的分发，最终会调用handle_ int 函数来处理实时钟中断。</li>
<li>在handle_ int 判断CP0_CAUSE寄存器是不是对应的4 号中断位引发的中断，如果是，则执行中断服务函数timer_ irq(在genex.S)。</li>
<li>在timer_ irq 里直接跳转到sched_ yield 中执行。而这个函数就是我们将要补充的调度函数，后面会完成。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs assembly">timer_irq:<br><br>        sb zero, 0xb5000110<br>1:      j       sched_yield<br>        nop<br>        /*li t1, 0xff<br>        lw    t0, delay<br>        addu  t0, 1<br>        sw      t0, delay<br>        beq     t0,t1,1f        <br>        nop*/<br>        j       ret_from_exception<br>        nop<br></code></pre></td></tr></table></figure>

<h4 id="Ex3-14-kclock-init"><a href="#Ex3-14-kclock-init" class="headerlink" title="Ex3.14 kclock_init"></a>Ex3.14 kclock_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">kclock_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-comment">// hint: use set_timer()</span><br>        set_timer();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>​	handle_int 函数的最后跳转到了 sched_ yield 函数执行调度，调度的算法很简单，就是时间片轮转的算法。</p>
<h4 id="Ex3-15-sched-c"><a href="#Ex3-15-sched-c" class="headerlink" title="Ex3.15 sched.c"></a>Ex3.15 sched.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env_list</span> <span class="hljs-title">env_sched_list</span>[];</span><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span>* <span class="hljs-title">curenv</span>;</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">sched_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// remaining time slices of current env</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> point = <span class="hljs-number">0</span>; <span class="hljs-comment">// current env_sched_list index</span><br>        <span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Env</span> *<span class="hljs-title">env</span> =</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span> (count &lt;= <span class="hljs-number">0</span> || env == <span class="hljs-literal">NULL</span> || (env != <span class="hljs-literal">NULL</span> &amp;&amp; env-&gt;env_status != ENV_RUNNABLE)) &#123;<br>                count = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (env != <span class="hljs-literal">NULL</span>) &#123;<br>                        LIST_REMOVE(env, env_sched_link);<br>                        <span class="hljs-keyword">if</span> (env-&gt;env_status != ENV_FREE) &#123;<br>                                LIST_INSERT_TAIL(&amp;env_sched_list[<span class="hljs-number">1</span>-point], env, env_sched_link);<br>                        &#125; <br>                &#125;<br>                <span class="hljs-keyword">if</span> (LIST_EMPTY(&amp;env_sched_list[point])) &#123;<br>                        point = <span class="hljs-number">1</span> - point;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (LIST_EMPTY(&amp;env_sched_list[point])) &#123;<br>                        <span class="hljs-comment">//panic(&quot;^^^^^^^there is no runnable env^^^^^^^by sched_yield&quot;);</span><br>                        <span class="hljs-keyword">continue</span>; <br>                &#125;<br>                env = LIST_FIRST(&amp;env_sched_list[point]);<br>                <span class="hljs-keyword">if</span> (env != <span class="hljs-literal">NULL</span>) &#123;<br>                        count = env-&gt;env_pri;<br>                &#125;<br>        &#125;<br>        count--;<br>        env_run(env);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>我们规定其数值表示进程每次运行的时间片数量</li>
<li>用两个链表存储所有参与调度进程。当进程被创建时，我们要将其插入第一个进程调度链表的头部。调用 sched_yield函数时，先判断当前时间片是否用完。如果用完，将其插入另一个进程调度链表的尾部。之后判断当前进程调度链表是否为空。如果为空，切换到另一个进程调度链表。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/" class="category-chain-item">操作系统实验笔记</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">#操作系统</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>OSlab3笔记</div>
      <div>https://guangstrip.github.io/20220511/OSlab3笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ZhaoYanguang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月11日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
              <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
              <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                <i class="iconfont icon-sa"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/20220515/OSlab3%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/" title="OSlab3实验报告">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">OSlab3实验报告</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/20220503/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93/" title="OO第二单元总结">
                        <span class="hidden-mobile">OO第二单元总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
